(function () {
window.WebComponents = window.WebComponents || { flags: {} };
var file = 'webcomponents.js';
var script = document.querySelector('script[src*="' + file + '"]');
var flags = {};
if (!flags.noOpts) {
location.search.slice(1).split('&').forEach(function (option) {
var parts = option.split('=');
var match;
if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
flags[match[1]] = parts[1] || true;
}
});
if (script) {
for (var i = 0, a; a = script.attributes[i]; i++) {
if (a.name !== 'src') {
flags[a.name] = a.value || true;
}
}
}
if (flags.log && flags.log.split) {
var parts = flags.log.split(',');
flags.log = {};
parts.forEach(function (f) {
flags.log[f] = true;
});
} else {
flags.log = {};
}
}
flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;
if (flags.shadow === 'native') {
flags.shadow = false;
} else {
flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;
}
if (flags.register) {
window.CustomElements = window.CustomElements || { flags: {} };
window.CustomElements.flags.register = flags.register;
}
WebComponents.flags = flags;
}());
if (WebComponents.flags.shadow) {
if (typeof WeakMap === 'undefined') {
(function () {
var defineProperty = Object.defineProperty;
var counter = Date.now() % 1000000000;
var WeakMap = function () {
this.name = '__st' + (Math.random() * 1000000000 >>> 0) + (counter++ + '__');
};
WeakMap.prototype = {
set: function (key, value) {
var entry = key[this.name];
if (entry && entry[0] === key)
entry[1] = value;
else
defineProperty(key, this.name, {
value: [
key,
value
],
writable: true
});
return this;
},
get: function (key) {
var entry;
return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
},
'delete': function (key) {
var entry = key[this.name];
if (!entry || entry[0] !== key)
return false;
entry[0] = entry[1] = undefined;
return true;
},
has: function (key) {
var entry = key[this.name];
if (!entry)
return false;
return entry[0] === key;
}
};
window.WeakMap = WeakMap;
}());
}
window.ShadowDOMPolyfill = {};
(function (scope) {
'use strict';
var constructorTable = new WeakMap();
var nativePrototypeTable = new WeakMap();
var wrappers = Object.create(null);
function detectEval() {
if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
return false;
}
if (navigator.getDeviceStorage) {
return false;
}
try {
var f = new Function('return true;');
return f();
} catch (ex) {
return false;
}
}
var hasEval = detectEval();
function assert(b) {
if (!b)
throw new Error('Assertion failed');
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function mixin(to, from) {
var names = getOwnPropertyNames(from);
for (var i = 0; i < names.length; i++) {
var name = names[i];
defineProperty(to, name, getOwnPropertyDescriptor(from, name));
}
return to;
}
function mixinStatics(to, from) {
var names = getOwnPropertyNames(from);
for (var i = 0; i < names.length; i++) {
var name = names[i];
switch (name) {
case 'arguments':
case 'caller':
case 'length':
case 'name':
case 'prototype':
case 'toString':
continue;
}
defineProperty(to, name, getOwnPropertyDescriptor(from, name));
}
return to;
}
function oneOf(object, propertyNames) {
for (var i = 0; i < propertyNames.length; i++) {
if (propertyNames[i] in object)
return propertyNames[i];
}
}
var nonEnumerableDataDescriptor = {
value: undefined,
configurable: true,
enumerable: false,
writable: true
};
function defineNonEnumerableDataProperty(object, name, value) {
nonEnumerableDataDescriptor.value = value;
defineProperty(object, name, nonEnumerableDataDescriptor);
}
getOwnPropertyNames(window);
function getWrapperConstructor(node, opt_instance) {
var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);
if (isFirefox) {
try {
getOwnPropertyNames(nativePrototype);
} catch (error) {
nativePrototype = nativePrototype.__proto__;
}
}
var wrapperConstructor = constructorTable.get(nativePrototype);
if (wrapperConstructor)
return wrapperConstructor;
var parentWrapperConstructor = getWrapperConstructor(nativePrototype);
var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);
registerInternal(nativePrototype, GeneratedWrapper, opt_instance);
return GeneratedWrapper;
}
function addForwardingProperties(nativePrototype, wrapperPrototype) {
installProperty(nativePrototype, wrapperPrototype, true);
}
function registerInstanceProperties(wrapperPrototype, instanceObject) {
installProperty(instanceObject, wrapperPrototype, false);
}
var isFirefox = /Firefox/.test(navigator.userAgent);
var dummyDescriptor = {
get: function () {
},
set: function (v) {
},
configurable: true,
enumerable: true
};
function isEventHandlerName(name) {
return /^on[a-z]+$/.test(name);
}
function isIdentifierName(name) {
return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);
}
function getGetter(name) {
return hasEval && isIdentifierName(name) ? new Function('return this.__impl4cf1e782hg__.' + name) : function () {
return this.__impl4cf1e782hg__[name];
};
}
function getSetter(name) {
return hasEval && isIdentifierName(name) ? new Function('v', 'this.__impl4cf1e782hg__.' + name + ' = v') : function (v) {
this.__impl4cf1e782hg__[name] = v;
};
}
function getMethod(name) {
return hasEval && isIdentifierName(name) ? new Function('return this.__impl4cf1e782hg__.' + name + '.apply(this.__impl4cf1e782hg__, arguments)') : function () {
return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);
};
}
function getDescriptor(source, name) {
try {
if (source === window && name === 'showModalDialog') {
return dummyDescriptor;
}
return Object.getOwnPropertyDescriptor(source, name);
} catch (ex) {
return dummyDescriptor;
}
}
var isBrokenSafari = function () {
var descr = Object.getOwnPropertyDescriptor(Node.prototype, 'nodeType');
return descr && !descr.get && !descr.set;
}();
function installProperty(source, target, allowMethod, opt_blacklist) {
var names = getOwnPropertyNames(source);
for (var i = 0; i < names.length; i++) {
var name = names[i];
if (name === 'polymerBlackList_')
continue;
if (name in target)
continue;
if (source.polymerBlackList_ && source.polymerBlackList_[name])
continue;
if (isFirefox) {
source.__lookupGetter__(name);
}
var descriptor = getDescriptor(source, name);
var getter, setter;
if (typeof descriptor.value === 'function') {
if (allowMethod) {
target[name] = getMethod(name);
}
continue;
}
var isEvent = isEventHandlerName(name);
if (isEvent)
getter = scope.getEventHandlerGetter(name);
else
getter = getGetter(name);
if (descriptor.writable || descriptor.set || isBrokenSafari) {
if (isEvent)
setter = scope.getEventHandlerSetter(name);
else
setter = getSetter(name);
}
var configurable = isBrokenSafari || descriptor.configurable;
defineProperty(target, name, {
get: getter,
set: setter,
configurable: configurable,
enumerable: descriptor.enumerable
});
}
}
function register(nativeConstructor, wrapperConstructor, opt_instance) {
if (nativeConstructor == null) {
return;
}
var nativePrototype = nativeConstructor.prototype;
registerInternal(nativePrototype, wrapperConstructor, opt_instance);
mixinStatics(wrapperConstructor, nativeConstructor);
}
function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {
var wrapperPrototype = wrapperConstructor.prototype;
assert(constructorTable.get(nativePrototype) === undefined);
constructorTable.set(nativePrototype, wrapperConstructor);
nativePrototypeTable.set(wrapperPrototype, nativePrototype);
addForwardingProperties(nativePrototype, wrapperPrototype);
if (opt_instance)
registerInstanceProperties(wrapperPrototype, opt_instance);
defineNonEnumerableDataProperty(wrapperPrototype, 'constructor', wrapperConstructor);
wrapperConstructor.prototype = wrapperPrototype;
}
function isWrapperFor(wrapperConstructor, nativeConstructor) {
return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;
}
function registerObject(object) {
var nativePrototype = Object.getPrototypeOf(object);
var superWrapperConstructor = getWrapperConstructor(nativePrototype);
var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);
registerInternal(nativePrototype, GeneratedWrapper, object);
return GeneratedWrapper;
}
function createWrapperConstructor(superWrapperConstructor) {
function GeneratedWrapper(node) {
superWrapperConstructor.call(this, node);
}
var p = Object.create(superWrapperConstructor.prototype);
p.constructor = GeneratedWrapper;
GeneratedWrapper.prototype = p;
return GeneratedWrapper;
}
function isWrapper(object) {
return object && object.__impl4cf1e782hg__;
}
function isNative(object) {
return !isWrapper(object);
}
function wrap(impl) {
if (impl === null)
return null;
assert(isNative(impl));
var wrapper = impl.__wrapper8e3dd93a60__;
if (wrapper != null) {
return wrapper;
}
return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);
}
function unwrap(wrapper) {
if (wrapper === null)
return null;
assert(isWrapper(wrapper));
return wrapper.__impl4cf1e782hg__;
}
function unsafeUnwrap(wrapper) {
return wrapper.__impl4cf1e782hg__;
}
function setWrapper(impl, wrapper) {
wrapper.__impl4cf1e782hg__ = impl;
impl.__wrapper8e3dd93a60__ = wrapper;
}
function unwrapIfNeeded(object) {
return object && isWrapper(object) ? unwrap(object) : object;
}
function wrapIfNeeded(object) {
return object && !isWrapper(object) ? wrap(object) : object;
}
function rewrap(node, wrapper) {
if (wrapper === null)
return;
assert(isNative(node));
assert(wrapper === undefined || isWrapper(wrapper));
node.__wrapper8e3dd93a60__ = wrapper;
}
var getterDescriptor = {
get: undefined,
configurable: true,
enumerable: true
};
function defineGetter(constructor, name, getter) {
getterDescriptor.get = getter;
defineProperty(constructor.prototype, name, getterDescriptor);
}
function defineWrapGetter(constructor, name) {
defineGetter(constructor, name, function () {
return wrap(this.__impl4cf1e782hg__[name]);
});
}
function forwardMethodsToWrapper(constructors, names) {
constructors.forEach(function (constructor) {
names.forEach(function (name) {
constructor.prototype[name] = function () {
var w = wrapIfNeeded(this);
return w[name].apply(w, arguments);
};
});
});
}
scope.addForwardingProperties = addForwardingProperties;
scope.assert = assert;
scope.constructorTable = constructorTable;
scope.defineGetter = defineGetter;
scope.defineWrapGetter = defineWrapGetter;
scope.forwardMethodsToWrapper = forwardMethodsToWrapper;
scope.isIdentifierName = isIdentifierName;
scope.isWrapper = isWrapper;
scope.isWrapperFor = isWrapperFor;
scope.mixin = mixin;
scope.nativePrototypeTable = nativePrototypeTable;
scope.oneOf = oneOf;
scope.registerObject = registerObject;
scope.registerWrapper = register;
scope.rewrap = rewrap;
scope.setWrapper = setWrapper;
scope.unsafeUnwrap = unsafeUnwrap;
scope.unwrap = unwrap;
scope.unwrapIfNeeded = unwrapIfNeeded;
scope.wrap = wrap;
scope.wrapIfNeeded = wrapIfNeeded;
scope.wrappers = wrappers;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
scope.ArraySplice = ArraySplice;
}(window.ShadowDOMPolyfill));
(function (context) {
'use strict';
var OriginalMutationObserver = window.MutationObserver;
var callbacks = [];
var pending = false;
var timerFunc;
function handle() {
pending = false;
var copies = callbacks.slice(0);
callbacks = [];
for (var i = 0; i < copies.length; i++) {
(0, copies[i])();
}
}
if (OriginalMutationObserver) {
var counter = 1;
var observer = new OriginalMutationObserver(handle);
var textNode = document.createTextNode(counter);
observer.observe(textNode, { characterData: true });
timerFunc = function () {
counter = (counter + 1) % 2;
textNode.data = counter;
};
} else {
timerFunc = window.setTimeout;
}
function setEndOfMicrotask(func) {
callbacks.push(func);
if (pending)
return;
pending = true;
timerFunc(handle, 0);
}
context.setEndOfMicrotask = setEndOfMicrotask;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var setEndOfMicrotask = scope.setEndOfMicrotask;
var wrapIfNeeded = scope.wrapIfNeeded;
var wrappers = scope.wrappers;
var registrationsTable = new WeakMap();
var globalMutationObservers = [];
var isScheduled = false;
function scheduleCallback(observer) {
if (observer.scheduled_)
return;
observer.scheduled_ = true;
globalMutationObservers.push(observer);
if (isScheduled)
return;
setEndOfMicrotask(notifyObservers);
isScheduled = true;
}
function notifyObservers() {
isScheduled = false;
while (globalMutationObservers.length) {
var notifyList = globalMutationObservers;
globalMutationObservers = [];
notifyList.sort(function (x, y) {
return x.uid_ - y.uid_;
});
for (var i = 0; i < notifyList.length; i++) {
var mo = notifyList[i];
mo.scheduled_ = false;
var queue = mo.takeRecords();
removeTransientObserversFor(mo);
if (queue.length) {
mo.callback_(queue, mo);
}
}
}
}
function MutationRecord(type, target) {
this.type = type;
this.target = target;
this.addedNodes = new wrappers.NodeList();
this.removedNodes = new wrappers.NodeList();
this.previousSibling = null;
this.nextSibling = null;
this.attributeName = null;
this.attributeNamespace = null;
this.oldValue = null;
}
function registerTransientObservers(ancestor, node) {
for (; ancestor; ancestor = ancestor.parentNode) {
var registrations = registrationsTable.get(ancestor);
if (!registrations)
continue;
for (var i = 0; i < registrations.length; i++) {
var registration = registrations[i];
if (registration.options.subtree)
registration.addTransientObserver(node);
}
}
}
function removeTransientObserversFor(observer) {
for (var i = 0; i < observer.nodes_.length; i++) {
var node = observer.nodes_[i];
var registrations = registrationsTable.get(node);
if (!registrations)
return;
for (var j = 0; j < registrations.length; j++) {
var registration = registrations[j];
if (registration.observer === observer)
registration.removeTransientObservers();
}
}
}
function enqueueMutation(target, type, data) {
var interestedObservers = Object.create(null);
var associatedStrings = Object.create(null);
for (var node = target; node; node = node.parentNode) {
var registrations = registrationsTable.get(node);
if (!registrations)
continue;
for (var j = 0; j < registrations.length; j++) {
var registration = registrations[j];
var options = registration.options;
if (node !== target && !options.subtree)
continue;
if (type === 'attributes' && !options.attributes)
continue;
if (type === 'attributes' && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {
continue;
}
if (type === 'characterData' && !options.characterData)
continue;
if (type === 'childList' && !options.childList)
continue;
var observer = registration.observer;
interestedObservers[observer.uid_] = observer;
if (type === 'attributes' && options.attributeOldValue || type === 'characterData' && options.characterDataOldValue) {
associatedStrings[observer.uid_] = data.oldValue;
}
}
}
for (var uid in interestedObservers) {
var observer = interestedObservers[uid];
var record = new MutationRecord(type, target);
if ('name' in data && 'namespace' in data) {
record.attributeName = data.name;
record.attributeNamespace = data.namespace;
}
if (data.addedNodes)
record.addedNodes = data.addedNodes;
if (data.removedNodes)
record.removedNodes = data.removedNodes;
if (data.previousSibling)
record.previousSibling = data.previousSibling;
if (data.nextSibling)
record.nextSibling = data.nextSibling;
if (associatedStrings[uid] !== undefined)
record.oldValue = associatedStrings[uid];
scheduleCallback(observer);
observer.records_.push(record);
}
}
var slice = Array.prototype.slice;
function MutationObserverOptions(options) {
this.childList = !!options.childList;
this.subtree = !!options.subtree;
if (!('attributes' in options) && ('attributeOldValue' in options || 'attributeFilter' in options)) {
this.attributes = true;
} else {
this.attributes = !!options.attributes;
}
if ('characterDataOldValue' in options && !('characterData' in options))
this.characterData = true;
else
this.characterData = !!options.characterData;
if (!this.attributes && (options.attributeOldValue || 'attributeFilter' in options) || !this.characterData && options.characterDataOldValue) {
throw new TypeError();
}
this.characterData = !!options.characterData;
this.attributeOldValue = !!options.attributeOldValue;
this.characterDataOldValue = !!options.characterDataOldValue;
if ('attributeFilter' in options) {
if (options.attributeFilter == null || typeof options.attributeFilter !== 'object') {
throw new TypeError();
}
this.attributeFilter = slice.call(options.attributeFilter);
} else {
this.attributeFilter = null;
}
}
var uidCounter = 0;
function MutationObserver(callback) {
this.callback_ = callback;
this.nodes_ = [];
this.records_ = [];
this.uid_ = ++uidCounter;
this.scheduled_ = false;
}
MutationObserver.prototype = {
constructor: MutationObserver,
observe: function (target, options) {
target = wrapIfNeeded(target);
var newOptions = new MutationObserverOptions(options);
var registration;
var registrations = registrationsTable.get(target);
if (!registrations)
registrationsTable.set(target, registrations = []);
for (var i = 0; i < registrations.length; i++) {
if (registrations[i].observer === this) {
registration = registrations[i];
registration.removeTransientObservers();
registration.options = newOptions;
}
}
if (!registration) {
registration = new Registration(this, target, newOptions);
registrations.push(registration);
this.nodes_.push(target);
}
},
disconnect: function () {
this.nodes_.forEach(function (node) {
var registrations = registrationsTable.get(node);
for (var i = 0; i < registrations.length; i++) {
var registration = registrations[i];
if (registration.observer === this) {
registrations.splice(i, 1);
break;
}
}
}, this);
this.records_ = [];
},
takeRecords: function () {
var copyOfRecords = this.records_;
this.records_ = [];
return copyOfRecords;
}
};
function Registration(observer, target, options) {
this.observer = observer;
this.target = target;
this.options = options;
this.transientObservedNodes = [];
}
Registration.prototype = {
addTransientObserver: function (node) {
if (node === this.target)
return;
scheduleCallback(this.observer);
this.transientObservedNodes.push(node);
var registrations = registrationsTable.get(node);
if (!registrations)
registrationsTable.set(node, registrations = []);
registrations.push(this);
},
removeTransientObservers: function () {
var transientObservedNodes = this.transientObservedNodes;
this.transientObservedNodes = [];
for (var i = 0; i < transientObservedNodes.length; i++) {
var node = transientObservedNodes[i];
var registrations = registrationsTable.get(node);
for (var j = 0; j < registrations.length; j++) {
if (registrations[j] === this) {
registrations.splice(j, 1);
break;
}
}
}
}
};
scope.enqueueMutation = enqueueMutation;
scope.registerTransientObservers = registerTransientObservers;
scope.wrappers.MutationObserver = MutationObserver;
scope.wrappers.MutationRecord = MutationRecord;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
function TreeScope(root, parent) {
this.root = root;
this.parent = parent;
}
TreeScope.prototype = {
get renderer() {
if (this.root instanceof scope.wrappers.ShadowRoot) {
return scope.getRendererForHost(this.root.host);
}
return null;
},
contains: function (treeScope) {
for (; treeScope; treeScope = treeScope.parent) {
if (treeScope === this)
return true;
}
return false;
}
};
function setTreeScope(node, treeScope) {
if (node.treeScope_ !== treeScope) {
node.treeScope_ = treeScope;
for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {
sr.treeScope_.parent = treeScope;
}
for (var child = node.firstChild; child; child = child.nextSibling) {
setTreeScope(child, treeScope);
}
}
}
function getTreeScope(node) {
if (node instanceof scope.wrappers.Window) {
debugger;
}
if (node.treeScope_)
return node.treeScope_;
var parent = node.parentNode;
var treeScope;
if (parent)
treeScope = getTreeScope(parent);
else
treeScope = new TreeScope(node, null);
return node.treeScope_ = treeScope;
}
scope.TreeScope = TreeScope;
scope.getTreeScope = getTreeScope;
scope.setTreeScope = setTreeScope;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
var getTreeScope = scope.getTreeScope;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var wrappers = scope.wrappers;
var wrappedFuns = new WeakMap();
var listenersTable = new WeakMap();
var handledEventsTable = new WeakMap();
var currentlyDispatchingEvents = new WeakMap();
var targetTable = new WeakMap();
var currentTargetTable = new WeakMap();
var relatedTargetTable = new WeakMap();
var eventPhaseTable = new WeakMap();
var stopPropagationTable = new WeakMap();
var stopImmediatePropagationTable = new WeakMap();
var eventHandlersTable = new WeakMap();
var eventPathTable = new WeakMap();
function isShadowRoot(node) {
return node instanceof wrappers.ShadowRoot;
}
function rootOfNode(node) {
return getTreeScope(node).root;
}
function getEventPath(node, event) {
var path = [];
var current = node;
path.push(current);
while (current) {
var destinationInsertionPoints = getDestinationInsertionPoints(current);
if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {
for (var i = 0; i < destinationInsertionPoints.length; i++) {
var insertionPoint = destinationInsertionPoints[i];
if (isShadowInsertionPoint(insertionPoint)) {
var shadowRoot = rootOfNode(insertionPoint);
var olderShadowRoot = shadowRoot.olderShadowRoot;
if (olderShadowRoot)
path.push(olderShadowRoot);
}
path.push(insertionPoint);
}
current = destinationInsertionPoints[destinationInsertionPoints.length - 1];
} else {
if (isShadowRoot(current)) {
if (inSameTree(node, current) && eventMustBeStopped(event)) {
break;
}
current = current.host;
path.push(current);
} else {
current = current.parentNode;
if (current)
path.push(current);
}
}
}
return path;
}
function eventMustBeStopped(event) {
if (!event)
return false;
switch (event.type) {
case 'abort':
case 'error':
case 'select':
case 'change':
case 'load':
case 'reset':
case 'resize':
case 'scroll':
case 'selectstart':
return true;
}
return false;
}
function isShadowInsertionPoint(node) {
return node instanceof HTMLShadowElement;
}
function getDestinationInsertionPoints(node) {
return scope.getDestinationInsertionPoints(node);
}
function eventRetargetting(path, currentTarget) {
if (path.length === 0)
return currentTarget;
if (currentTarget instanceof wrappers.Window)
currentTarget = currentTarget.document;
var currentTargetTree = getTreeScope(currentTarget);
var originalTarget = path[0];
var originalTargetTree = getTreeScope(originalTarget);
var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);
for (var i = 0; i < path.length; i++) {
var node = path[i];
if (getTreeScope(node) === relativeTargetTree)
return node;
}
return path[path.length - 1];
}
function getTreeScopeAncestors(treeScope) {
var ancestors = [];
for (; treeScope; treeScope = treeScope.parent) {
ancestors.push(treeScope);
}
return ancestors;
}
function lowestCommonInclusiveAncestor(tsA, tsB) {
var ancestorsA = getTreeScopeAncestors(tsA);
var ancestorsB = getTreeScopeAncestors(tsB);
var result = null;
while (ancestorsA.length > 0 && ancestorsB.length > 0) {
var a = ancestorsA.pop();
var b = ancestorsB.pop();
if (a === b)
result = a;
else
break;
}
return result;
}
function getTreeScopeRoot(ts) {
if (!ts.parent)
return ts;
return getTreeScopeRoot(ts.parent);
}
function relatedTargetResolution(event, currentTarget, relatedTarget) {
if (currentTarget instanceof wrappers.Window)
currentTarget = currentTarget.document;
var currentTargetTree = getTreeScope(currentTarget);
var relatedTargetTree = getTreeScope(relatedTarget);
var relatedTargetEventPath = getEventPath(relatedTarget, event);
var lowestCommonAncestorTree;
var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);
if (!lowestCommonAncestorTree)
lowestCommonAncestorTree = relatedTargetTree.root;
for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {
var adjustedRelatedTarget;
for (var i = 0; i < relatedTargetEventPath.length; i++) {
var node = relatedTargetEventPath[i];
if (getTreeScope(node) === commonAncestorTree)
return node;
}
}
return null;
}
function inSameTree(a, b) {
return getTreeScope(a) === getTreeScope(b);
}
var NONE = 0;
var CAPTURING_PHASE = 1;
var AT_TARGET = 2;
var BUBBLING_PHASE = 3;
var pendingError;
function dispatchOriginalEvent(originalEvent) {
if (handledEventsTable.get(originalEvent))
return;
handledEventsTable.set(originalEvent, true);
dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));
if (pendingError) {
var err = pendingError;
pendingError = null;
throw err;
}
}
function isLoadLikeEvent(event) {
switch (event.type) {
case 'load':
case 'beforeunload':
case 'unload':
return true;
}
return false;
}
function dispatchEvent(event, originalWrapperTarget) {
if (currentlyDispatchingEvents.get(event))
throw new Error('InvalidStateError');
currentlyDispatchingEvents.set(event, true);
scope.renderAllPending();
var eventPath;
var overrideTarget;
var win;
if (isLoadLikeEvent(event) && !event.bubbles) {
var doc = originalWrapperTarget;
if (doc instanceof wrappers.Document && (win = doc.defaultView)) {
overrideTarget = doc;
eventPath = [];
}
}
if (!eventPath) {
if (originalWrapperTarget instanceof wrappers.Window) {
win = originalWrapperTarget;
eventPath = [];
} else {
eventPath = getEventPath(originalWrapperTarget, event);
if (!isLoadLikeEvent(event)) {
var doc = eventPath[eventPath.length - 1];
if (doc instanceof wrappers.Document)
win = doc.defaultView;
}
}
}
eventPathTable.set(event, eventPath);
if (dispatchCapturing(event, eventPath, win, overrideTarget)) {
if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {
dispatchBubbling(event, eventPath, win, overrideTarget);
}
}
eventPhaseTable.set(event, NONE);
currentTargetTable.delete(event, null);
currentlyDispatchingEvents.delete(event);
return event.defaultPrevented;
}
function dispatchCapturing(event, eventPath, win, overrideTarget) {
var phase = CAPTURING_PHASE;
if (win) {
if (!invoke(win, event, phase, eventPath, overrideTarget))
return false;
}
for (var i = eventPath.length - 1; i > 0; i--) {
if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget))
return false;
}
return true;
}
function dispatchAtTarget(event, eventPath, win, overrideTarget) {
var phase = AT_TARGET;
var currentTarget = eventPath[0] || win;
return invoke(currentTarget, event, phase, eventPath, overrideTarget);
}
function dispatchBubbling(event, eventPath, win, overrideTarget) {
var phase = BUBBLING_PHASE;
for (var i = 1; i < eventPath.length; i++) {
if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget))
return;
}
if (win && eventPath.length > 0) {
invoke(win, event, phase, eventPath, overrideTarget);
}
}
function invoke(currentTarget, event, phase, eventPath, overrideTarget) {
var listeners = listenersTable.get(currentTarget);
if (!listeners)
return true;
var target = overrideTarget || eventRetargetting(eventPath, currentTarget);
if (target === currentTarget) {
if (phase === CAPTURING_PHASE)
return true;
if (phase === BUBBLING_PHASE)
phase = AT_TARGET;
} else if (phase === BUBBLING_PHASE && !event.bubbles) {
return true;
}
if ('relatedTarget' in event) {
var originalEvent = unwrap(event);
var unwrappedRelatedTarget = originalEvent.relatedTarget;
if (unwrappedRelatedTarget) {
if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {
var relatedTarget = wrap(unwrappedRelatedTarget);
var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);
if (adjusted === target)
return true;
} else {
adjusted = null;
}
relatedTargetTable.set(event, adjusted);
}
}
eventPhaseTable.set(event, phase);
var type = event.type;
var anyRemoved = false;
targetTable.set(event, target);
currentTargetTable.set(event, currentTarget);
listeners.depth++;
for (var i = 0, len = listeners.length; i < len; i++) {
var listener = listeners[i];
if (listener.removed) {
anyRemoved = true;
continue;
}
if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {
continue;
}
try {
if (typeof listener.handler === 'function')
listener.handler.call(currentTarget, event);
else
listener.handler.handleEvent(event);
if (stopImmediatePropagationTable.get(event))
return false;
} catch (ex) {
if (!pendingError)
pendingError = ex;
}
}
listeners.depth--;
if (anyRemoved && listeners.depth === 0) {
var copy = listeners.slice();
listeners.length = 0;
for (var i = 0; i < copy.length; i++) {
if (!copy[i].removed)
listeners.push(copy[i]);
}
}
return !stopPropagationTable.get(event);
}
function Listener(type, handler, capture) {
this.type = type;
this.handler = handler;
this.capture = Boolean(capture);
}
Listener.prototype = {
equals: function (that) {
return this.handler === that.handler && this.type === that.type && this.capture === that.capture;
},
get removed() {
return this.handler === null;
},
remove: function () {
this.handler = null;
}
};
var OriginalEvent = window.Event;
OriginalEvent.prototype.polymerBlackList_ = {
returnValue: true,
keyLocation: true
};
function Event(type, options) {
if (type instanceof OriginalEvent) {
var impl = type;
if (!OriginalBeforeUnloadEvent && impl.type === 'beforeunload' && !(this instanceof BeforeUnloadEvent)) {
return new BeforeUnloadEvent(impl);
}
setWrapper(impl, this);
} else {
return wrap(constructEvent(OriginalEvent, 'Event', type, options));
}
}
Event.prototype = {
get target() {
return targetTable.get(this);
},
get currentTarget() {
return currentTargetTable.get(this);
},
get eventPhase() {
return eventPhaseTable.get(this);
},
get path() {
var eventPath = eventPathTable.get(this);
if (!eventPath)
return [];
return eventPath.slice();
},
stopPropagation: function () {
stopPropagationTable.set(this, true);
},
stopImmediatePropagation: function () {
stopPropagationTable.set(this, true);
stopImmediatePropagationTable.set(this, true);
}
};
var supportsDefaultPrevented = function () {
var e = document.createEvent('Event');
e.initEvent('test', true, true);
e.preventDefault();
return e.defaultPrevented;
}();
if (!supportsDefaultPrevented) {
Event.prototype.preventDefault = function () {
if (!this.cancelable)
return;
unsafeUnwrap(this).preventDefault();
Object.defineProperty(this, 'defaultPrevented', {
get: function () {
return true;
},
configurable: true
});
};
}
registerWrapper(OriginalEvent, Event, document.createEvent('Event'));
function unwrapOptions(options) {
if (!options || !options.relatedTarget)
return options;
return Object.create(options, { relatedTarget: { value: unwrap(options.relatedTarget) } });
}
function registerGenericEvent(name, SuperEvent, prototype) {
var OriginalEvent = window[name];
var GenericEvent = function (type, options) {
if (type instanceof OriginalEvent)
setWrapper(type, this);
else
return wrap(constructEvent(OriginalEvent, name, type, options));
};
GenericEvent.prototype = Object.create(SuperEvent.prototype);
if (prototype)
mixin(GenericEvent.prototype, prototype);
if (OriginalEvent) {
try {
registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent('temp'));
} catch (ex) {
registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));
}
}
return GenericEvent;
}
var UIEvent = registerGenericEvent('UIEvent', Event);
var CustomEvent = registerGenericEvent('CustomEvent', Event);
var relatedTargetProto = {
get relatedTarget() {
var relatedTarget = relatedTargetTable.get(this);
if (relatedTarget !== undefined)
return relatedTarget;
return wrap(unwrap(this).relatedTarget);
}
};
function getInitFunction(name, relatedTargetIndex) {
return function () {
arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);
var impl = unwrap(this);
impl[name].apply(impl, arguments);
};
}
var mouseEventProto = mixin({ initMouseEvent: getInitFunction('initMouseEvent', 14) }, relatedTargetProto);
var focusEventProto = mixin({ initFocusEvent: getInitFunction('initFocusEvent', 5) }, relatedTargetProto);
var MouseEvent = registerGenericEvent('MouseEvent', UIEvent, mouseEventProto);
var FocusEvent = registerGenericEvent('FocusEvent', UIEvent, focusEventProto);
var defaultInitDicts = Object.create(null);
var supportsEventConstructors = function () {
try {
new window.FocusEvent('focus');
} catch (ex) {
return false;
}
return true;
}();
function constructEvent(OriginalEvent, name, type, options) {
if (supportsEventConstructors)
return new OriginalEvent(type, unwrapOptions(options));
var event = unwrap(document.createEvent(name));
var defaultDict = defaultInitDicts[name];
var args = [type];
Object.keys(defaultDict).forEach(function (key) {
var v = options != null && key in options ? options[key] : defaultDict[key];
if (key === 'relatedTarget')
v = unwrap(v);
args.push(v);
});
event['init' + name].apply(event, args);
return event;
}
if (!supportsEventConstructors) {
var configureEventConstructor = function (name, initDict, superName) {
if (superName) {
var superDict = defaultInitDicts[superName];
initDict = mixin(mixin({}, superDict), initDict);
}
defaultInitDicts[name] = initDict;
};
configureEventConstructor('Event', {
bubbles: false,
cancelable: false
});
configureEventConstructor('CustomEvent', { detail: null }, 'Event');
configureEventConstructor('UIEvent', {
view: null,
detail: 0
}, 'Event');
configureEventConstructor('MouseEvent', {
screenX: 0,
screenY: 0,
clientX: 0,
clientY: 0,
ctrlKey: false,
altKey: false,
shiftKey: false,
metaKey: false,
button: 0,
relatedTarget: null
}, 'UIEvent');
configureEventConstructor('FocusEvent', { relatedTarget: null }, 'UIEvent');
}
var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;
function BeforeUnloadEvent(impl) {
Event.call(this, impl);
}
BeforeUnloadEvent.prototype = Object.create(Event.prototype);
mixin(BeforeUnloadEvent.prototype, {
get returnValue() {
return unsafeUnwrap(this).returnValue;
},
set returnValue(v) {
unsafeUnwrap(this).returnValue = v;
}
});
if (OriginalBeforeUnloadEvent)
registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);
function isValidListener(fun) {
if (typeof fun === 'function')
return true;
return fun && fun.handleEvent;
}
function isMutationEvent(type) {
switch (type) {
case 'DOMAttrModified':
case 'DOMAttributeNameChanged':
case 'DOMCharacterDataModified':
case 'DOMElementNameChanged':
case 'DOMNodeInserted':
case 'DOMNodeInsertedIntoDocument':
case 'DOMNodeRemoved':
case 'DOMNodeRemovedFromDocument':
case 'DOMSubtreeModified':
return true;
}
return false;
}
var OriginalEventTarget = window.EventTarget;
function EventTarget(impl) {
setWrapper(impl, this);
}
var methodNames = [
'addEventListener',
'removeEventListener',
'dispatchEvent'
];
[
Node,
Window
].forEach(function (constructor) {
var p = constructor.prototype;
methodNames.forEach(function (name) {
Object.defineProperty(p, name + '_', { value: p[name] });
});
});
function getTargetToListenAt(wrapper) {
if (wrapper instanceof wrappers.ShadowRoot)
wrapper = wrapper.host;
return unwrap(wrapper);
}
EventTarget.prototype = {
addEventListener: function (type, fun, capture) {
if (!isValidListener(fun) || isMutationEvent(type))
return;
var listener = new Listener(type, fun, capture);
var listeners = listenersTable.get(this);
if (!listeners) {
listeners = [];
listeners.depth = 0;
listenersTable.set(this, listeners);
} else {
for (var i = 0; i < listeners.length; i++) {
if (listener.equals(listeners[i]))
return;
}
}
listeners.push(listener);
var target = getTargetToListenAt(this);
target.addEventListener_(type, dispatchOriginalEvent, true);
},
removeEventListener: function (type, fun, capture) {
capture = Boolean(capture);
var listeners = listenersTable.get(this);
if (!listeners)
return;
var count = 0, found = false;
for (var i = 0; i < listeners.length; i++) {
if (listeners[i].type === type && listeners[i].capture === capture) {
count++;
if (listeners[i].handler === fun) {
found = true;
listeners[i].remove();
}
}
}
if (found && count === 1) {
var target = getTargetToListenAt(this);
target.removeEventListener_(type, dispatchOriginalEvent, true);
}
},
dispatchEvent: function (event) {
var nativeEvent = unwrap(event);
var eventType = nativeEvent.type;
handledEventsTable.set(nativeEvent, false);
scope.renderAllPending();
var tempListener;
if (!hasListenerInAncestors(this, eventType)) {
tempListener = function () {
};
this.addEventListener(eventType, tempListener, true);
}
try {
return unwrap(this).dispatchEvent_(nativeEvent);
} finally {
if (tempListener)
this.removeEventListener(eventType, tempListener, true);
}
}
};
function hasListener(node, type) {
var listeners = listenersTable.get(node);
if (listeners) {
for (var i = 0; i < listeners.length; i++) {
if (!listeners[i].removed && listeners[i].type === type)
return true;
}
}
return false;
}
function hasListenerInAncestors(target, type) {
for (var node = unwrap(target); node; node = node.parentNode) {
if (hasListener(wrap(node), type))
return true;
}
return false;
}
if (OriginalEventTarget)
registerWrapper(OriginalEventTarget, EventTarget);
function wrapEventTargetMethods(constructors) {
forwardMethodsToWrapper(constructors, methodNames);
}
var originalElementFromPoint = document.elementFromPoint;
function elementFromPoint(self, document, x, y) {
scope.renderAllPending();
var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));
if (!element)
return null;
var path = getEventPath(element, null);
var idx = path.lastIndexOf(self);
if (idx == -1)
return null;
else
path = path.slice(0, idx);
return eventRetargetting(path, self);
}
function getEventHandlerGetter(name) {
return function () {
var inlineEventHandlers = eventHandlersTable.get(this);
return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;
};
}
function getEventHandlerSetter(name) {
var eventType = name.slice(2);
return function (value) {
var inlineEventHandlers = eventHandlersTable.get(this);
if (!inlineEventHandlers) {
inlineEventHandlers = Object.create(null);
eventHandlersTable.set(this, inlineEventHandlers);
}
var old = inlineEventHandlers[name];
if (old)
this.removeEventListener(eventType, old.wrapped, false);
if (typeof value === 'function') {
var wrapped = function (e) {
var rv = value.call(this, e);
if (rv === false)
e.preventDefault();
else if (name === 'onbeforeunload' && typeof rv === 'string')
e.returnValue = rv;
};
this.addEventListener(eventType, wrapped, false);
inlineEventHandlers[name] = {
value: value,
wrapped: wrapped
};
}
};
}
scope.elementFromPoint = elementFromPoint;
scope.getEventHandlerGetter = getEventHandlerGetter;
scope.getEventHandlerSetter = getEventHandlerSetter;
scope.wrapEventTargetMethods = wrapEventTargetMethods;
scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;
scope.wrappers.CustomEvent = CustomEvent;
scope.wrappers.Event = Event;
scope.wrappers.EventTarget = EventTarget;
scope.wrappers.FocusEvent = FocusEvent;
scope.wrappers.MouseEvent = MouseEvent;
scope.wrappers.UIEvent = UIEvent;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var UIEvent = scope.wrappers.UIEvent;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var OriginalTouchEvent = window.TouchEvent;
if (!OriginalTouchEvent)
return;
var nativeEvent;
try {
nativeEvent = document.createEvent('TouchEvent');
} catch (ex) {
return;
}
var nonEnumDescriptor = { enumerable: false };
function nonEnum(obj, prop) {
Object.defineProperty(obj, prop, nonEnumDescriptor);
}
function Touch(impl) {
setWrapper(impl, this);
}
Touch.prototype = {
get target() {
return wrap(unsafeUnwrap(this).target);
}
};
var descr = {
configurable: true,
enumerable: true,
get: null
};
[
'clientX',
'clientY',
'screenX',
'screenY',
'pageX',
'pageY',
'identifier',
'webkitRadiusX',
'webkitRadiusY',
'webkitRotationAngle',
'webkitForce'
].forEach(function (name) {
descr.get = function () {
return unsafeUnwrap(this)[name];
};
Object.defineProperty(Touch.prototype, name, descr);
});
function TouchList() {
this.length = 0;
nonEnum(this, 'length');
}
TouchList.prototype = {
item: function (index) {
return this[index];
}
};
function wrapTouchList(nativeTouchList) {
var list = new TouchList();
for (var i = 0; i < nativeTouchList.length; i++) {
list[i] = new Touch(nativeTouchList[i]);
}
list.length = i;
return list;
}
function TouchEvent(impl) {
UIEvent.call(this, impl);
}
TouchEvent.prototype = Object.create(UIEvent.prototype);
mixin(TouchEvent.prototype, {
get touches() {
return wrapTouchList(unsafeUnwrap(this).touches);
},
get targetTouches() {
return wrapTouchList(unsafeUnwrap(this).targetTouches);
},
get changedTouches() {
return wrapTouchList(unsafeUnwrap(this).changedTouches);
},
initTouchEvent: function () {
throw new Error('Not implemented');
}
});
registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);
scope.wrappers.Touch = Touch;
scope.wrappers.TouchEvent = TouchEvent;
scope.wrappers.TouchList = TouchList;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var nonEnumDescriptor = { enumerable: false };
function nonEnum(obj, prop) {
Object.defineProperty(obj, prop, nonEnumDescriptor);
}
function NodeList() {
this.length = 0;
nonEnum(this, 'length');
}
NodeList.prototype = {
item: function (index) {
return this[index];
}
};
nonEnum(NodeList.prototype, 'item');
function wrapNodeList(list) {
if (list == null)
return list;
var wrapperList = new NodeList();
for (var i = 0, length = list.length; i < length; i++) {
wrapperList[i] = wrap(list[i]);
}
wrapperList.length = length;
return wrapperList;
}
function addWrapNodeListMethod(wrapperConstructor, name) {
wrapperConstructor.prototype[name] = function () {
return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));
};
}
scope.wrappers.NodeList = NodeList;
scope.addWrapNodeListMethod = addWrapNodeListMethod;
scope.wrapNodeList = wrapNodeList;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
scope.wrapHTMLCollection = scope.wrapNodeList;
scope.wrappers.HTMLCollection = scope.wrappers.NodeList;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var EventTarget = scope.wrappers.EventTarget;
var NodeList = scope.wrappers.NodeList;
var TreeScope = scope.TreeScope;
var assert = scope.assert;
var defineWrapGetter = scope.defineWrapGetter;
var enqueueMutation = scope.enqueueMutation;
var getTreeScope = scope.getTreeScope;
var isWrapper = scope.isWrapper;
var mixin = scope.mixin;
var registerTransientObservers = scope.registerTransientObservers;
var registerWrapper = scope.registerWrapper;
var setTreeScope = scope.setTreeScope;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var wrapIfNeeded = scope.wrapIfNeeded;
var wrappers = scope.wrappers;
function assertIsNodeWrapper(node) {
assert(node instanceof Node);
}
function createOneElementNodeList(node) {
var nodes = new NodeList();
nodes[0] = node;
nodes.length = 1;
return nodes;
}
var surpressMutations = false;
function enqueueRemovalForInsertedNodes(node, parent, nodes) {
enqueueMutation(parent, 'childList', {
removedNodes: nodes,
previousSibling: node.previousSibling,
nextSibling: node.nextSibling
});
}
function enqueueRemovalForInsertedDocumentFragment(df, nodes) {
enqueueMutation(df, 'childList', { removedNodes: nodes });
}
function collectNodes(node, parentNode, previousNode, nextNode) {
if (node instanceof DocumentFragment) {
var nodes = collectNodesForDocumentFragment(node);
surpressMutations = true;
for (var i = nodes.length - 1; i >= 0; i--) {
node.removeChild(nodes[i]);
nodes[i].parentNode_ = parentNode;
}
surpressMutations = false;
for (var i = 0; i < nodes.length; i++) {
nodes[i].previousSibling_ = nodes[i - 1] || previousNode;
nodes[i].nextSibling_ = nodes[i + 1] || nextNode;
}
if (previousNode)
previousNode.nextSibling_ = nodes[0];
if (nextNode)
nextNode.previousSibling_ = nodes[nodes.length - 1];
return nodes;
}
var nodes = createOneElementNodeList(node);
var oldParent = node.parentNode;
if (oldParent) {
oldParent.removeChild(node);
}
node.parentNode_ = parentNode;
node.previousSibling_ = previousNode;
node.nextSibling_ = nextNode;
if (previousNode)
previousNode.nextSibling_ = node;
if (nextNode)
nextNode.previousSibling_ = node;
return nodes;
}
function collectNodesNative(node) {
if (node instanceof DocumentFragment)
return collectNodesForDocumentFragment(node);
var nodes = createOneElementNodeList(node);
var oldParent = node.parentNode;
if (oldParent)
enqueueRemovalForInsertedNodes(node, oldParent, nodes);
return nodes;
}
function collectNodesForDocumentFragment(node) {
var nodes = new NodeList();
var i = 0;
for (var child = node.firstChild; child; child = child.nextSibling) {
nodes[i++] = child;
}
nodes.length = i;
enqueueRemovalForInsertedDocumentFragment(node, nodes);
return nodes;
}
function snapshotNodeList(nodeList) {
return nodeList;
}
function nodeWasAdded(node, treeScope) {
setTreeScope(node, treeScope);
node.nodeIsInserted_();
}
function nodesWereAdded(nodes, parent) {
var treeScope = getTreeScope(parent);
for (var i = 0; i < nodes.length; i++) {
nodeWasAdded(nodes[i], treeScope);
}
}
function nodeWasRemoved(node) {
setTreeScope(node, new TreeScope(node, null));
}
function nodesWereRemoved(nodes) {
for (var i = 0; i < nodes.length; i++) {
nodeWasRemoved(nodes[i]);
}
}
function ensureSameOwnerDocument(parent, child) {
var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;
if (ownerDoc !== child.ownerDocument)
ownerDoc.adoptNode(child);
}
function adoptNodesIfNeeded(owner, nodes) {
if (!nodes.length)
return;
var ownerDoc = owner.ownerDocument;
if (ownerDoc === nodes[0].ownerDocument)
return;
for (var i = 0; i < nodes.length; i++) {
scope.adoptNodeNoRemove(nodes[i], ownerDoc);
}
}
function unwrapNodesForInsertion(owner, nodes) {
adoptNodesIfNeeded(owner, nodes);
var length = nodes.length;
if (length === 1)
return unwrap(nodes[0]);
var df = unwrap(owner.ownerDocument.createDocumentFragment());
for (var i = 0; i < length; i++) {
df.appendChild(unwrap(nodes[i]));
}
return df;
}
function clearChildNodes(wrapper) {
if (wrapper.firstChild_ !== undefined) {
var child = wrapper.firstChild_;
while (child) {
var tmp = child;
child = child.nextSibling_;
tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;
}
}
wrapper.firstChild_ = wrapper.lastChild_ = undefined;
}
function removeAllChildNodes(wrapper) {
if (wrapper.invalidateShadowRenderer()) {
var childWrapper = wrapper.firstChild;
while (childWrapper) {
assert(childWrapper.parentNode === wrapper);
var nextSibling = childWrapper.nextSibling;
var childNode = unwrap(childWrapper);
var parentNode = childNode.parentNode;
if (parentNode)
originalRemoveChild.call(parentNode, childNode);
childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
childWrapper = nextSibling;
}
wrapper.firstChild_ = wrapper.lastChild_ = null;
} else {
var node = unwrap(wrapper);
var child = node.firstChild;
var nextSibling;
while (child) {
nextSibling = child.nextSibling;
originalRemoveChild.call(node, child);
child = nextSibling;
}
}
}
function invalidateParent(node) {
var p = node.parentNode;
return p && p.invalidateShadowRenderer();
}
function cleanupNodes(nodes) {
for (var i = 0, n; i < nodes.length; i++) {
n = nodes[i];
n.parentNode.removeChild(n);
}
}
var originalImportNode = document.importNode;
var originalCloneNode = window.Node.prototype.cloneNode;
function cloneNode(node, deep, opt_doc) {
var clone;
if (opt_doc)
clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false));
else
clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));
if (deep) {
for (var child = node.firstChild; child; child = child.nextSibling) {
clone.appendChild(cloneNode(child, true, opt_doc));
}
if (node instanceof wrappers.HTMLTemplateElement) {
var cloneContent = clone.content;
for (var child = node.content.firstChild; child; child = child.nextSibling) {
cloneContent.appendChild(cloneNode(child, true, opt_doc));
}
}
}
return clone;
}
function contains(self, child) {
if (!child || getTreeScope(self) !== getTreeScope(child))
return false;
for (var node = child; node; node = node.parentNode) {
if (node === self)
return true;
}
return false;
}
var OriginalNode = window.Node;
function Node(original) {
assert(original instanceof OriginalNode);
EventTarget.call(this, original);
this.parentNode_ = undefined;
this.firstChild_ = undefined;
this.lastChild_ = undefined;
this.nextSibling_ = undefined;
this.previousSibling_ = undefined;
this.treeScope_ = undefined;
}
var OriginalDocumentFragment = window.DocumentFragment;
var originalAppendChild = OriginalNode.prototype.appendChild;
var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;
var originalIsEqualNode = OriginalNode.prototype.isEqualNode;
var originalInsertBefore = OriginalNode.prototype.insertBefore;
var originalRemoveChild = OriginalNode.prototype.removeChild;
var originalReplaceChild = OriginalNode.prototype.replaceChild;
var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);
var removeChildOriginalHelper = isIEOrEdge ? function (parent, child) {
try {
originalRemoveChild.call(parent, child);
} catch (ex) {
if (!(parent instanceof OriginalDocumentFragment))
throw ex;
}
} : function (parent, child) {
originalRemoveChild.call(parent, child);
};
Node.prototype = Object.create(EventTarget.prototype);
mixin(Node.prototype, {
appendChild: function (childWrapper) {
return this.insertBefore(childWrapper, null);
},
insertBefore: function (childWrapper, refWrapper) {
assertIsNodeWrapper(childWrapper);
var refNode;
if (refWrapper) {
if (isWrapper(refWrapper)) {
refNode = unwrap(refWrapper);
} else {
refNode = refWrapper;
refWrapper = wrap(refNode);
}
} else {
refWrapper = null;
refNode = null;
}
refWrapper && assert(refWrapper.parentNode === this);
var nodes;
var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;
var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);
if (useNative)
nodes = collectNodesNative(childWrapper);
else
nodes = collectNodes(childWrapper, this, previousNode, refWrapper);
if (useNative) {
ensureSameOwnerDocument(this, childWrapper);
clearChildNodes(this);
originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);
} else {
if (!previousNode)
this.firstChild_ = nodes[0];
if (!refWrapper) {
this.lastChild_ = nodes[nodes.length - 1];
if (this.firstChild_ === undefined)
this.firstChild_ = this.firstChild;
}
var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);
if (parentNode) {
originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);
} else {
adoptNodesIfNeeded(this, nodes);
}
}
enqueueMutation(this, 'childList', {
addedNodes: nodes,
nextSibling: refWrapper,
previousSibling: previousNode
});
nodesWereAdded(nodes, this);
return childWrapper;
},
removeChild: function (childWrapper) {
assertIsNodeWrapper(childWrapper);
if (childWrapper.parentNode !== this) {
var found = false;
var childNodes = this.childNodes;
for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {
if (ieChild === childWrapper) {
found = true;
break;
}
}
if (!found) {
throw new Error('NotFoundError');
}
}
var childNode = unwrap(childWrapper);
var childWrapperNextSibling = childWrapper.nextSibling;
var childWrapperPreviousSibling = childWrapper.previousSibling;
if (this.invalidateShadowRenderer()) {
var thisFirstChild = this.firstChild;
var thisLastChild = this.lastChild;
var parentNode = childNode.parentNode;
if (parentNode)
removeChildOriginalHelper(parentNode, childNode);
if (thisFirstChild === childWrapper)
this.firstChild_ = childWrapperNextSibling;
if (thisLastChild === childWrapper)
this.lastChild_ = childWrapperPreviousSibling;
if (childWrapperPreviousSibling)
childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;
if (childWrapperNextSibling) {
childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;
}
childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;
} else {
clearChildNodes(this);
removeChildOriginalHelper(unsafeUnwrap(this), childNode);
}
if (!surpressMutations) {
enqueueMutation(this, 'childList', {
removedNodes: createOneElementNodeList(childWrapper),
nextSibling: childWrapperNextSibling,
previousSibling: childWrapperPreviousSibling
});
}
registerTransientObservers(this, childWrapper);
return childWrapper;
},
replaceChild: function (newChildWrapper, oldChildWrapper) {
assertIsNodeWrapper(newChildWrapper);
var oldChildNode;
if (isWrapper(oldChildWrapper)) {
oldChildNode = unwrap(oldChildWrapper);
} else {
oldChildNode = oldChildWrapper;
oldChildWrapper = wrap(oldChildNode);
}
if (oldChildWrapper.parentNode !== this) {
throw new Error('NotFoundError');
}
var nextNode = oldChildWrapper.nextSibling;
var previousNode = oldChildWrapper.previousSibling;
var nodes;
var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);
if (useNative) {
nodes = collectNodesNative(newChildWrapper);
} else {
if (nextNode === newChildWrapper)
nextNode = newChildWrapper.nextSibling;
nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);
}
if (!useNative) {
if (this.firstChild === oldChildWrapper)
this.firstChild_ = nodes[0];
if (this.lastChild === oldChildWrapper)
this.lastChild_ = nodes[nodes.length - 1];
oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;
if (oldChildNode.parentNode) {
originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);
}
} else {
ensureSameOwnerDocument(this, newChildWrapper);
clearChildNodes(this);
originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);
}
enqueueMutation(this, 'childList', {
addedNodes: nodes,
removedNodes: createOneElementNodeList(oldChildWrapper),
nextSibling: nextNode,
previousSibling: previousNode
});
nodeWasRemoved(oldChildWrapper);
nodesWereAdded(nodes, this);
return oldChildWrapper;
},
nodeIsInserted_: function () {
for (var child = this.firstChild; child; child = child.nextSibling) {
child.nodeIsInserted_();
}
},
hasChildNodes: function () {
return this.firstChild !== null;
},
get parentNode() {
return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);
},
get firstChild() {
return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);
},
get lastChild() {
return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);
},
get nextSibling() {
return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);
},
get previousSibling() {
return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);
},
get parentElement() {
var p = this.parentNode;
while (p && p.nodeType !== Node.ELEMENT_NODE) {
p = p.parentNode;
}
return p;
},
get textContent() {
var s = '';
for (var child = this.firstChild; child; child = child.nextSibling) {
if (child.nodeType != Node.COMMENT_NODE) {
s += child.textContent;
}
}
return s;
},
set textContent(textContent) {
if (textContent == null)
textContent = '';
var removedNodes = snapshotNodeList(this.childNodes);
if (this.invalidateShadowRenderer()) {
removeAllChildNodes(this);
if (textContent !== '') {
var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);
this.appendChild(textNode);
}
} else {
clearChildNodes(this);
unsafeUnwrap(this).textContent = textContent;
}
var addedNodes = snapshotNodeList(this.childNodes);
enqueueMutation(this, 'childList', {
addedNodes: addedNodes,
removedNodes: removedNodes
});
nodesWereRemoved(removedNodes);
nodesWereAdded(addedNodes, this);
},
get childNodes() {
var wrapperList = new NodeList();
var i = 0;
for (var child = this.firstChild; child; child = child.nextSibling) {
wrapperList[i++] = child;
}
wrapperList.length = i;
return wrapperList;
},
cloneNode: function (deep) {
return cloneNode(this, deep);
},
contains: function (child) {
return contains(this, wrapIfNeeded(child));
},
compareDocumentPosition: function (otherNode) {
return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));
},
isEqualNode: function (otherNode) {
return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));
},
normalize: function () {
var nodes = snapshotNodeList(this.childNodes);
var remNodes = [];
var s = '';
var modNode;
for (var i = 0, n; i < nodes.length; i++) {
n = nodes[i];
if (n.nodeType === Node.TEXT_NODE) {
if (!modNode && !n.data.length)
this.removeChild(n);
else if (!modNode)
modNode = n;
else {
s += n.data;
remNodes.push(n);
}
} else {
if (modNode && remNodes.length) {
modNode.data += s;
cleanupNodes(remNodes);
}
remNodes = [];
s = '';
modNode = null;
if (n.childNodes.length)
n.normalize();
}
}
if (modNode && remNodes.length) {
modNode.data += s;
cleanupNodes(remNodes);
}
}
});
defineWrapGetter(Node, 'ownerDocument');
registerWrapper(OriginalNode, Node, document.createDocumentFragment());
delete Node.prototype.querySelector;
delete Node.prototype.querySelectorAll;
Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);
scope.cloneNode = cloneNode;
scope.nodeWasAdded = nodeWasAdded;
scope.nodeWasRemoved = nodeWasRemoved;
scope.nodesWereAdded = nodesWereAdded;
scope.nodesWereRemoved = nodesWereRemoved;
scope.originalInsertBefore = originalInsertBefore;
scope.originalRemoveChild = originalRemoveChild;
scope.snapshotNodeList = snapshotNodeList;
scope.wrappers.Node = Node;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLCollection = scope.wrappers.HTMLCollection;
var NodeList = scope.wrappers.NodeList;
var getTreeScope = scope.getTreeScope;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var originalDocumentQuerySelector = document.querySelector;
var originalElementQuerySelector = document.documentElement.querySelector;
var originalDocumentQuerySelectorAll = document.querySelectorAll;
var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;
var originalDocumentGetElementsByTagName = document.getElementsByTagName;
var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;
var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;
var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;
var OriginalElement = window.Element;
var OriginalDocument = window.HTMLDocument || window.Document;
function filterNodeList(list, index, result, deep) {
var wrappedItem = null;
var root = null;
for (var i = 0, length = list.length; i < length; i++) {
wrappedItem = wrap(list[i]);
if (!deep && (root = getTreeScope(wrappedItem).root)) {
if (root instanceof scope.wrappers.ShadowRoot) {
continue;
}
}
result[index++] = wrappedItem;
}
return index;
}
function shimSelector(selector) {
return String(selector).replace(/\/deep\/|::shadow|>>>/g, ' ');
}
function shimMatchesSelector(selector) {
return String(selector).replace(/:host\(([^\s]+)\)/g, '$1').replace(/([^\s]):host/g, '$1').replace(':host', '*').replace(/\^|\/shadow\/|\/shadow-deep\/|::shadow|\/deep\/|::content|>>>/g, ' ');
}
function findOne(node, selector) {
var m, el = node.firstElementChild;
while (el) {
if (el.matches(selector))
return el;
m = findOne(el, selector);
if (m)
return m;
el = el.nextElementSibling;
}
return null;
}
function matchesSelector(el, selector) {
return el.matches(selector);
}
var XHTML_NS = 'http://www.w3.org/1999/xhtml';
function matchesTagName(el, localName, localNameLowerCase) {
var ln = el.localName;
return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;
}
function matchesEveryThing() {
return true;
}
function matchesLocalNameOnly(el, ns, localName) {
return el.localName === localName;
}
function matchesNameSpace(el, ns) {
return el.namespaceURI === ns;
}
function matchesLocalNameNS(el, ns, localName) {
return el.namespaceURI === ns && el.localName === localName;
}
function findElements(node, index, result, p, arg0, arg1) {
var el = node.firstElementChild;
while (el) {
if (p(el, arg0, arg1))
result[index++] = el;
index = findElements(el, index, result, p, arg0, arg1);
el = el.nextElementSibling;
}
return index;
}
function querySelectorAllFiltered(p, index, result, selector, deep) {
var target = unsafeUnwrap(this);
var list;
var root = getTreeScope(this).root;
if (root instanceof scope.wrappers.ShadowRoot) {
return findElements(this, index, result, p, selector, null);
} else if (target instanceof OriginalElement) {
list = originalElementQuerySelectorAll.call(target, selector);
} else if (target instanceof OriginalDocument) {
list = originalDocumentQuerySelectorAll.call(target, selector);
} else {
return findElements(this, index, result, p, selector, null);
}
return filterNodeList(list, index, result, deep);
}
var SelectorsInterface = {
querySelector: function (selector) {
var shimmed = shimSelector(selector);
var deep = shimmed !== selector;
selector = shimmed;
var target = unsafeUnwrap(this);
var wrappedItem;
var root = getTreeScope(this).root;
if (root instanceof scope.wrappers.ShadowRoot) {
return findOne(this, selector);
} else if (target instanceof OriginalElement) {
wrappedItem = wrap(originalElementQuerySelector.call(target, selector));
} else if (target instanceof OriginalDocument) {
wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));
} else {
return findOne(this, selector);
}
if (!wrappedItem) {
return wrappedItem;
} else if (!deep && (root = getTreeScope(wrappedItem).root)) {
if (root instanceof scope.wrappers.ShadowRoot) {
return findOne(this, selector);
}
}
return wrappedItem;
},
querySelectorAll: function (selector) {
var shimmed = shimSelector(selector);
var deep = shimmed !== selector;
selector = shimmed;
var result = new NodeList();
result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);
return result;
}
};
var MatchesInterface = {
matches: function (selector) {
selector = shimMatchesSelector(selector);
return scope.originalMatches.call(unsafeUnwrap(this), selector);
}
};
function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {
var target = unsafeUnwrap(this);
var list;
var root = getTreeScope(this).root;
if (root instanceof scope.wrappers.ShadowRoot) {
return findElements(this, index, result, p, localName, lowercase);
} else if (target instanceof OriginalElement) {
list = originalElementGetElementsByTagName.call(target, localName, lowercase);
} else if (target instanceof OriginalDocument) {
list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);
} else {
return findElements(this, index, result, p, localName, lowercase);
}
return filterNodeList(list, index, result, false);
}
function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {
var target = unsafeUnwrap(this);
var list;
var root = getTreeScope(this).root;
if (root instanceof scope.wrappers.ShadowRoot) {
return findElements(this, index, result, p, ns, localName);
} else if (target instanceof OriginalElement) {
list = originalElementGetElementsByTagNameNS.call(target, ns, localName);
} else if (target instanceof OriginalDocument) {
list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);
} else {
return findElements(this, index, result, p, ns, localName);
}
return filterNodeList(list, index, result, false);
}
var GetElementsByInterface = {
getElementsByTagName: function (localName) {
var result = new HTMLCollection();
var match = localName === '*' ? matchesEveryThing : matchesTagName;
result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());
return result;
},
getElementsByClassName: function (className) {
return this.querySelectorAll('.' + className);
},
getElementsByTagNameNS: function (ns, localName) {
var result = new HTMLCollection();
var match = null;
if (ns === '*') {
match = localName === '*' ? matchesEveryThing : matchesLocalNameOnly;
} else {
match = localName === '*' ? matchesNameSpace : matchesLocalNameNS;
}
result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);
return result;
}
};
scope.GetElementsByInterface = GetElementsByInterface;
scope.SelectorsInterface = SelectorsInterface;
scope.MatchesInterface = MatchesInterface;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var NodeList = scope.wrappers.NodeList;
function forwardElement(node) {
while (node && node.nodeType !== Node.ELEMENT_NODE) {
node = node.nextSibling;
}
return node;
}
function backwardsElement(node) {
while (node && node.nodeType !== Node.ELEMENT_NODE) {
node = node.previousSibling;
}
return node;
}
var ParentNodeInterface = {
get firstElementChild() {
return forwardElement(this.firstChild);
},
get lastElementChild() {
return backwardsElement(this.lastChild);
},
get childElementCount() {
var count = 0;
for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
count++;
}
return count;
},
get children() {
var wrapperList = new NodeList();
var i = 0;
for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
wrapperList[i++] = child;
}
wrapperList.length = i;
return wrapperList;
},
remove: function () {
var p = this.parentNode;
if (p)
p.removeChild(this);
}
};
var ChildNodeInterface = {
get nextElementSibling() {
return forwardElement(this.nextSibling);
},
get previousElementSibling() {
return backwardsElement(this.previousSibling);
}
};
var NonElementParentNodeInterface = {
getElementById: function (id) {
if (/[ \t\n\r\f]/.test(id))
return null;
return this.querySelector('[id="' + id + '"]');
}
};
scope.ChildNodeInterface = ChildNodeInterface;
scope.NonElementParentNodeInterface = NonElementParentNodeInterface;
scope.ParentNodeInterface = ParentNodeInterface;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var ChildNodeInterface = scope.ChildNodeInterface;
var Node = scope.wrappers.Node;
var enqueueMutation = scope.enqueueMutation;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var OriginalCharacterData = window.CharacterData;
function CharacterData(node) {
Node.call(this, node);
}
CharacterData.prototype = Object.create(Node.prototype);
mixin(CharacterData.prototype, {
get nodeValue() {
return this.data;
},
set nodeValue(data) {
this.data = data;
},
get textContent() {
return this.data;
},
set textContent(value) {
this.data = value;
},
get data() {
return unsafeUnwrap(this).data;
},
set data(value) {
var oldValue = unsafeUnwrap(this).data;
enqueueMutation(this, 'characterData', { oldValue: oldValue });
unsafeUnwrap(this).data = value;
}
});
mixin(CharacterData.prototype, ChildNodeInterface);
registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(''));
scope.wrappers.CharacterData = CharacterData;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var CharacterData = scope.wrappers.CharacterData;
var enqueueMutation = scope.enqueueMutation;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
function toUInt32(x) {
return x >>> 0;
}
var OriginalText = window.Text;
function Text(node) {
CharacterData.call(this, node);
}
Text.prototype = Object.create(CharacterData.prototype);
mixin(Text.prototype, {
splitText: function (offset) {
offset = toUInt32(offset);
var s = this.data;
if (offset > s.length)
throw new Error('IndexSizeError');
var head = s.slice(0, offset);
var tail = s.slice(offset);
this.data = head;
var newTextNode = this.ownerDocument.createTextNode(tail);
if (this.parentNode)
this.parentNode.insertBefore(newTextNode, this.nextSibling);
return newTextNode;
}
});
registerWrapper(OriginalText, Text, document.createTextNode(''));
scope.wrappers.Text = Text;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
if (!window.DOMTokenList) {
console.warn('Missing DOMTokenList prototype, please include a ' + 'compatible classList polyfill such as http://goo.gl/uTcepH.');
return;
}
var unsafeUnwrap = scope.unsafeUnwrap;
var enqueueMutation = scope.enqueueMutation;
function getClass(el) {
return unsafeUnwrap(el).getAttribute('class');
}
function enqueueClassAttributeChange(el, oldValue) {
enqueueMutation(el, 'attributes', {
name: 'class',
namespace: null,
oldValue: oldValue
});
}
function invalidateClass(el) {
scope.invalidateRendererBasedOnAttribute(el, 'class');
}
function changeClass(tokenList, method, args) {
var ownerElement = tokenList.ownerElement_;
if (ownerElement == null) {
return method.apply(tokenList, args);
}
var oldValue = getClass(ownerElement);
var retv = method.apply(tokenList, args);
if (getClass(ownerElement) !== oldValue) {
enqueueClassAttributeChange(ownerElement, oldValue);
invalidateClass(ownerElement);
}
return retv;
}
var oldAdd = DOMTokenList.prototype.add;
DOMTokenList.prototype.add = function () {
changeClass(this, oldAdd, arguments);
};
var oldRemove = DOMTokenList.prototype.remove;
DOMTokenList.prototype.remove = function () {
changeClass(this, oldRemove, arguments);
};
var oldToggle = DOMTokenList.prototype.toggle;
DOMTokenList.prototype.toggle = function () {
return changeClass(this, oldToggle, arguments);
};
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var ChildNodeInterface = scope.ChildNodeInterface;
var GetElementsByInterface = scope.GetElementsByInterface;
var Node = scope.wrappers.Node;
var ParentNodeInterface = scope.ParentNodeInterface;
var SelectorsInterface = scope.SelectorsInterface;
var MatchesInterface = scope.MatchesInterface;
var addWrapNodeListMethod = scope.addWrapNodeListMethod;
var enqueueMutation = scope.enqueueMutation;
var mixin = scope.mixin;
var oneOf = scope.oneOf;
var registerWrapper = scope.registerWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrappers = scope.wrappers;
var OriginalElement = window.Element;
var matchesNames = [
'matches',
'mozMatchesSelector',
'msMatchesSelector',
'webkitMatchesSelector'
].filter(function (name) {
return OriginalElement.prototype[name];
});
var matchesName = matchesNames[0];
var originalMatches = OriginalElement.prototype[matchesName];
function invalidateRendererBasedOnAttribute(element, name) {
var p = element.parentNode;
if (!p || !p.shadowRoot)
return;
var renderer = scope.getRendererForHost(p);
if (renderer.dependsOnAttribute(name))
renderer.invalidate();
}
function enqueAttributeChange(element, name, oldValue) {
enqueueMutation(element, 'attributes', {
name: name,
namespace: null,
oldValue: oldValue
});
}
var classListTable = new WeakMap();
function Element(node) {
Node.call(this, node);
}
Element.prototype = Object.create(Node.prototype);
mixin(Element.prototype, {
createShadowRoot: function () {
var newShadowRoot = new wrappers.ShadowRoot(this);
unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;
var renderer = scope.getRendererForHost(this);
renderer.invalidate();
return newShadowRoot;
},
get shadowRoot() {
return unsafeUnwrap(this).polymerShadowRoot_ || null;
},
setAttribute: function (name, value) {
var oldValue = unsafeUnwrap(this).getAttribute(name);
unsafeUnwrap(this).setAttribute(name, value);
enqueAttributeChange(this, name, oldValue);
invalidateRendererBasedOnAttribute(this, name);
},
removeAttribute: function (name) {
var oldValue = unsafeUnwrap(this).getAttribute(name);
unsafeUnwrap(this).removeAttribute(name);
enqueAttributeChange(this, name, oldValue);
invalidateRendererBasedOnAttribute(this, name);
},
get classList() {
var list = classListTable.get(this);
if (!list) {
list = unsafeUnwrap(this).classList;
if (!list)
return;
list.ownerElement_ = this;
classListTable.set(this, list);
}
return list;
},
get className() {
return unsafeUnwrap(this).className;
},
set className(v) {
this.setAttribute('class', v);
},
get id() {
return unsafeUnwrap(this).id;
},
set id(v) {
this.setAttribute('id', v);
}
});
matchesNames.forEach(function (name) {
if (name !== 'matches') {
Element.prototype[name] = function (selector) {
return this.matches(selector);
};
}
});
if (OriginalElement.prototype.webkitCreateShadowRoot) {
Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;
}
mixin(Element.prototype, ChildNodeInterface);
mixin(Element.prototype, GetElementsByInterface);
mixin(Element.prototype, ParentNodeInterface);
mixin(Element.prototype, SelectorsInterface);
mixin(Element.prototype, MatchesInterface);
registerWrapper(OriginalElement, Element, document.createElementNS(null, 'x'));
scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;
scope.matchesNames = matchesNames;
scope.originalMatches = originalMatches;
scope.wrappers.Element = Element;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var Element = scope.wrappers.Element;
var defineGetter = scope.defineGetter;
var enqueueMutation = scope.enqueueMutation;
var mixin = scope.mixin;
var nodesWereAdded = scope.nodesWereAdded;
var nodesWereRemoved = scope.nodesWereRemoved;
var registerWrapper = scope.registerWrapper;
var snapshotNodeList = scope.snapshotNodeList;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var wrappers = scope.wrappers;
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
var XHTML_NS = 'http://www.w3.org/1999/xhtml';
function needsSelfClosingSlash(node) {
if (node.namespaceURI !== XHTML_NS)
return true;
var doctype = node.ownerDocument.doctype;
return doctype && doctype.publicId && doctype.systemId;
}
function getOuterHTML(node, parentNode) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.tagName.toLowerCase();
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
if (voidElements[tagName]) {
if (needsSelfClosingSlash(node))
s += '/';
return s + '>';
}
return s + '>' + getInnerHTML(node) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName])
return data;
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node) {
if (node instanceof wrappers.HTMLTemplateElement)
node = node.content;
var s = '';
for (var child = node.firstChild; child; child = child.nextSibling) {
s += getOuterHTML(child, node);
}
return s;
}
function setInnerHTML(node, value, opt_tagName) {
var tagName = opt_tagName || 'div';
node.textContent = '';
var tempElement = unwrap(node.ownerDocument.createElement(tagName));
tempElement.innerHTML = value;
var firstChild;
while (firstChild = tempElement.firstChild) {
node.appendChild(wrap(firstChild));
}
}
var oldIe = /MSIE/.test(navigator.userAgent);
var OriginalHTMLElement = window.HTMLElement;
var OriginalHTMLTemplateElement = window.HTMLTemplateElement;
function HTMLElement(node) {
Element.call(this, node);
}
HTMLElement.prototype = Object.create(Element.prototype);
mixin(HTMLElement.prototype, {
get innerHTML() {
return getInnerHTML(this);
},
set innerHTML(value) {
if (oldIe && plaintextParents[this.localName]) {
this.textContent = value;
return;
}
var removedNodes = snapshotNodeList(this.childNodes);
if (this.invalidateShadowRenderer()) {
if (this instanceof wrappers.HTMLTemplateElement)
setInnerHTML(this.content, value);
else
setInnerHTML(this, value, this.tagName);
} else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {
setInnerHTML(this.content, value);
} else {
unsafeUnwrap(this).innerHTML = value;
}
var addedNodes = snapshotNodeList(this.childNodes);
enqueueMutation(this, 'childList', {
addedNodes: addedNodes,
removedNodes: removedNodes
});
nodesWereRemoved(removedNodes);
nodesWereAdded(addedNodes, this);
},
get outerHTML() {
return getOuterHTML(this, this.parentNode);
},
set outerHTML(value) {
var p = this.parentNode;
if (p) {
p.invalidateShadowRenderer();
var df = frag(p, value);
p.replaceChild(df, this);
}
},
insertAdjacentHTML: function (position, text) {
var contextElement, refNode;
switch (String(position).toLowerCase()) {
case 'beforebegin':
contextElement = this.parentNode;
refNode = this;
break;
case 'afterend':
contextElement = this.parentNode;
refNode = this.nextSibling;
break;
case 'afterbegin':
contextElement = this;
refNode = this.firstChild;
break;
case 'beforeend':
contextElement = this;
refNode = null;
break;
default:
return;
}
var df = frag(contextElement, text);
contextElement.insertBefore(df, refNode);
},
get hidden() {
return this.hasAttribute('hidden');
},
set hidden(v) {
if (v) {
this.setAttribute('hidden', '');
} else {
this.removeAttribute('hidden');
}
}
});
function frag(contextElement, html) {
var p = unwrap(contextElement.cloneNode(false));
p.innerHTML = html;
var df = unwrap(document.createDocumentFragment());
var c;
while (c = p.firstChild) {
df.appendChild(c);
}
return wrap(df);
}
function getter(name) {
return function () {
scope.renderAllPending();
return unsafeUnwrap(this)[name];
};
}
function getterRequiresRendering(name) {
defineGetter(HTMLElement, name, getter(name));
}
[
'clientHeight',
'clientLeft',
'clientTop',
'clientWidth',
'offsetHeight',
'offsetLeft',
'offsetTop',
'offsetWidth',
'scrollHeight',
'scrollWidth'
].forEach(getterRequiresRendering);
function getterAndSetterRequiresRendering(name) {
Object.defineProperty(HTMLElement.prototype, name, {
get: getter(name),
set: function (v) {
scope.renderAllPending();
unsafeUnwrap(this)[name] = v;
},
configurable: true,
enumerable: true
});
}
[
'scrollLeft',
'scrollTop'
].forEach(getterAndSetterRequiresRendering);
function methodRequiresRendering(name) {
Object.defineProperty(HTMLElement.prototype, name, {
value: function () {
scope.renderAllPending();
return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);
},
configurable: true,
enumerable: true
});
}
[
'focus',
'getBoundingClientRect',
'getClientRects',
'scrollIntoView'
].forEach(methodRequiresRendering);
registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement('b'));
scope.wrappers.HTMLElement = HTMLElement;
scope.getInnerHTML = getInnerHTML;
scope.setInnerHTML = setInnerHTML;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var OriginalHTMLCanvasElement = window.HTMLCanvasElement;
function HTMLCanvasElement(node) {
HTMLElement.call(this, node);
}
HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLCanvasElement.prototype, {
getContext: function () {
var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);
return context && wrap(context);
}
});
registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement('canvas'));
scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var OriginalHTMLContentElement = window.HTMLContentElement;
function HTMLContentElement(node) {
HTMLElement.call(this, node);
}
HTMLContentElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLContentElement.prototype, {
constructor: HTMLContentElement,
get select() {
return this.getAttribute('select');
},
set select(value) {
this.setAttribute('select', value);
},
setAttribute: function (n, v) {
HTMLElement.prototype.setAttribute.call(this, n, v);
if (String(n).toLowerCase() === 'select')
this.invalidateShadowRenderer(true);
}
});
if (OriginalHTMLContentElement)
registerWrapper(OriginalHTMLContentElement, HTMLContentElement);
scope.wrappers.HTMLContentElement = HTMLContentElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var wrapHTMLCollection = scope.wrapHTMLCollection;
var unwrap = scope.unwrap;
var OriginalHTMLFormElement = window.HTMLFormElement;
function HTMLFormElement(node) {
HTMLElement.call(this, node);
}
HTMLFormElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLFormElement.prototype, {
get elements() {
return wrapHTMLCollection(unwrap(this).elements);
}
});
registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement('form'));
scope.wrappers.HTMLFormElement = HTMLFormElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var rewrap = scope.rewrap;
var OriginalHTMLImageElement = window.HTMLImageElement;
function HTMLImageElement(node) {
HTMLElement.call(this, node);
}
HTMLImageElement.prototype = Object.create(HTMLElement.prototype);
registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement('img'));
function Image(width, height) {
if (!(this instanceof Image)) {
throw new TypeError('DOM object constructor cannot be called as a function.');
}
var node = unwrap(document.createElement('img'));
HTMLElement.call(this, node);
rewrap(node, this);
if (width !== undefined)
node.width = width;
if (height !== undefined)
node.height = height;
}
Image.prototype = HTMLImageElement.prototype;
scope.wrappers.HTMLImageElement = HTMLImageElement;
scope.wrappers.Image = Image;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var NodeList = scope.wrappers.NodeList;
var registerWrapper = scope.registerWrapper;
var OriginalHTMLShadowElement = window.HTMLShadowElement;
function HTMLShadowElement(node) {
HTMLElement.call(this, node);
}
HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);
HTMLShadowElement.prototype.constructor = HTMLShadowElement;
if (OriginalHTMLShadowElement)
registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);
scope.wrappers.HTMLShadowElement = HTMLShadowElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var contentTable = new WeakMap();
var templateContentsOwnerTable = new WeakMap();
function getTemplateContentsOwner(doc) {
if (!doc.defaultView)
return doc;
var d = templateContentsOwnerTable.get(doc);
if (!d) {
d = doc.implementation.createHTMLDocument('');
while (d.lastChild) {
d.removeChild(d.lastChild);
}
templateContentsOwnerTable.set(doc, d);
}
return d;
}
function extractContent(templateElement) {
var doc = getTemplateContentsOwner(templateElement.ownerDocument);
var df = unwrap(doc.createDocumentFragment());
var child;
while (child = templateElement.firstChild) {
df.appendChild(child);
}
return df;
}
var OriginalHTMLTemplateElement = window.HTMLTemplateElement;
function HTMLTemplateElement(node) {
HTMLElement.call(this, node);
if (!OriginalHTMLTemplateElement) {
var content = extractContent(node);
contentTable.set(this, wrap(content));
}
}
HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLTemplateElement.prototype, {
constructor: HTMLTemplateElement,
get content() {
if (OriginalHTMLTemplateElement)
return wrap(unsafeUnwrap(this).content);
return contentTable.get(this);
}
});
if (OriginalHTMLTemplateElement)
registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);
scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var registerWrapper = scope.registerWrapper;
var OriginalHTMLMediaElement = window.HTMLMediaElement;
if (!OriginalHTMLMediaElement)
return;
function HTMLMediaElement(node) {
HTMLElement.call(this, node);
}
HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);
registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement('audio'));
scope.wrappers.HTMLMediaElement = HTMLMediaElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLMediaElement = scope.wrappers.HTMLMediaElement;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var rewrap = scope.rewrap;
var OriginalHTMLAudioElement = window.HTMLAudioElement;
if (!OriginalHTMLAudioElement)
return;
function HTMLAudioElement(node) {
HTMLMediaElement.call(this, node);
}
HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);
registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement('audio'));
function Audio(src) {
if (!(this instanceof Audio)) {
throw new TypeError('DOM object constructor cannot be called as a function.');
}
var node = unwrap(document.createElement('audio'));
HTMLMediaElement.call(this, node);
rewrap(node, this);
node.setAttribute('preload', 'auto');
if (src !== undefined)
node.setAttribute('src', src);
}
Audio.prototype = HTMLAudioElement.prototype;
scope.wrappers.HTMLAudioElement = HTMLAudioElement;
scope.wrappers.Audio = Audio;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var rewrap = scope.rewrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var OriginalHTMLOptionElement = window.HTMLOptionElement;
function trimText(s) {
return s.replace(/\s+/g, ' ').trim();
}
function HTMLOptionElement(node) {
HTMLElement.call(this, node);
}
HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLOptionElement.prototype, {
get text() {
return trimText(this.textContent);
},
set text(value) {
this.textContent = trimText(String(value));
},
get form() {
return wrap(unwrap(this).form);
}
});
registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement('option'));
function Option(text, value, defaultSelected, selected) {
if (!(this instanceof Option)) {
throw new TypeError('DOM object constructor cannot be called as a function.');
}
var node = unwrap(document.createElement('option'));
HTMLElement.call(this, node);
rewrap(node, this);
if (text !== undefined)
node.text = text;
if (value !== undefined)
node.setAttribute('value', value);
if (defaultSelected === true)
node.setAttribute('selected', '');
node.selected = selected === true;
}
Option.prototype = HTMLOptionElement.prototype;
scope.wrappers.HTMLOptionElement = HTMLOptionElement;
scope.wrappers.Option = Option;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var OriginalHTMLSelectElement = window.HTMLSelectElement;
function HTMLSelectElement(node) {
HTMLElement.call(this, node);
}
HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLSelectElement.prototype, {
add: function (element, before) {
if (typeof before === 'object')
before = unwrap(before);
unwrap(this).add(unwrap(element), before);
},
remove: function (indexOrNode) {
if (indexOrNode === undefined) {
HTMLElement.prototype.remove.call(this);
return;
}
if (typeof indexOrNode === 'object')
indexOrNode = unwrap(indexOrNode);
unwrap(this).remove(indexOrNode);
},
get form() {
return wrap(unwrap(this).form);
}
});
registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement('select'));
scope.wrappers.HTMLSelectElement = HTMLSelectElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var wrapHTMLCollection = scope.wrapHTMLCollection;
var OriginalHTMLTableElement = window.HTMLTableElement;
function HTMLTableElement(node) {
HTMLElement.call(this, node);
}
HTMLTableElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLTableElement.prototype, {
get caption() {
return wrap(unwrap(this).caption);
},
createCaption: function () {
return wrap(unwrap(this).createCaption());
},
get tHead() {
return wrap(unwrap(this).tHead);
},
createTHead: function () {
return wrap(unwrap(this).createTHead());
},
createTFoot: function () {
return wrap(unwrap(this).createTFoot());
},
get tFoot() {
return wrap(unwrap(this).tFoot);
},
get tBodies() {
return wrapHTMLCollection(unwrap(this).tBodies);
},
createTBody: function () {
return wrap(unwrap(this).createTBody());
},
get rows() {
return wrapHTMLCollection(unwrap(this).rows);
},
insertRow: function (index) {
return wrap(unwrap(this).insertRow(index));
}
});
registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement('table'));
scope.wrappers.HTMLTableElement = HTMLTableElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var wrapHTMLCollection = scope.wrapHTMLCollection;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;
function HTMLTableSectionElement(node) {
HTMLElement.call(this, node);
}
HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLTableSectionElement.prototype, {
constructor: HTMLTableSectionElement,
get rows() {
return wrapHTMLCollection(unwrap(this).rows);
},
insertRow: function (index) {
return wrap(unwrap(this).insertRow(index));
}
});
registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement('thead'));
scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var wrapHTMLCollection = scope.wrapHTMLCollection;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var OriginalHTMLTableRowElement = window.HTMLTableRowElement;
function HTMLTableRowElement(node) {
HTMLElement.call(this, node);
}
HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);
mixin(HTMLTableRowElement.prototype, {
get cells() {
return wrapHTMLCollection(unwrap(this).cells);
},
insertCell: function (index) {
return wrap(unwrap(this).insertCell(index));
}
});
registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement('tr'));
scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLContentElement = scope.wrappers.HTMLContentElement;
var HTMLElement = scope.wrappers.HTMLElement;
var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var OriginalHTMLUnknownElement = window.HTMLUnknownElement;
function HTMLUnknownElement(node) {
switch (node.localName) {
case 'content':
return new HTMLContentElement(node);
case 'shadow':
return new HTMLShadowElement(node);
case 'template':
return new HTMLTemplateElement(node);
}
HTMLElement.call(this, node);
}
HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);
registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);
scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var Element = scope.wrappers.Element;
var HTMLElement = scope.wrappers.HTMLElement;
var registerWrapper = scope.registerWrapper;
var defineWrapGetter = scope.defineWrapGetter;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var mixin = scope.mixin;
var SVG_NS = 'http://www.w3.org/2000/svg';
var OriginalSVGElement = window.SVGElement;
var svgTitleElement = document.createElementNS(SVG_NS, 'title');
if (!('classList' in svgTitleElement)) {
var descr = Object.getOwnPropertyDescriptor(Element.prototype, 'classList');
Object.defineProperty(HTMLElement.prototype, 'classList', descr);
delete Element.prototype.classList;
}
function SVGElement(node) {
Element.call(this, node);
}
SVGElement.prototype = Object.create(Element.prototype);
mixin(SVGElement.prototype, {
get ownerSVGElement() {
return wrap(unsafeUnwrap(this).ownerSVGElement);
}
});
registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, 'title'));
scope.wrappers.SVGElement = SVGElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var OriginalSVGUseElement = window.SVGUseElement;
var SVG_NS = 'http://www.w3.org/2000/svg';
var gWrapper = wrap(document.createElementNS(SVG_NS, 'g'));
var useElement = document.createElementNS(SVG_NS, 'use');
var SVGGElement = gWrapper.constructor;
var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);
var parentInterface = parentInterfacePrototype.constructor;
function SVGUseElement(impl) {
parentInterface.call(this, impl);
}
SVGUseElement.prototype = Object.create(parentInterfacePrototype);
if ('instanceRoot' in useElement) {
mixin(SVGUseElement.prototype, {
get instanceRoot() {
return wrap(unwrap(this).instanceRoot);
},
get animatedInstanceRoot() {
return wrap(unwrap(this).animatedInstanceRoot);
}
});
}
registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);
scope.wrappers.SVGUseElement = SVGUseElement;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var EventTarget = scope.wrappers.EventTarget;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var wrap = scope.wrap;
var OriginalSVGElementInstance = window.SVGElementInstance;
if (!OriginalSVGElementInstance)
return;
function SVGElementInstance(impl) {
EventTarget.call(this, impl);
}
SVGElementInstance.prototype = Object.create(EventTarget.prototype);
mixin(SVGElementInstance.prototype, {
get correspondingElement() {
return wrap(unsafeUnwrap(this).correspondingElement);
},
get correspondingUseElement() {
return wrap(unsafeUnwrap(this).correspondingUseElement);
},
get parentNode() {
return wrap(unsafeUnwrap(this).parentNode);
},
get childNodes() {
throw new Error('Not implemented');
},
get firstChild() {
return wrap(unsafeUnwrap(this).firstChild);
},
get lastChild() {
return wrap(unsafeUnwrap(this).lastChild);
},
get previousSibling() {
return wrap(unsafeUnwrap(this).previousSibling);
},
get nextSibling() {
return wrap(unsafeUnwrap(this).nextSibling);
}
});
registerWrapper(OriginalSVGElementInstance, SVGElementInstance);
scope.wrappers.SVGElementInstance = SVGElementInstance;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;
function CanvasRenderingContext2D(impl) {
setWrapper(impl, this);
}
mixin(CanvasRenderingContext2D.prototype, {
get canvas() {
return wrap(unsafeUnwrap(this).canvas);
},
drawImage: function () {
arguments[0] = unwrapIfNeeded(arguments[0]);
unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);
},
createPattern: function () {
arguments[0] = unwrap(arguments[0]);
return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);
}
});
registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement('canvas').getContext('2d'));
scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var addForwardingProperties = scope.addForwardingProperties;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var OriginalWebGLRenderingContext = window.WebGLRenderingContext;
if (!OriginalWebGLRenderingContext)
return;
function WebGLRenderingContext(impl) {
setWrapper(impl, this);
}
mixin(WebGLRenderingContext.prototype, {
get canvas() {
return wrap(unsafeUnwrap(this).canvas);
},
texImage2D: function () {
arguments[5] = unwrapIfNeeded(arguments[5]);
unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);
},
texSubImage2D: function () {
arguments[6] = unwrapIfNeeded(arguments[6]);
unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);
}
});
var OriginalWebGLRenderingContextBase = Object.getPrototypeOf(OriginalWebGLRenderingContext.prototype);
if (OriginalWebGLRenderingContextBase !== Object.prototype) {
addForwardingProperties(OriginalWebGLRenderingContextBase, WebGLRenderingContext.prototype);
}
var instanceProperties = /WebKit/.test(navigator.userAgent) ? {
drawingBufferHeight: null,
drawingBufferWidth: null
} : {};
registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);
scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var Node = scope.wrappers.Node;
var GetElementsByInterface = scope.GetElementsByInterface;
var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;
var ParentNodeInterface = scope.ParentNodeInterface;
var SelectorsInterface = scope.SelectorsInterface;
var mixin = scope.mixin;
var registerObject = scope.registerObject;
var registerWrapper = scope.registerWrapper;
var OriginalDocumentFragment = window.DocumentFragment;
function DocumentFragment(node) {
Node.call(this, node);
}
DocumentFragment.prototype = Object.create(Node.prototype);
mixin(DocumentFragment.prototype, ParentNodeInterface);
mixin(DocumentFragment.prototype, SelectorsInterface);
mixin(DocumentFragment.prototype, GetElementsByInterface);
mixin(DocumentFragment.prototype, NonElementParentNodeInterface);
registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());
scope.wrappers.DocumentFragment = DocumentFragment;
var Comment = registerObject(document.createComment(''));
scope.wrappers.Comment = Comment;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var DocumentFragment = scope.wrappers.DocumentFragment;
var TreeScope = scope.TreeScope;
var elementFromPoint = scope.elementFromPoint;
var getInnerHTML = scope.getInnerHTML;
var getTreeScope = scope.getTreeScope;
var mixin = scope.mixin;
var rewrap = scope.rewrap;
var setInnerHTML = scope.setInnerHTML;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var shadowHostTable = new WeakMap();
var nextOlderShadowTreeTable = new WeakMap();
function ShadowRoot(hostWrapper) {
var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());
DocumentFragment.call(this, node);
rewrap(node, this);
var oldShadowRoot = hostWrapper.shadowRoot;
nextOlderShadowTreeTable.set(this, oldShadowRoot);
this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));
shadowHostTable.set(this, hostWrapper);
}
ShadowRoot.prototype = Object.create(DocumentFragment.prototype);
mixin(ShadowRoot.prototype, {
constructor: ShadowRoot,
get innerHTML() {
return getInnerHTML(this);
},
set innerHTML(value) {
setInnerHTML(this, value);
this.invalidateShadowRenderer();
},
get olderShadowRoot() {
return nextOlderShadowTreeTable.get(this) || null;
},
get host() {
return shadowHostTable.get(this) || null;
},
invalidateShadowRenderer: function () {
return shadowHostTable.get(this).invalidateShadowRenderer();
},
elementFromPoint: function (x, y) {
return elementFromPoint(this, this.ownerDocument, x, y);
},
getSelection: function () {
return document.getSelection();
},
get activeElement() {
var unwrappedActiveElement = unwrap(this).ownerDocument.activeElement;
if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType)
return null;
var activeElement = wrap(unwrappedActiveElement);
while (!this.contains(activeElement)) {
while (activeElement.parentNode) {
activeElement = activeElement.parentNode;
}
if (activeElement.host) {
activeElement = activeElement.host;
} else {
return null;
}
}
return activeElement;
}
});
scope.wrappers.ShadowRoot = ShadowRoot;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var getTreeScope = scope.getTreeScope;
var OriginalRange = window.Range;
var ShadowRoot = scope.wrappers.ShadowRoot;
function getHost(node) {
var root = getTreeScope(node).root;
if (root instanceof ShadowRoot) {
return root.host;
}
return null;
}
function hostNodeToShadowNode(refNode, offset) {
if (refNode.shadowRoot) {
offset = Math.min(refNode.childNodes.length - 1, offset);
var child = refNode.childNodes[offset];
if (child) {
var insertionPoint = scope.getDestinationInsertionPoints(child);
if (insertionPoint.length > 0) {
var parentNode = insertionPoint[0].parentNode;
if (parentNode.nodeType == Node.ELEMENT_NODE) {
refNode = parentNode;
}
}
}
}
return refNode;
}
function shadowNodeToHostNode(node) {
node = wrap(node);
return getHost(node) || node;
}
function Range(impl) {
setWrapper(impl, this);
}
Range.prototype = {
get startContainer() {
return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);
},
get endContainer() {
return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);
},
get commonAncestorContainer() {
return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);
},
setStart: function (refNode, offset) {
refNode = hostNodeToShadowNode(refNode, offset);
unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);
},
setEnd: function (refNode, offset) {
refNode = hostNodeToShadowNode(refNode, offset);
unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);
},
setStartBefore: function (refNode) {
unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));
},
setStartAfter: function (refNode) {
unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));
},
setEndBefore: function (refNode) {
unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));
},
setEndAfter: function (refNode) {
unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));
},
selectNode: function (refNode) {
unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));
},
selectNodeContents: function (refNode) {
unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));
},
compareBoundaryPoints: function (how, sourceRange) {
return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));
},
extractContents: function () {
return wrap(unsafeUnwrap(this).extractContents());
},
cloneContents: function () {
return wrap(unsafeUnwrap(this).cloneContents());
},
insertNode: function (node) {
unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));
},
surroundContents: function (newParent) {
unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));
},
cloneRange: function () {
return wrap(unsafeUnwrap(this).cloneRange());
},
isPointInRange: function (node, offset) {
return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);
},
comparePoint: function (node, offset) {
return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);
},
intersectsNode: function (node) {
return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));
},
toString: function () {
return unsafeUnwrap(this).toString();
}
};
if (OriginalRange.prototype.createContextualFragment) {
Range.prototype.createContextualFragment = function (html) {
return wrap(unsafeUnwrap(this).createContextualFragment(html));
};
}
registerWrapper(window.Range, Range, document.createRange());
scope.wrappers.Range = Range;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var Element = scope.wrappers.Element;
var HTMLContentElement = scope.wrappers.HTMLContentElement;
var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
var Node = scope.wrappers.Node;
var ShadowRoot = scope.wrappers.ShadowRoot;
var assert = scope.assert;
var getTreeScope = scope.getTreeScope;
var mixin = scope.mixin;
var oneOf = scope.oneOf;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var ArraySplice = scope.ArraySplice;
function updateWrapperUpAndSideways(wrapper) {
wrapper.previousSibling_ = wrapper.previousSibling;
wrapper.nextSibling_ = wrapper.nextSibling;
wrapper.parentNode_ = wrapper.parentNode;
}
function updateWrapperDown(wrapper) {
wrapper.firstChild_ = wrapper.firstChild;
wrapper.lastChild_ = wrapper.lastChild;
}
function updateAllChildNodes(parentNodeWrapper) {
assert(parentNodeWrapper instanceof Node);
for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {
updateWrapperUpAndSideways(childWrapper);
}
updateWrapperDown(parentNodeWrapper);
}
function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {
var parentNode = unwrap(parentNodeWrapper);
var newChild = unwrap(newChildWrapper);
var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;
remove(newChildWrapper);
updateWrapperUpAndSideways(newChildWrapper);
if (!refChildWrapper) {
parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;
if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild)
parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;
var lastChildWrapper = wrap(parentNode.lastChild);
if (lastChildWrapper)
lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;
} else {
if (parentNodeWrapper.firstChild === refChildWrapper)
parentNodeWrapper.firstChild_ = refChildWrapper;
refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;
}
scope.originalInsertBefore.call(parentNode, newChild, refChild);
}
function remove(nodeWrapper) {
var node = unwrap(nodeWrapper);
var parentNode = node.parentNode;
if (!parentNode)
return;
var parentNodeWrapper = wrap(parentNode);
updateWrapperUpAndSideways(nodeWrapper);
if (nodeWrapper.previousSibling)
nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;
if (nodeWrapper.nextSibling)
nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;
if (parentNodeWrapper.lastChild === nodeWrapper)
parentNodeWrapper.lastChild_ = nodeWrapper;
if (parentNodeWrapper.firstChild === nodeWrapper)
parentNodeWrapper.firstChild_ = nodeWrapper;
scope.originalRemoveChild.call(parentNode, node);
}
var distributedNodesTable = new WeakMap();
var destinationInsertionPointsTable = new WeakMap();
var rendererForHostTable = new WeakMap();
function resetDistributedNodes(insertionPoint) {
distributedNodesTable.set(insertionPoint, []);
}
function getDistributedNodes(insertionPoint) {
var rv = distributedNodesTable.get(insertionPoint);
if (!rv)
distributedNodesTable.set(insertionPoint, rv = []);
return rv;
}
function getChildNodesSnapshot(node) {
var result = [], i = 0;
for (var child = node.firstChild; child; child = child.nextSibling) {
result[i++] = child;
}
return result;
}
var request = oneOf(window, [
'requestAnimationFrame',
'mozRequestAnimationFrame',
'webkitRequestAnimationFrame',
'setTimeout'
]);
var pendingDirtyRenderers = [];
var renderTimer;
function renderAllPending() {
for (var i = 0; i < pendingDirtyRenderers.length; i++) {
var renderer = pendingDirtyRenderers[i];
var parentRenderer = renderer.parentRenderer;
if (parentRenderer && parentRenderer.dirty)
continue;
renderer.render();
}
pendingDirtyRenderers = [];
}
function handleRequestAnimationFrame() {
renderTimer = null;
renderAllPending();
}
function getRendererForHost(host) {
var renderer = rendererForHostTable.get(host);
if (!renderer) {
renderer = new ShadowRenderer(host);
rendererForHostTable.set(host, renderer);
}
return renderer;
}
function getShadowRootAncestor(node) {
var root = getTreeScope(node).root;
if (root instanceof ShadowRoot)
return root;
return null;
}
function getRendererForShadowRoot(shadowRoot) {
return getRendererForHost(shadowRoot.host);
}
var spliceDiff = new ArraySplice();
spliceDiff.equals = function (renderNode, rawNode) {
return unwrap(renderNode.node) === rawNode;
};
function RenderNode(node) {
this.skip = false;
this.node = node;
this.childNodes = [];
}
RenderNode.prototype = {
append: function (node) {
var rv = new RenderNode(node);
this.childNodes.push(rv);
return rv;
},
sync: function (opt_added) {
if (this.skip)
return;
var nodeWrapper = this.node;
var newChildren = this.childNodes;
var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));
var added = opt_added || new WeakMap();
var splices = spliceDiff.calculateSplices(newChildren, oldChildren);
var newIndex = 0, oldIndex = 0;
var lastIndex = 0;
for (var i = 0; i < splices.length; i++) {
var splice = splices[i];
for (; lastIndex < splice.index; lastIndex++) {
oldIndex++;
newChildren[newIndex++].sync(added);
}
var removedCount = splice.removed.length;
for (var j = 0; j < removedCount; j++) {
var wrapper = wrap(oldChildren[oldIndex++]);
if (!added.get(wrapper))
remove(wrapper);
}
var addedCount = splice.addedCount;
var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);
for (var j = 0; j < addedCount; j++) {
var newChildRenderNode = newChildren[newIndex++];
var newChildWrapper = newChildRenderNode.node;
insertBefore(nodeWrapper, newChildWrapper, refNode);
added.set(newChildWrapper, true);
newChildRenderNode.sync(added);
}
lastIndex += addedCount;
}
for (var i = lastIndex; i < newChildren.length; i++) {
newChildren[i].sync(added);
}
}
};
function ShadowRenderer(host) {
this.host = host;
this.dirty = false;
this.invalidateAttributes();
this.associateNode(host);
}
ShadowRenderer.prototype = {
render: function (opt_renderNode) {
if (!this.dirty)
return;
this.invalidateAttributes();
var host = this.host;
this.distribution(host);
var renderNode = opt_renderNode || new RenderNode(host);
this.buildRenderTree(renderNode, host);
var topMostRenderer = !opt_renderNode;
if (topMostRenderer)
renderNode.sync();
this.dirty = false;
},
get parentRenderer() {
return getTreeScope(this.host).renderer;
},
invalidate: function () {
if (!this.dirty) {
this.dirty = true;
var parentRenderer = this.parentRenderer;
if (parentRenderer)
parentRenderer.invalidate();
pendingDirtyRenderers.push(this);
if (renderTimer)
return;
renderTimer = window[request](handleRequestAnimationFrame, 0);
}
},
distribution: function (root) {
this.resetAllSubtrees(root);
this.distributionResolution(root);
},
resetAll: function (node) {
if (isInsertionPoint(node))
resetDistributedNodes(node);
else
resetDestinationInsertionPoints(node);
this.resetAllSubtrees(node);
},
resetAllSubtrees: function (node) {
for (var child = node.firstChild; child; child = child.nextSibling) {
this.resetAll(child);
}
if (node.shadowRoot)
this.resetAll(node.shadowRoot);
if (node.olderShadowRoot)
this.resetAll(node.olderShadowRoot);
},
distributionResolution: function (node) {
if (isShadowHost(node)) {
var shadowHost = node;
var pool = poolPopulation(shadowHost);
var shadowTrees = getShadowTrees(shadowHost);
for (var i = 0; i < shadowTrees.length; i++) {
this.poolDistribution(shadowTrees[i], pool);
}
for (var i = shadowTrees.length - 1; i >= 0; i--) {
var shadowTree = shadowTrees[i];
var shadow = getShadowInsertionPoint(shadowTree);
if (shadow) {
var olderShadowRoot = shadowTree.olderShadowRoot;
if (olderShadowRoot) {
pool = poolPopulation(olderShadowRoot);
}
for (var j = 0; j < pool.length; j++) {
destributeNodeInto(pool[j], shadow);
}
}
this.distributionResolution(shadowTree);
}
}
for (var child = node.firstChild; child; child = child.nextSibling) {
this.distributionResolution(child);
}
},
poolDistribution: function (node, pool) {
if (node instanceof HTMLShadowElement)
return;
if (node instanceof HTMLContentElement) {
var content = node;
this.updateDependentAttributes(content.getAttribute('select'));
var anyDistributed = false;
for (var i = 0; i < pool.length; i++) {
var node = pool[i];
if (!node)
continue;
if (matches(node, content)) {
destributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
for (var child = content.firstChild; child; child = child.nextSibling) {
destributeNodeInto(child, content);
}
}
return;
}
for (var child = node.firstChild; child; child = child.nextSibling) {
this.poolDistribution(child, pool);
}
},
buildRenderTree: function (renderNode, node) {
var children = this.compose(node);
for (var i = 0; i < children.length; i++) {
var child = children[i];
var childRenderNode = renderNode.append(child);
this.buildRenderTree(childRenderNode, child);
}
if (isShadowHost(node)) {
var renderer = getRendererForHost(node);
renderer.dirty = false;
}
},
compose: function (node) {
var children = [];
var p = node.shadowRoot || node;
for (var child = p.firstChild; child; child = child.nextSibling) {
if (isInsertionPoint(child)) {
this.associateNode(p);
var distributedNodes = getDistributedNodes(child);
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode))
children.push(distributedNode);
}
} else {
children.push(child);
}
}
return children;
},
invalidateAttributes: function () {
this.attributes = Object.create(null);
},
updateDependentAttributes: function (selector) {
if (!selector)
return;
var attributes = this.attributes;
if (/\.\w+/.test(selector))
attributes['class'] = true;
if (/#\w+/.test(selector))
attributes['id'] = true;
selector.replace(/\[\s*([^\s=\|~\]]+)/g, function (_, name) {
attributes[name] = true;
});
},
dependsOnAttribute: function (name) {
return this.attributes[name];
},
associateNode: function (node) {
unsafeUnwrap(node).polymerShadowRenderer_ = this;
}
};
function poolPopulation(node) {
var pool = [];
for (var child = node.firstChild; child; child = child.nextSibling) {
if (isInsertionPoint(child)) {
pool.push.apply(pool, getDistributedNodes(child));
} else {
pool.push(child);
}
}
return pool;
}
function getShadowInsertionPoint(node) {
if (node instanceof HTMLShadowElement)
return node;
if (node instanceof HTMLContentElement)
return null;
for (var child = node.firstChild; child; child = child.nextSibling) {
var res = getShadowInsertionPoint(child);
if (res)
return res;
}
return null;
}
function destributeNodeInto(child, insertionPoint) {
getDistributedNodes(insertionPoint).push(child);
var points = destinationInsertionPointsTable.get(child);
if (!points)
destinationInsertionPointsTable.set(child, [insertionPoint]);
else
points.push(insertionPoint);
}
function getDestinationInsertionPoints(node) {
return destinationInsertionPointsTable.get(node);
}
function resetDestinationInsertionPoints(node) {
destinationInsertionPointsTable.set(node, undefined);
}
var selectorStartCharRe = /^(:not\()?[*.#[a-zA-Z_|]/;
function matches(node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select)
return true;
select = select.trim();
if (!select)
return true;
if (!(node instanceof Element))
return false;
if (!selectorStartCharRe.test(select))
return false;
try {
return node.matches(select);
} catch (ex) {
return false;
}
}
function isFinalDestination(insertionPoint, node) {
var points = getDestinationInsertionPoints(node);
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;
}
function isShadowHost(shadowHost) {
return shadowHost.shadowRoot;
}
function getShadowTrees(host) {
var trees = [];
for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {
trees.push(tree);
}
return trees;
}
function render(host) {
new ShadowRenderer(host).render();
}
Node.prototype.invalidateShadowRenderer = function (force) {
var renderer = unsafeUnwrap(this).polymerShadowRenderer_;
if (renderer) {
renderer.invalidate();
return true;
}
return false;
};
HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function () {
renderAllPending();
return getDistributedNodes(this);
};
Element.prototype.getDestinationInsertionPoints = function () {
renderAllPending();
return getDestinationInsertionPoints(this) || [];
};
HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function () {
this.invalidateShadowRenderer();
var shadowRoot = getShadowRootAncestor(this);
var renderer;
if (shadowRoot)
renderer = getRendererForShadowRoot(shadowRoot);
unsafeUnwrap(this).polymerShadowRenderer_ = renderer;
if (renderer)
renderer.invalidate();
};
scope.getRendererForHost = getRendererForHost;
scope.getShadowTrees = getShadowTrees;
scope.renderAllPending = renderAllPending;
scope.getDestinationInsertionPoints = getDestinationInsertionPoints;
scope.visual = {
insertBefore: insertBefore,
remove: remove
};
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var HTMLElement = scope.wrappers.HTMLElement;
var assert = scope.assert;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var elementsWithFormProperty = [
'HTMLButtonElement',
'HTMLFieldSetElement',
'HTMLInputElement',
'HTMLKeygenElement',
'HTMLLabelElement',
'HTMLLegendElement',
'HTMLObjectElement',
'HTMLOutputElement',
'HTMLTextAreaElement'
];
function createWrapperConstructor(name) {
if (!window[name])
return;
assert(!scope.wrappers[name]);
var GeneratedWrapper = function (node) {
HTMLElement.call(this, node);
};
GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);
mixin(GeneratedWrapper.prototype, {
get form() {
return wrap(unwrap(this).form);
}
});
registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));
scope.wrappers[name] = GeneratedWrapper;
}
elementsWithFormProperty.forEach(createWrapperConstructor);
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var OriginalSelection = window.Selection;
function Selection(impl) {
setWrapper(impl, this);
}
Selection.prototype = {
get anchorNode() {
return wrap(unsafeUnwrap(this).anchorNode);
},
get focusNode() {
return wrap(unsafeUnwrap(this).focusNode);
},
addRange: function (range) {
unsafeUnwrap(this).addRange(unwrapIfNeeded(range));
},
collapse: function (node, index) {
unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);
},
containsNode: function (node, allowPartial) {
return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);
},
getRangeAt: function (index) {
return wrap(unsafeUnwrap(this).getRangeAt(index));
},
removeRange: function (range) {
unsafeUnwrap(this).removeRange(unwrap(range));
},
selectAllChildren: function (node) {
unsafeUnwrap(this).selectAllChildren(node instanceof ShadowRoot ? unsafeUnwrap(node.host) : unwrapIfNeeded(node));
},
toString: function () {
return unsafeUnwrap(this).toString();
}
};
if (OriginalSelection.prototype.extend) {
Selection.prototype.extend = function (node, offset) {
unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);
};
}
registerWrapper(window.Selection, Selection, window.getSelection());
scope.wrappers.Selection = Selection;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var OriginalTreeWalker = window.TreeWalker;
function TreeWalker(impl) {
setWrapper(impl, this);
}
TreeWalker.prototype = {
get root() {
return wrap(unsafeUnwrap(this).root);
},
get currentNode() {
return wrap(unsafeUnwrap(this).currentNode);
},
set currentNode(node) {
unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);
},
get filter() {
return unsafeUnwrap(this).filter;
},
parentNode: function () {
return wrap(unsafeUnwrap(this).parentNode());
},
firstChild: function () {
return wrap(unsafeUnwrap(this).firstChild());
},
lastChild: function () {
return wrap(unsafeUnwrap(this).lastChild());
},
previousSibling: function () {
return wrap(unsafeUnwrap(this).previousSibling());
},
previousNode: function () {
return wrap(unsafeUnwrap(this).previousNode());
},
nextNode: function () {
return wrap(unsafeUnwrap(this).nextNode());
}
};
registerWrapper(OriginalTreeWalker, TreeWalker);
scope.wrappers.TreeWalker = TreeWalker;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var GetElementsByInterface = scope.GetElementsByInterface;
var Node = scope.wrappers.Node;
var ParentNodeInterface = scope.ParentNodeInterface;
var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;
var Selection = scope.wrappers.Selection;
var SelectorsInterface = scope.SelectorsInterface;
var ShadowRoot = scope.wrappers.ShadowRoot;
var TreeScope = scope.TreeScope;
var cloneNode = scope.cloneNode;
var defineGetter = scope.defineGetter;
var defineWrapGetter = scope.defineWrapGetter;
var elementFromPoint = scope.elementFromPoint;
var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
var matchesNames = scope.matchesNames;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var renderAllPending = scope.renderAllPending;
var rewrap = scope.rewrap;
var setWrapper = scope.setWrapper;
var unsafeUnwrap = scope.unsafeUnwrap;
var unwrap = scope.unwrap;
var wrap = scope.wrap;
var wrapEventTargetMethods = scope.wrapEventTargetMethods;
var wrapNodeList = scope.wrapNodeList;
var implementationTable = new WeakMap();
function Document(node) {
Node.call(this, node);
this.treeScope_ = new TreeScope(this, null);
}
Document.prototype = Object.create(Node.prototype);
defineWrapGetter(Document, 'documentElement');
defineWrapGetter(Document, 'body');
defineWrapGetter(Document, 'head');
defineGetter(Document, 'activeElement', function () {
var unwrappedActiveElement = unwrap(this).activeElement;
if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType)
return null;
var activeElement = wrap(unwrappedActiveElement);
while (!this.contains(activeElement)) {
while (activeElement.parentNode) {
activeElement = activeElement.parentNode;
}
if (activeElement.host) {
activeElement = activeElement.host;
} else {
return null;
}
}
return activeElement;
});
function wrapMethod(name) {
var original = document[name];
Document.prototype[name] = function () {
return wrap(original.apply(unsafeUnwrap(this), arguments));
};
}
[
'createComment',
'createDocumentFragment',
'createElement',
'createElementNS',
'createEvent',
'createEventNS',
'createRange',
'createTextNode'
].forEach(wrapMethod);
var originalAdoptNode = document.adoptNode;
function adoptNodeNoRemove(node, doc) {
originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));
adoptSubtree(node, doc);
}
function adoptSubtree(node, doc) {
if (node.shadowRoot)
doc.adoptNode(node.shadowRoot);
if (node instanceof ShadowRoot)
adoptOlderShadowRoots(node, doc);
for (var child = node.firstChild; child; child = child.nextSibling) {
adoptSubtree(child, doc);
}
}
function adoptOlderShadowRoots(shadowRoot, doc) {
var oldShadowRoot = shadowRoot.olderShadowRoot;
if (oldShadowRoot)
doc.adoptNode(oldShadowRoot);
}
var originalGetSelection = document.getSelection;
mixin(Document.prototype, {
adoptNode: function (node) {
if (node.parentNode)
node.parentNode.removeChild(node);
adoptNodeNoRemove(node, this);
return node;
},
elementFromPoint: function (x, y) {
return elementFromPoint(this, this, x, y);
},
importNode: function (node, deep) {
return cloneNode(node, deep, unsafeUnwrap(this));
},
getSelection: function () {
renderAllPending();
return new Selection(originalGetSelection.call(unwrap(this)));
},
getElementsByName: function (name) {
return SelectorsInterface.querySelectorAll.call(this, '[name=' + JSON.stringify(String(name)) + ']');
}
});
var originalCreateTreeWalker = document.createTreeWalker;
var TreeWalkerWrapper = scope.wrappers.TreeWalker;
Document.prototype.createTreeWalker = function (root, whatToShow, filter, expandEntityReferences) {
var newFilter = null;
if (filter) {
if (filter.acceptNode && typeof filter.acceptNode === 'function') {
newFilter = {
acceptNode: function (node) {
return filter.acceptNode(wrap(node));
}
};
} else if (typeof filter === 'function') {
newFilter = function (node) {
return filter(wrap(node));
};
}
}
return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));
};
if (document.registerElement) {
var originalRegisterElement = document.registerElement;
Document.prototype.registerElement = function (tagName, object) {
var prototype, extendsOption;
if (object !== undefined) {
prototype = object.prototype;
extendsOption = object.extends;
}
if (!prototype)
prototype = Object.create(HTMLElement.prototype);
if (scope.nativePrototypeTable.get(prototype)) {
throw new Error('NotSupportedError');
}
var proto = Object.getPrototypeOf(prototype);
var nativePrototype;
var prototypes = [];
while (proto) {
nativePrototype = scope.nativePrototypeTable.get(proto);
if (nativePrototype)
break;
prototypes.push(proto);
proto = Object.getPrototypeOf(proto);
}
if (!nativePrototype) {
throw new Error('NotSupportedError');
}
var newPrototype = Object.create(nativePrototype);
for (var i = prototypes.length - 1; i >= 0; i--) {
newPrototype = Object.create(newPrototype);
}
[
'createdCallback',
'attachedCallback',
'detachedCallback',
'attributeChangedCallback'
].forEach(function (name) {
var f = prototype[name];
if (!f)
return;
newPrototype[name] = function () {
if (!(wrap(this) instanceof CustomElementConstructor)) {
rewrap(this);
}
f.apply(wrap(this), arguments);
};
});
var p = { prototype: newPrototype };
if (extendsOption)
p.extends = extendsOption;
function CustomElementConstructor(node) {
if (!node) {
if (extendsOption) {
return document.createElement(extendsOption, tagName);
} else {
return document.createElement(tagName);
}
}
setWrapper(node, this);
}
CustomElementConstructor.prototype = prototype;
CustomElementConstructor.prototype.constructor = CustomElementConstructor;
scope.constructorTable.set(newPrototype, CustomElementConstructor);
scope.nativePrototypeTable.set(prototype, newPrototype);
var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);
return CustomElementConstructor;
};
forwardMethodsToWrapper([window.HTMLDocument || window.Document], ['registerElement']);
}
forwardMethodsToWrapper([
window.HTMLBodyElement,
window.HTMLDocument || window.Document,
window.HTMLHeadElement,
window.HTMLHtmlElement
], [
'appendChild',
'compareDocumentPosition',
'contains',
'getElementsByClassName',
'getElementsByTagName',
'getElementsByTagNameNS',
'insertBefore',
'querySelector',
'querySelectorAll',
'removeChild',
'replaceChild'
]);
forwardMethodsToWrapper([
window.HTMLBodyElement,
window.HTMLHeadElement,
window.HTMLHtmlElement
], matchesNames);
forwardMethodsToWrapper([window.HTMLDocument || window.Document], [
'adoptNode',
'importNode',
'contains',
'createComment',
'createDocumentFragment',
'createElement',
'createElementNS',
'createEvent',
'createEventNS',
'createRange',
'createTextNode',
'createTreeWalker',
'elementFromPoint',
'getElementById',
'getElementsByName',
'getSelection'
]);
mixin(Document.prototype, GetElementsByInterface);
mixin(Document.prototype, ParentNodeInterface);
mixin(Document.prototype, SelectorsInterface);
mixin(Document.prototype, NonElementParentNodeInterface);
mixin(Document.prototype, {
get implementation() {
var implementation = implementationTable.get(this);
if (implementation)
return implementation;
implementation = new DOMImplementation(unwrap(this).implementation);
implementationTable.set(this, implementation);
return implementation;
},
get defaultView() {
return wrap(unwrap(this).defaultView);
}
});
registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(''));
if (window.HTMLDocument)
registerWrapper(window.HTMLDocument, Document);
wrapEventTargetMethods([
window.HTMLBodyElement,
window.HTMLDocument || window.Document,
window.HTMLHeadElement
]);
function DOMImplementation(impl) {
setWrapper(impl, this);
}
var originalCreateDocument = document.implementation.createDocument;
DOMImplementation.prototype.createDocument = function () {
arguments[2] = unwrap(arguments[2]);
return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));
};
function wrapImplMethod(constructor, name) {
var original = document.implementation[name];
constructor.prototype[name] = function () {
return wrap(original.apply(unsafeUnwrap(this), arguments));
};
}
function forwardImplMethod(constructor, name) {
var original = document.implementation[name];
constructor.prototype[name] = function () {
return original.apply(unsafeUnwrap(this), arguments);
};
}
wrapImplMethod(DOMImplementation, 'createDocumentType');
wrapImplMethod(DOMImplementation, 'createHTMLDocument');
forwardImplMethod(DOMImplementation, 'hasFeature');
registerWrapper(window.DOMImplementation, DOMImplementation);
forwardMethodsToWrapper([window.DOMImplementation], [
'createDocument',
'createDocumentType',
'createHTMLDocument',
'hasFeature'
]);
scope.adoptNodeNoRemove = adoptNodeNoRemove;
scope.wrappers.DOMImplementation = DOMImplementation;
scope.wrappers.Document = Document;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var EventTarget = scope.wrappers.EventTarget;
var Selection = scope.wrappers.Selection;
var mixin = scope.mixin;
var registerWrapper = scope.registerWrapper;
var renderAllPending = scope.renderAllPending;
var unwrap = scope.unwrap;
var unwrapIfNeeded = scope.unwrapIfNeeded;
var wrap = scope.wrap;
var OriginalWindow = window.Window;
var originalGetComputedStyle = window.getComputedStyle;
var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;
var originalGetSelection = window.getSelection;
function Window(impl) {
EventTarget.call(this, impl);
}
Window.prototype = Object.create(EventTarget.prototype);
OriginalWindow.prototype.getComputedStyle = function (el, pseudo) {
return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);
};
if (originalGetDefaultComputedStyle) {
OriginalWindow.prototype.getDefaultComputedStyle = function (el, pseudo) {
return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);
};
}
OriginalWindow.prototype.getSelection = function () {
return wrap(this || window).getSelection();
};
delete window.getComputedStyle;
delete window.getDefaultComputedStyle;
delete window.getSelection;
[
'addEventListener',
'removeEventListener',
'dispatchEvent'
].forEach(function (name) {
OriginalWindow.prototype[name] = function () {
var w = wrap(this || window);
return w[name].apply(w, arguments);
};
delete window[name];
});
mixin(Window.prototype, {
getComputedStyle: function (el, pseudo) {
renderAllPending();
return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
},
getSelection: function () {
renderAllPending();
return new Selection(originalGetSelection.call(unwrap(this)));
},
get document() {
return wrap(unwrap(this).document);
}
});
if (originalGetDefaultComputedStyle) {
Window.prototype.getDefaultComputedStyle = function (el, pseudo) {
renderAllPending();
return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
};
}
registerWrapper(OriginalWindow, Window, window);
scope.wrappers.Window = Window;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var unwrap = scope.unwrap;
var OriginalDataTransfer = window.DataTransfer || window.Clipboard;
var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;
if (OriginalDataTransferSetDragImage) {
OriginalDataTransfer.prototype.setDragImage = function (image, x, y) {
OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);
};
}
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var registerWrapper = scope.registerWrapper;
var setWrapper = scope.setWrapper;
var unwrap = scope.unwrap;
var OriginalFormData = window.FormData;
if (!OriginalFormData)
return;
function FormData(formElement) {
var impl;
if (formElement instanceof OriginalFormData) {
impl = formElement;
} else {
impl = new OriginalFormData(formElement && unwrap(formElement));
}
setWrapper(impl, this);
}
registerWrapper(OriginalFormData, FormData, new OriginalFormData());
scope.wrappers.FormData = FormData;
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var unwrapIfNeeded = scope.unwrapIfNeeded;
var originalSend = XMLHttpRequest.prototype.send;
XMLHttpRequest.prototype.send = function (obj) {
return originalSend.call(this, unwrapIfNeeded(obj));
};
}(window.ShadowDOMPolyfill));
(function (scope) {
'use strict';
var isWrapperFor = scope.isWrapperFor;
var elements = {
a: 'HTMLAnchorElement',
area: 'HTMLAreaElement',
audio: 'HTMLAudioElement',
base: 'HTMLBaseElement',
body: 'HTMLBodyElement',
br: 'HTMLBRElement',
button: 'HTMLButtonElement',
canvas: 'HTMLCanvasElement',
caption: 'HTMLTableCaptionElement',
col: 'HTMLTableColElement',
content: 'HTMLContentElement',
data: 'HTMLDataElement',
datalist: 'HTMLDataListElement',
del: 'HTMLModElement',
dir: 'HTMLDirectoryElement',
div: 'HTMLDivElement',
dl: 'HTMLDListElement',
embed: 'HTMLEmbedElement',
fieldset: 'HTMLFieldSetElement',
font: 'HTMLFontElement',
form: 'HTMLFormElement',
frame: 'HTMLFrameElement',
frameset: 'HTMLFrameSetElement',
h1: 'HTMLHeadingElement',
head: 'HTMLHeadElement',
hr: 'HTMLHRElement',
html: 'HTMLHtmlElement',
iframe: 'HTMLIFrameElement',
img: 'HTMLImageElement',
input: 'HTMLInputElement',
keygen: 'HTMLKeygenElement',
label: 'HTMLLabelElement',
legend: 'HTMLLegendElement',
li: 'HTMLLIElement',
link: 'HTMLLinkElement',
map: 'HTMLMapElement',
marquee: 'HTMLMarqueeElement',
menu: 'HTMLMenuElement',
menuitem: 'HTMLMenuItemElement',
meta: 'HTMLMetaElement',
meter: 'HTMLMeterElement',
object: 'HTMLObjectElement',
ol: 'HTMLOListElement',
optgroup: 'HTMLOptGroupElement',
option: 'HTMLOptionElement',
output: 'HTMLOutputElement',
p: 'HTMLParagraphElement',
param: 'HTMLParamElement',
pre: 'HTMLPreElement',
progress: 'HTMLProgressElement',
q: 'HTMLQuoteElement',
script: 'HTMLScriptElement',
select: 'HTMLSelectElement',
shadow: 'HTMLShadowElement',
source: 'HTMLSourceElement',
span: 'HTMLSpanElement',
style: 'HTMLStyleElement',
table: 'HTMLTableElement',
tbody: 'HTMLTableSectionElement',
template: 'HTMLTemplateElement',
textarea: 'HTMLTextAreaElement',
thead: 'HTMLTableSectionElement',
time: 'HTMLTimeElement',
title: 'HTMLTitleElement',
tr: 'HTMLTableRowElement',
track: 'HTMLTrackElement',
ul: 'HTMLUListElement',
video: 'HTMLVideoElement'
};
function overrideConstructor(tagName) {
var nativeConstructorName = elements[tagName];
var nativeConstructor = window[nativeConstructorName];
if (!nativeConstructor)
return;
var element = document.createElement(tagName);
var wrapperConstructor = element.constructor;
window[nativeConstructorName] = wrapperConstructor;
}
Object.keys(elements).forEach(overrideConstructor);
Object.getOwnPropertyNames(scope.wrappers).forEach(function (name) {
window[name] = scope.wrappers[name];
});
}(window.ShadowDOMPolyfill));
(function (scope) {
var ShadowCSS = {
strictStyling: false,
registry: {},
shimStyling: function (root, name, extendsName) {
var scopeStyles = this.prepareRoot(root, name, extendsName);
var typeExtension = this.isTypeExtension(extendsName);
var scopeSelector = this.makeScopeSelector(name, typeExtension);
var cssText = stylesToCssText(scopeStyles, true);
cssText = this.scopeCssText(cssText, scopeSelector);
if (root) {
root.shimmedStyle = cssText;
}
this.addCssToDocument(cssText, name);
},
shimStyle: function (style, selector) {
return this.shimCssText(style.textContent, selector);
},
shimCssText: function (cssText, selector) {
cssText = this.insertDirectives(cssText);
return this.scopeCssText(cssText, selector);
},
makeScopeSelector: function (name, typeExtension) {
if (name) {
return typeExtension ? '[is=' + name + ']' : name;
}
return '';
},
isTypeExtension: function (extendsName) {
return extendsName && extendsName.indexOf('-') < 0;
},
prepareRoot: function (root, name, extendsName) {
var def = this.registerRoot(root, name, extendsName);
this.replaceTextInStyles(def.rootStyles, this.insertDirectives);
this.removeStyles(root, def.rootStyles);
if (this.strictStyling) {
this.applyScopeToContent(root, name);
}
return def.scopeStyles;
},
removeStyles: function (root, styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
s.parentNode.removeChild(s);
}
},
registerRoot: function (root, name, extendsName) {
var def = this.registry[name] = {
root: root,
name: name,
extendsName: extendsName
};
var styles = this.findStyles(root);
def.rootStyles = styles;
def.scopeStyles = def.rootStyles;
var extendee = this.registry[def.extendsName];
if (extendee) {
def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);
}
return def;
},
findStyles: function (root) {
if (!root) {
return [];
}
var styles = root.querySelectorAll('style');
return Array.prototype.filter.call(styles, function (s) {
return !s.hasAttribute(NO_SHIM_ATTRIBUTE);
});
},
applyScopeToContent: function (root, name) {
if (root) {
Array.prototype.forEach.call(root.querySelectorAll('*'), function (node) {
node.setAttribute(name, '');
});
Array.prototype.forEach.call(root.querySelectorAll('template'), function (template) {
this.applyScopeToContent(template.content, name);
}, this);
}
},
insertDirectives: function (cssText) {
cssText = this.insertPolyfillDirectivesInCssText(cssText);
return this.insertPolyfillRulesInCssText(cssText);
},
insertPolyfillDirectivesInCssText: function (cssText) {
cssText = cssText.replace(cssCommentNextSelectorRe, function (match, p1) {
return p1.slice(0, -2) + '{';
});
return cssText.replace(cssContentNextSelectorRe, function (match, p1) {
return p1 + ' {';
});
},
insertPolyfillRulesInCssText: function (cssText) {
cssText = cssText.replace(cssCommentRuleRe, function (match, p1) {
return p1.slice(0, -1);
});
return cssText.replace(cssContentRuleRe, function (match, p1, p2, p3) {
var rule = match.replace(p1, '').replace(p2, '');
return p3 + rule;
});
},
scopeCssText: function (cssText, scopeSelector) {
var unscoped = this.extractUnscopedRulesFromCssText(cssText);
cssText = this.insertPolyfillHostInCssText(cssText);
cssText = this.convertColonHost(cssText);
cssText = this.convertColonHostContext(cssText);
cssText = this.convertShadowDOMSelectors(cssText);
if (scopeSelector) {
var self = this, cssText;
withCssRules(cssText, function (rules) {
cssText = self.scopeRules(rules, scopeSelector);
});
}
cssText = cssText + '\n' + unscoped;
return cssText.trim();
},
extractUnscopedRulesFromCssText: function (cssText) {
var r = '', m;
while (m = cssCommentUnscopedRuleRe.exec(cssText)) {
r += m[1].slice(0, -1) + '\n\n';
}
while (m = cssContentUnscopedRuleRe.exec(cssText)) {
r += m[0].replace(m[2], '').replace(m[1], m[3]) + '\n\n';
}
return r;
},
convertColonHost: function (cssText) {
return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);
},
convertColonHostContext: function (cssText) {
return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);
},
convertColonRule: function (cssText, regExp, partReplacer) {
return cssText.replace(regExp, function (m, p1, p2, p3) {
p1 = polyfillHostNoCombinator;
if (p2) {
var parts = p2.split(','), r = [];
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
p = p.trim();
r.push(partReplacer(p1, p, p3));
}
return r.join(',');
} else {
return p1 + p3;
}
});
},
colonHostContextPartReplacer: function (host, part, suffix) {
if (part.match(polyfillHost)) {
return this.colonHostPartReplacer(host, part, suffix);
} else {
return host + part + suffix + ', ' + part + ' ' + host + suffix;
}
},
colonHostPartReplacer: function (host, part, suffix) {
return host + part.replace(polyfillHost, '') + suffix;
},
convertShadowDOMSelectors: function (cssText) {
for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {
cssText = cssText.replace(shadowDOMSelectorsRe[i], ' ');
}
return cssText;
},
scopeRules: function (cssRules, scopeSelector) {
var cssText = '';
if (cssRules) {
Array.prototype.forEach.call(cssRules, function (rule) {
if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {
cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + ' {\n\t';
cssText += this.propertiesFromRule(rule) + '\n}\n\n';
} else if (rule.type === CSSRule.MEDIA_RULE) {
cssText += '@media ' + rule.media.mediaText + ' {\n';
cssText += this.scopeRules(rule.cssRules, scopeSelector);
cssText += '\n}\n\n';
} else {
try {
if (rule.cssText) {
cssText += rule.cssText + '\n\n';
}
} catch (x) {
if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {
cssText += this.ieSafeCssTextFromKeyFrameRule(rule);
}
}
}
}, this);
}
return cssText;
},
ieSafeCssTextFromKeyFrameRule: function (rule) {
var cssText = '@keyframes ' + rule.name + ' {';
Array.prototype.forEach.call(rule.cssRules, function (rule) {
cssText += ' ' + rule.keyText + ' {' + rule.style.cssText + '}';
});
cssText += ' }';
return cssText;
},
scopeSelector: function (selector, scopeSelector, strict) {
var r = [], parts = selector.split(',');
parts.forEach(function (p) {
p = p.trim();
if (this.selectorNeedsScoping(p, scopeSelector)) {
p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);
}
r.push(p);
}, this);
return r.join(', ');
},
selectorNeedsScoping: function (selector, scopeSelector) {
if (Array.isArray(scopeSelector)) {
return true;
}
var re = this.makeScopeMatcher(scopeSelector);
return !selector.match(re);
},
makeScopeMatcher: function (scopeSelector) {
scopeSelector = scopeSelector.replace(/\[/g, '\\[').replace(/\]/g, '\\]');
return new RegExp('^(' + scopeSelector + ')' + selectorReSuffix, 'm');
},
applySelectorScope: function (selector, selectorScope) {
return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);
},
applySelectorScopeList: function (selector, scopeSelectorList) {
var r = [];
for (var i = 0, s; s = scopeSelectorList[i]; i++) {
r.push(this.applySimpleSelectorScope(selector, s));
}
return r.join(', ');
},
applySimpleSelectorScope: function (selector, scopeSelector) {
if (selector.match(polyfillHostRe)) {
selector = selector.replace(polyfillHostNoCombinator, scopeSelector);
return selector.replace(polyfillHostRe, scopeSelector + ' ');
} else {
return scopeSelector + ' ' + selector;
}
},
applyStrictSelectorScope: function (selector, scopeSelector) {
scopeSelector = scopeSelector.replace(/\[is=([^\]]*)\]/g, '$1');
var splits = [
' ',
'>',
'+',
'~'
], scoped = selector, attrName = '[' + scopeSelector + ']';
splits.forEach(function (sep) {
var parts = scoped.split(sep);
scoped = parts.map(function (p) {
var t = p.trim().replace(polyfillHostRe, '');
if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {
p = t.replace(/([^:]*)(:*)(.*)/, '$1' + attrName + '$2$3');
}
return p;
}).join(sep);
});
return scoped;
},
insertPolyfillHostInCssText: function (selector) {
return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);
},
propertiesFromRule: function (rule) {
var cssText = rule.style.cssText;
if (rule.style.content && !rule.style.content.match(/['"]+|attr/)) {
cssText = cssText.replace(/content:[^;]*;/g, 'content: \'' + rule.style.content + '\';');
}
var style = rule.style;
for (var i in style) {
if (style[i] === 'initial') {
cssText += i + ': initial; ';
}
}
return cssText;
},
replaceTextInStyles: function (styles, action) {
if (styles && action) {
if (!(styles instanceof Array)) {
styles = [styles];
}
Array.prototype.forEach.call(styles, function (s) {
s.textContent = action.call(this, s.textContent);
}, this);
}
},
addCssToDocument: function (cssText, name) {
if (cssText.match('@import')) {
addOwnSheet(cssText, name);
} else {
addCssToDocument(cssText);
}
}
};
var selectorRe = /([^{]*)({[\s\S]*?})/gim, cssCommentRe = /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim, cssCommentNextSelectorRe = /\/\*\s*@polyfill ([^*]*\*+([^\/*][^*]*\*+)*\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim, cssCommentRuleRe = /\/\*\s@polyfill-rule([^*]*\*+([^\/*][^*]*\*+)*)\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\/\*\s@polyfill-unscoped-rule([^*]*\*+([^\/*][^*]*\*+)*)\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\s{,(]*)/gim, cssPartRe = /::part\(([^)]*)\)/gim, polyfillHost = '-shadowcsshost', polyfillHostContext = '-shadowcsscontext', parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
var cssColonHostRe = new RegExp('(' + polyfillHost + parenSuffix, 'gim'), cssColonHostContextRe = new RegExp('(' + polyfillHostContext + parenSuffix, 'gim'), selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$', colonHostRe = /\:host/gim, colonHostContextRe = /\:host-context/gim, polyfillHostNoCombinator = polyfillHost + '-no-combinator', polyfillHostRe = new RegExp(polyfillHost, 'gim'), polyfillHostContextRe = new RegExp(polyfillHostContext, 'gim'), shadowDOMSelectorsRe = [
/>>>/g,
/::shadow/g,
/::content/g,
/\/deep\//g,
/\/shadow\//g,
/\/shadow-deep\//g,
/\^\^/g,
/\^(?!=)/g
];
function stylesToCssText(styles, preserveComments) {
var cssText = '';
Array.prototype.forEach.call(styles, function (s) {
cssText += s.textContent + '\n\n';
});
if (!preserveComments) {
cssText = cssText.replace(cssCommentRe, '');
}
return cssText;
}
function cssTextToStyle(cssText) {
var style = document.createElement('style');
style.textContent = cssText;
return style;
}
function cssToRules(cssText) {
var style = cssTextToStyle(cssText);
document.head.appendChild(style);
var rules = [];
if (style.sheet) {
try {
rules = style.sheet.cssRules;
} catch (e) {
}
} else {
console.warn('sheet not found', style);
}
style.parentNode.removeChild(style);
return rules;
}
var frame = document.createElement('iframe');
frame.style.display = 'none';
function initFrame() {
frame.initialized = true;
document.body.appendChild(frame);
var doc = frame.contentDocument;
var base = doc.createElement('base');
base.href = document.baseURI;
doc.head.appendChild(base);
}
function inFrame(fn) {
if (!frame.initialized) {
initFrame();
}
document.body.appendChild(frame);
fn(frame.contentDocument);
document.body.removeChild(frame);
}
var isChrome = navigator.userAgent.match('Chrome');
function withCssRules(cssText, callback) {
if (!callback) {
return;
}
var rules;
if (cssText.match('@import') && isChrome) {
var style = cssTextToStyle(cssText);
inFrame(function (doc) {
doc.head.appendChild(style.impl);
rules = Array.prototype.slice.call(style.sheet.cssRules, 0);
callback(rules);
});
} else {
rules = cssToRules(cssText);
callback(rules);
}
}
function rulesToCss(cssRules) {
for (var i = 0, css = []; i < cssRules.length; i++) {
css.push(cssRules[i].cssText);
}
return css.join('\n\n');
}
function addCssToDocument(cssText) {
if (cssText) {
getSheet().appendChild(document.createTextNode(cssText));
}
}
function addOwnSheet(cssText, name) {
var style = cssTextToStyle(cssText);
style.setAttribute(name, '');
style.setAttribute(SHIMMED_ATTRIBUTE, '');
document.head.appendChild(style);
}
var SHIM_ATTRIBUTE = 'shim-shadowdom';
var SHIMMED_ATTRIBUTE = 'shim-shadowdom-css';
var NO_SHIM_ATTRIBUTE = 'no-shim';
var sheet;
function getSheet() {
if (!sheet) {
sheet = document.createElement('style');
sheet.setAttribute(SHIMMED_ATTRIBUTE, '');
sheet[SHIMMED_ATTRIBUTE] = true;
}
return sheet;
}
if (window.ShadowDOMPolyfill) {
addCssToDocument('style { display: none !important; }\n');
var doc = ShadowDOMPolyfill.wrap(document);
var head = doc.querySelector('head');
head.insertBefore(getSheet(), head.childNodes[0]);
document.addEventListener('DOMContentLoaded', function () {
var urlResolver = scope.urlResolver;
if (window.HTMLImports && !HTMLImports.useNative) {
var SHIM_SHEET_SELECTOR = 'link[rel=stylesheet]' + '[' + SHIM_ATTRIBUTE + ']';
var SHIM_STYLE_SELECTOR = 'style[' + SHIM_ATTRIBUTE + ']';
HTMLImports.importer.documentPreloadSelectors += ',' + SHIM_SHEET_SELECTOR;
HTMLImports.importer.importsPreloadSelectors += ',' + SHIM_SHEET_SELECTOR;
HTMLImports.parser.documentSelectors = [
HTMLImports.parser.documentSelectors,
SHIM_SHEET_SELECTOR,
SHIM_STYLE_SELECTOR
].join(',');
var originalParseGeneric = HTMLImports.parser.parseGeneric;
HTMLImports.parser.parseGeneric = function (elt) {
if (elt[SHIMMED_ATTRIBUTE]) {
return;
}
var style = elt.__importElement || elt;
if (!style.hasAttribute(SHIM_ATTRIBUTE)) {
originalParseGeneric.call(this, elt);
return;
}
if (elt.__resource) {
style = elt.ownerDocument.createElement('style');
style.textContent = elt.__resource;
}
HTMLImports.path.resolveUrlsInStyle(style, elt.href);
style.textContent = ShadowCSS.shimStyle(style);
style.removeAttribute(SHIM_ATTRIBUTE, '');
style.setAttribute(SHIMMED_ATTRIBUTE, '');
style[SHIMMED_ATTRIBUTE] = true;
if (style.parentNode !== head) {
if (elt.parentNode === head) {
head.replaceChild(style, elt);
} else {
this.addElementToDocument(style);
}
}
style.__importParsed = true;
this.markParsingComplete(elt);
this.parseNext();
};
var hasResource = HTMLImports.parser.hasResource;
HTMLImports.parser.hasResource = function (node) {
if (node.localName === 'link' && node.rel === 'stylesheet' && node.hasAttribute(SHIM_ATTRIBUTE)) {
return node.__resource;
} else {
return hasResource.call(this, node);
}
};
}
});
}
scope.ShadowCSS = ShadowCSS;
}(window.WebComponents));
}
(function (scope) {
if (window.ShadowDOMPolyfill) {
window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
} else {
window.wrap = window.unwrap = function (n) {
return n;
};
}
}(window.WebComponents));
(function (scope) {
'use strict';
var hasWorkingUrl = false;
if (!scope.forceJURL) {
try {
var u = new URL('b', 'http://a');
u.pathname = 'c%20d';
hasWorkingUrl = u.href === 'http://a/c%20d';
} catch (e) {
}
}
if (hasWorkingUrl)
return;
var relative = Object.create(null);
relative['ftp'] = 21;
relative['file'] = 0;
relative['gopher'] = 70;
relative['http'] = 80;
relative['https'] = 443;
relative['ws'] = 80;
relative['wss'] = 443;
var relativePathDotMapping = Object.create(null);
relativePathDotMapping['%2e'] = '.';
relativePathDotMapping['.%2e'] = '..';
relativePathDotMapping['%2e.'] = '..';
relativePathDotMapping['%2e%2e'] = '..';
function isRelativeScheme(scheme) {
return relative[scheme] !== undefined;
}
function invalid() {
clear.call(this);
this._isInvalid = true;
}
function IDNAToASCII(h) {
if ('' == h) {
invalid.call(this);
}
return h.toLowerCase();
}
function percentEscape(c) {
var unicode = c.charCodeAt(0);
if (unicode > 32 && unicode < 127 && [
34,
35,
60,
62,
63,
96
].indexOf(unicode) == -1) {
return c;
}
return encodeURIComponent(c);
}
function percentEscapeQuery(c) {
var unicode = c.charCodeAt(0);
if (unicode > 32 && unicode < 127 && [
34,
35,
60,
62,
96
].indexOf(unicode) == -1) {
return c;
}
return encodeURIComponent(c);
}
var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
function parse(input, stateOverride, base) {
function err(message) {
errors.push(message);
}
var state = stateOverride || 'scheme start', cursor = 0, buffer = '', seenAt = false, seenBracket = false, errors = [];
loop:
while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
var c = input[cursor];
switch (state) {
case 'scheme start':
if (c && ALPHA.test(c)) {
buffer += c.toLowerCase();
state = 'scheme';
} else if (!stateOverride) {
buffer = '';
state = 'no scheme';
continue;
} else {
err('Invalid scheme.');
break loop;
}
break;
case 'scheme':
if (c && ALPHANUMERIC.test(c)) {
buffer += c.toLowerCase();
} else if (':' == c) {
this._scheme = buffer;
buffer = '';
if (stateOverride) {
break loop;
}
if (isRelativeScheme(this._scheme)) {
this._isRelative = true;
}
if ('file' == this._scheme) {
state = 'relative';
} else if (this._isRelative && base && base._scheme == this._scheme) {
state = 'relative or authority';
} else if (this._isRelative) {
state = 'authority first slash';
} else {
state = 'scheme data';
}
} else if (!stateOverride) {
buffer = '';
cursor = 0;
state = 'no scheme';
continue;
} else if (EOF == c) {
break loop;
} else {
err('Code point not allowed in scheme: ' + c);
break loop;
}
break;
case 'scheme data':
if ('?' == c) {
this._query = '?';
state = 'query';
} else if ('#' == c) {
this._fragment = '#';
state = 'fragment';
} else {
if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
this._schemeData += percentEscape(c);
}
}
break;
case 'no scheme':
if (!base || !isRelativeScheme(base._scheme)) {
err('Missing scheme.');
invalid.call(this);
} else {
state = 'relative';
continue;
}
break;
case 'relative or authority':
if ('/' == c && '/' == input[cursor + 1]) {
state = 'authority ignore slashes';
} else {
err('Expected /, got: ' + c);
state = 'relative';
continue;
}
break;
case 'relative':
this._isRelative = true;
if ('file' != this._scheme)
this._scheme = base._scheme;
if (EOF == c) {
this._host = base._host;
this._port = base._port;
this._path = base._path.slice();
this._query = base._query;
this._username = base._username;
this._password = base._password;
break loop;
} else if ('/' == c || '\\' == c) {
if ('\\' == c)
err('\\ is an invalid code point.');
state = 'relative slash';
} else if ('?' == c) {
this._host = base._host;
this._port = base._port;
this._path = base._path.slice();
this._query = '?';
this._username = base._username;
this._password = base._password;
state = 'query';
} else if ('#' == c) {
this._host = base._host;
this._port = base._port;
this._path = base._path.slice();
this._query = base._query;
this._fragment = '#';
this._username = base._username;
this._password = base._password;
state = 'fragment';
} else {
var nextC = input[cursor + 1];
var nextNextC = input[cursor + 2];
if ('file' != this._scheme || !ALPHA.test(c) || nextC != ':' && nextC != '|' || EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC) {
this._host = base._host;
this._port = base._port;
this._username = base._username;
this._password = base._password;
this._path = base._path.slice();
this._path.pop();
}
state = 'relative path';
continue;
}
break;
case 'relative slash':
if ('/' == c || '\\' == c) {
if ('\\' == c) {
err('\\ is an invalid code point.');
}
if ('file' == this._scheme) {
state = 'file host';
} else {
state = 'authority ignore slashes';
}
} else {
if ('file' != this._scheme) {
this._host = base._host;
this._port = base._port;
this._username = base._username;
this._password = base._password;
}
state = 'relative path';
continue;
}
break;
case 'authority first slash':
if ('/' == c) {
state = 'authority second slash';
} else {
err('Expected \'/\', got: ' + c);
state = 'authority ignore slashes';
continue;
}
break;
case 'authority second slash':
state = 'authority ignore slashes';
if ('/' != c) {
err('Expected \'/\', got: ' + c);
continue;
}
break;
case 'authority ignore slashes':
if ('/' != c && '\\' != c) {
state = 'authority';
continue;
} else {
err('Expected authority, got: ' + c);
}
break;
case 'authority':
if ('@' == c) {
if (seenAt) {
err('@ already seen.');
buffer += '%40';
}
seenAt = true;
for (var i = 0; i < buffer.length; i++) {
var cp = buffer[i];
if ('\t' == cp || '\n' == cp || '\r' == cp) {
err('Invalid whitespace in authority.');
continue;
}
if (':' == cp && null === this._password) {
this._password = '';
continue;
}
var tempC = percentEscape(cp);
null !== this._password ? this._password += tempC : this._username += tempC;
}
buffer = '';
} else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
cursor -= buffer.length;
buffer = '';
state = 'host';
continue;
} else {
buffer += c;
}
break;
case 'file host':
if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
state = 'relative path';
} else if (buffer.length == 0) {
state = 'relative path start';
} else {
this._host = IDNAToASCII.call(this, buffer);
buffer = '';
state = 'relative path start';
}
continue;
} else if ('\t' == c || '\n' == c || '\r' == c) {
err('Invalid whitespace in file host.');
} else {
buffer += c;
}
break;
case 'host':
case 'hostname':
if (':' == c && !seenBracket) {
this._host = IDNAToASCII.call(this, buffer);
buffer = '';
state = 'port';
if ('hostname' == stateOverride) {
break loop;
}
} else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
this._host = IDNAToASCII.call(this, buffer);
buffer = '';
state = 'relative path start';
if (stateOverride) {
break loop;
}
continue;
} else if ('\t' != c && '\n' != c && '\r' != c) {
if ('[' == c) {
seenBracket = true;
} else if (']' == c) {
seenBracket = false;
}
buffer += c;
} else {
err('Invalid code point in host/hostname: ' + c);
}
break;
case 'port':
if (/[0-9]/.test(c)) {
buffer += c;
} else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
if ('' != buffer) {
var temp = parseInt(buffer, 10);
if (temp != relative[this._scheme]) {
this._port = temp + '';
}
buffer = '';
}
if (stateOverride) {
break loop;
}
state = 'relative path start';
continue;
} else if ('\t' == c || '\n' == c || '\r' == c) {
err('Invalid code point in port: ' + c);
} else {
invalid.call(this);
}
break;
case 'relative path start':
if ('\\' == c)
err('\'\\\' not allowed in path.');
state = 'relative path';
if ('/' != c && '\\' != c) {
continue;
}
break;
case 'relative path':
if (EOF == c || '/' == c || '\\' == c || !stateOverride && ('?' == c || '#' == c)) {
if ('\\' == c) {
err('\\ not allowed in relative path.');
}
var tmp;
if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
buffer = tmp;
}
if ('..' == buffer) {
this._path.pop();
if ('/' != c && '\\' != c) {
this._path.push('');
}
} else if ('.' == buffer && '/' != c && '\\' != c) {
this._path.push('');
} else if ('.' != buffer) {
if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
buffer = buffer[0] + ':';
}
this._path.push(buffer);
}
buffer = '';
if ('?' == c) {
this._query = '?';
state = 'query';
} else if ('#' == c) {
this._fragment = '#';
state = 'fragment';
}
} else if ('\t' != c && '\n' != c && '\r' != c) {
buffer += percentEscape(c);
}
break;
case 'query':
if (!stateOverride && '#' == c) {
this._fragment = '#';
state = 'fragment';
} else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
this._query += percentEscapeQuery(c);
}
break;
case 'fragment':
if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
this._fragment += c;
}
break;
}
cursor++;
}
}
function clear() {
this._scheme = '';
this._schemeData = '';
this._username = '';
this._password = null;
this._host = '';
this._port = '';
this._path = [];
this._query = '';
this._fragment = '';
this._isInvalid = false;
this._isRelative = false;
}
function jURL(url, base) {
if (base !== undefined && !(base instanceof jURL))
base = new jURL(String(base));
this._url = url;
clear.call(this);
var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
parse.call(this, input, null, base);
}
jURL.prototype = {
toString: function () {
return this.href;
},
get href() {
if (this._isInvalid)
return this._url;
var authority = '';
if ('' != this._username || null != this._password) {
authority = this._username + (null != this._password ? ':' + this._password : '') + '@';
}
return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;
},
set href(href) {
clear.call(this);
parse.call(this, href);
},
get protocol() {
return this._scheme + ':';
},
set protocol(protocol) {
if (this._isInvalid)
return;
parse.call(this, protocol + ':', 'scheme start');
},
get host() {
return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
},
set host(host) {
if (this._isInvalid || !this._isRelative)
return;
parse.call(this, host, 'host');
},
get hostname() {
return this._host;
},
set hostname(hostname) {
if (this._isInvalid || !this._isRelative)
return;
parse.call(this, hostname, 'hostname');
},
get port() {
return this._port;
},
set port(port) {
if (this._isInvalid || !this._isRelative)
return;
parse.call(this, port, 'port');
},
get pathname() {
return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
},
set pathname(pathname) {
if (this._isInvalid || !this._isRelative)
return;
this._path = [];
parse.call(this, pathname, 'relative path start');
},
get search() {
return this._isInvalid || !this._query || '?' == this._query ? '' : this._query;
},
set search(search) {
if (this._isInvalid || !this._isRelative)
return;
this._query = '?';
if ('?' == search[0])
search = search.slice(1);
parse.call(this, search, 'query');
},
get hash() {
return this._isInvalid || !this._fragment || '#' == this._fragment ? '' : this._fragment;
},
set hash(hash) {
if (this._isInvalid)
return;
this._fragment = '#';
if ('#' == hash[0])
hash = hash.slice(1);
parse.call(this, hash, 'fragment');
},
get origin() {
var host;
if (this._isInvalid || !this._scheme) {
return '';
}
switch (this._scheme) {
case 'data':
case 'file':
case 'javascript':
case 'mailto':
return 'null';
}
host = this.host;
if (!host) {
return '';
}
return this._scheme + '://' + host;
}
};
var OriginalURL = scope.URL;
if (OriginalURL) {
jURL.createObjectURL = function (blob) {
return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
};
jURL.revokeObjectURL = function (url) {
OriginalURL.revokeObjectURL(url);
};
}
scope.URL = jURL;
}(self));
(function (global) {
if (global.JsMutationObserver) {
return;
}
var registrationsTable = new WeakMap();
var setImmediate;
if (/Trident|Edge/.test(navigator.userAgent)) {
setImmediate = setTimeout;
} else if (window.setImmediate) {
setImmediate = window.setImmediate;
} else {
var setImmediateQueue = [];
var sentinel = String(Math.random());
window.addEventListener('message', function (e) {
if (e.data === sentinel) {
var queue = setImmediateQueue;
setImmediateQueue = [];
queue.forEach(function (func) {
func();
});
}
});
setImmediate = function (func) {
setImmediateQueue.push(func);
window.postMessage(sentinel, '*');
};
}
var isScheduled = false;
var scheduledObservers = [];
function scheduleCallback(observer) {
scheduledObservers.push(observer);
if (!isScheduled) {
isScheduled = true;
setImmediate(dispatchCallbacks);
}
}
function wrapIfNeeded(node) {
return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
}
function dispatchCallbacks() {
isScheduled = false;
var observers = scheduledObservers;
scheduledObservers = [];
observers.sort(function (o1, o2) {
return o1.uid_ - o2.uid_;
});
var anyNonEmpty = false;
observers.forEach(function (observer) {
var queue = observer.takeRecords();
removeTransientObserversFor(observer);
if (queue.length) {
observer.callback_(queue, observer);
anyNonEmpty = true;
}
});
if (anyNonEmpty)
dispatchCallbacks();
}
function removeTransientObserversFor(observer) {
observer.nodes_.forEach(function (node) {
var registrations = registrationsTable.get(node);
if (!registrations)
return;
registrations.forEach(function (registration) {
if (registration.observer === observer)
registration.removeTransientObservers();
});
});
}
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
for (var node = target; node; node = node.parentNode) {
var registrations = registrationsTable.get(node);
if (registrations) {
for (var j = 0; j < registrations.length; j++) {
var registration = registrations[j];
var options = registration.options;
if (node !== target && !options.subtree)
continue;
var record = callback(options);
if (record)
registration.enqueue(record);
}
}
}
}
var uidCounter = 0;
function JsMutationObserver(callback) {
this.callback_ = callback;
this.nodes_ = [];
this.records_ = [];
this.uid_ = ++uidCounter;
}
JsMutationObserver.prototype = {
observe: function (target, options) {
target = wrapIfNeeded(target);
if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
throw new SyntaxError();
}
var registrations = registrationsTable.get(target);
if (!registrations)
registrationsTable.set(target, registrations = []);
var registration;
for (var i = 0; i < registrations.length; i++) {
if (registrations[i].observer === this) {
registration = registrations[i];
registration.removeListeners();
registration.options = options;
break;
}
}
if (!registration) {
registration = new Registration(this, target, options);
registrations.push(registration);
this.nodes_.push(target);
}
registration.addListeners();
},
disconnect: function () {
this.nodes_.forEach(function (node) {
var registrations = registrationsTable.get(node);
for (var i = 0; i < registrations.length; i++) {
var registration = registrations[i];
if (registration.observer === this) {
registration.removeListeners();
registrations.splice(i, 1);
break;
}
}
}, this);
this.records_ = [];
},
takeRecords: function () {
var copyOfRecords = this.records_;
this.records_ = [];
return copyOfRecords;
}
};
function MutationRecord(type, target) {
this.type = type;
this.target = target;
this.addedNodes = [];
this.removedNodes = [];
this.previousSibling = null;
this.nextSibling = null;
this.attributeName = null;
this.attributeNamespace = null;
this.oldValue = null;
}
function copyMutationRecord(original) {
var record = new MutationRecord(original.type, original.target);
record.addedNodes = original.addedNodes.slice();
record.removedNodes = original.removedNodes.slice();
record.previousSibling = original.previousSibling;
record.nextSibling = original.nextSibling;
record.attributeName = original.attributeName;
record.attributeNamespace = original.attributeNamespace;
record.oldValue = original.oldValue;
return record;
}
var currentRecord, recordWithOldValue;
function getRecord(type, target) {
return currentRecord = new MutationRecord(type, target);
}
function getRecordWithOldValue(oldValue) {
if (recordWithOldValue)
return recordWithOldValue;
recordWithOldValue = copyMutationRecord(currentRecord);
recordWithOldValue.oldValue = oldValue;
return recordWithOldValue;
}
function clearRecords() {
currentRecord = recordWithOldValue = undefined;
}
function recordRepresentsCurrentMutation(record) {
return record === recordWithOldValue || record === currentRecord;
}
function selectRecord(lastRecord, newRecord) {
if (lastRecord === newRecord)
return lastRecord;
if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
return recordWithOldValue;
return null;
}
function Registration(observer, target, options) {
this.observer = observer;
this.target = target;
this.options = options;
this.transientObservedNodes = [];
}
Registration.prototype = {
enqueue: function (record) {
var records = this.observer.records_;
var length = records.length;
if (records.length > 0) {
var lastRecord = records[length - 1];
var recordToReplaceLast = selectRecord(lastRecord, record);
if (recordToReplaceLast) {
records[length - 1] = recordToReplaceLast;
return;
}
} else {
scheduleCallback(this.observer);
}
records[length] = record;
},
addListeners: function () {
this.addListeners_(this.target);
},
addListeners_: function (node) {
var options = this.options;
if (options.attributes)
node.addEventListener('DOMAttrModified', this, true);
if (options.characterData)
node.addEventListener('DOMCharacterDataModified', this, true);
if (options.childList)
node.addEventListener('DOMNodeInserted', this, true);
if (options.childList || options.subtree)
node.addEventListener('DOMNodeRemoved', this, true);
},
removeListeners: function () {
this.removeListeners_(this.target);
},
removeListeners_: function (node) {
var options = this.options;
if (options.attributes)
node.removeEventListener('DOMAttrModified', this, true);
if (options.characterData)
node.removeEventListener('DOMCharacterDataModified', this, true);
if (options.childList)
node.removeEventListener('DOMNodeInserted', this, true);
if (options.childList || options.subtree)
node.removeEventListener('DOMNodeRemoved', this, true);
},
addTransientObserver: function (node) {
if (node === this.target)
return;
this.addListeners_(node);
this.transientObservedNodes.push(node);
var registrations = registrationsTable.get(node);
if (!registrations)
registrationsTable.set(node, registrations = []);
registrations.push(this);
},
removeTransientObservers: function () {
var transientObservedNodes = this.transientObservedNodes;
this.transientObservedNodes = [];
transientObservedNodes.forEach(function (node) {
this.removeListeners_(node);
var registrations = registrationsTable.get(node);
for (var i = 0; i < registrations.length; i++) {
if (registrations[i] === this) {
registrations.splice(i, 1);
break;
}
}
}, this);
},
handleEvent: function (e) {
e.stopImmediatePropagation();
switch (e.type) {
case 'DOMAttrModified':
var name = e.attrName;
var namespace = e.relatedNode.namespaceURI;
var target = e.target;
var record = new getRecord('attributes', target);
record.attributeName = name;
record.attributeNamespace = namespace;
var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
forEachAncestorAndObserverEnqueueRecord(target, function (options) {
if (!options.attributes)
return;
if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
return;
}
if (options.attributeOldValue)
return getRecordWithOldValue(oldValue);
return record;
});
break;
case 'DOMCharacterDataModified':
var target = e.target;
var record = getRecord('characterData', target);
var oldValue = e.prevValue;
forEachAncestorAndObserverEnqueueRecord(target, function (options) {
if (!options.characterData)
return;
if (options.characterDataOldValue)
return getRecordWithOldValue(oldValue);
return record;
});
break;
case 'DOMNodeRemoved':
this.addTransientObserver(e.target);
case 'DOMNodeInserted':
var changedNode = e.target;
var addedNodes, removedNodes;
if (e.type === 'DOMNodeInserted') {
addedNodes = [changedNode];
removedNodes = [];
} else {
addedNodes = [];
removedNodes = [changedNode];
}
var previousSibling = changedNode.previousSibling;
var nextSibling = changedNode.nextSibling;
var record = getRecord('childList', e.target.parentNode);
record.addedNodes = addedNodes;
record.removedNodes = removedNodes;
record.previousSibling = previousSibling;
record.nextSibling = nextSibling;
forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
if (!options.childList)
return;
return record;
});
}
clearRecords();
}
};
global.JsMutationObserver = JsMutationObserver;
if (!global.MutationObserver) {
global.MutationObserver = JsMutationObserver;
JsMutationObserver._isPolyfilled = true;
}
}(self));
(function (scope) {
'use strict';
if (!(window.performance && window.performance.now)) {
var start = Date.now();
window.performance = {
now: function () {
return Date.now() - start;
}
};
}
if (!window.requestAnimationFrame) {
window.requestAnimationFrame = function () {
var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
return nativeRaf ? function (callback) {
return nativeRaf(function () {
callback(performance.now());
});
} : function (callback) {
return window.setTimeout(callback, 1000 / 60);
};
}();
}
if (!window.cancelAnimationFrame) {
window.cancelAnimationFrame = function () {
return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) {
clearTimeout(id);
};
}();
}
var workingDefaultPrevented = function () {
var e = document.createEvent('Event');
e.initEvent('foo', true, true);
e.preventDefault();
return e.defaultPrevented;
}();
if (!workingDefaultPrevented) {
var origPreventDefault = Event.prototype.preventDefault;
Event.prototype.preventDefault = function () {
if (!this.cancelable) {
return;
}
origPreventDefault.call(this);
Object.defineProperty(this, 'defaultPrevented', {
get: function () {
return true;
},
configurable: true
});
};
}
var isIE = /Trident/.test(navigator.userAgent);
if (!window.CustomEvent || isIE && typeof window.CustomEvent !== 'function') {
window.CustomEvent = function (inType, params) {
params = params || {};
var e = document.createEvent('CustomEvent');
e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
return e;
};
window.CustomEvent.prototype = window.Event.prototype;
}
if (!window.Event || isIE && typeof window.Event !== 'function') {
var origEvent = window.Event;
window.Event = function (inType, params) {
params = params || {};
var e = document.createEvent('Event');
e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
return e;
};
window.Event.prototype = origEvent.prototype;
}
}(window.WebComponents));
window.HTMLImports = window.HTMLImports || { flags: {} };
(function (scope) {
var IMPORT_LINK_TYPE = 'import';
var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));
var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
var wrap = function (node) {
return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
};
var rootDocument = wrap(document);
var currentScriptDescriptor = {
get: function () {
var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== 'complete' ? document.scripts[document.scripts.length - 1] : null);
return wrap(script);
},
configurable: true
};
Object.defineProperty(document, '_currentScript', currentScriptDescriptor);
Object.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);
var isIE = /Trident/.test(navigator.userAgent);
function whenReady(callback, doc) {
doc = doc || rootDocument;
whenDocumentReady(function () {
watchImportsLoad(callback, doc);
}, doc);
}
var requiredReadyState = isIE ? 'complete' : 'interactive';
var READY_EVENT = 'readystatechange';
function isDocumentReady(doc) {
return doc.readyState === 'complete' || doc.readyState === requiredReadyState;
}
function whenDocumentReady(callback, doc) {
if (!isDocumentReady(doc)) {
var checkReady = function () {
if (doc.readyState === 'complete' || doc.readyState === requiredReadyState) {
doc.removeEventListener(READY_EVENT, checkReady);
whenDocumentReady(callback, doc);
}
};
doc.addEventListener(READY_EVENT, checkReady);
} else if (callback) {
callback();
}
}
function markTargetLoaded(event) {
event.target.__loaded = true;
}
function watchImportsLoad(callback, doc) {
var imports = doc.querySelectorAll('link[rel=import]');
var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
function checkDone() {
if (parsedCount == importCount && callback) {
callback({
allImports: imports,
loadedImports: newImports,
errorImports: errorImports
});
}
}
function loadedImport(e) {
markTargetLoaded(e);
newImports.push(this);
parsedCount++;
checkDone();
}
function errorLoadingImport(e) {
errorImports.push(this);
parsedCount++;
checkDone();
}
if (importCount) {
for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {
if (isImportLoaded(imp)) {
newImports.push(this);
parsedCount++;
checkDone();
} else {
imp.addEventListener('load', loadedImport);
imp.addEventListener('error', errorLoadingImport);
}
}
} else {
checkDone();
}
}
function isImportLoaded(link) {
return useNative ? link.__loaded || link.import && link.import.readyState !== 'loading' : link.__importParsed;
}
if (useNative) {
new MutationObserver(function (mxns) {
for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
if (m.addedNodes) {
handleImports(m.addedNodes);
}
}
}).observe(document.head, { childList: true });
function handleImports(nodes) {
for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
if (isImport(n)) {
handleImport(n);
}
}
}
function isImport(element) {
return element.localName === 'link' && element.rel === 'import';
}
function handleImport(element) {
var loaded = element.import;
if (loaded) {
markTargetLoaded({ target: element });
} else {
element.addEventListener('load', markTargetLoaded);
element.addEventListener('error', markTargetLoaded);
}
}
(function () {
if (document.readyState === 'loading') {
var imports = document.querySelectorAll('link[rel=import]');
for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
handleImport(imp);
}
}
}());
}
whenReady(function (detail) {
window.HTMLImports.ready = true;
window.HTMLImports.readyTime = new Date().getTime();
var evt = rootDocument.createEvent('CustomEvent');
evt.initCustomEvent('HTMLImportsLoaded', true, true, detail);
rootDocument.dispatchEvent(evt);
});
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
scope.useNative = useNative;
scope.rootDocument = rootDocument;
scope.whenReady = whenReady;
scope.isIE = isIE;
}(window.HTMLImports));
(function (scope) {
var modules = [];
var addModule = function (module) {
modules.push(module);
};
var initializeModules = function () {
modules.forEach(function (module) {
module(scope);
});
};
scope.addModule = addModule;
scope.initializeModules = initializeModules;
}(window.HTMLImports));
window.HTMLImports.addModule(function (scope) {
var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
var path = {
resolveUrlsInStyle: function (style, linkUrl) {
var doc = style.ownerDocument;
var resolver = doc.createElement('a');
style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
return style;
},
resolveUrlsInCssText: function (cssText, linkUrl, urlObj) {
var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
return r;
},
replaceUrls: function (text, urlObj, linkUrl, regexp) {
return text.replace(regexp, function (m, pre, url, post) {
var urlPath = url.replace(/["']/g, '');
if (linkUrl) {
urlPath = new URL(urlPath, linkUrl).href;
}
urlObj.href = urlPath;
urlPath = urlObj.href;
return pre + '\'' + urlPath + '\'' + post;
});
}
};
scope.path = path;
});
window.HTMLImports.addModule(function (scope) {
var xhr = {
async: true,
ok: function (request) {
return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
},
load: function (url, next, nextContext) {
var request = new XMLHttpRequest();
if (scope.flags.debug || scope.flags.bust) {
url += '?' + Math.random();
}
request.open('GET', url, xhr.async);
request.addEventListener('readystatechange', function (e) {
if (request.readyState === 4) {
var redirectedUrl = null;
try {
var locationHeader = request.getResponseHeader('Location');
if (locationHeader) {
redirectedUrl = locationHeader.substr(0, 1) === '/' ? location.origin + locationHeader : locationHeader;
}
} catch (e) {
console.error(e.message);
}
next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
}
});
request.send();
return request;
},
loadDocument: function (url, next, nextContext) {
this.load(url, next, nextContext).responseType = 'document';
}
};
scope.xhr = xhr;
});
window.HTMLImports.addModule(function (scope) {
var xhr = scope.xhr;
var flags = scope.flags;
var Loader = function (onLoad, onComplete) {
this.cache = {};
this.onload = onLoad;
this.oncomplete = onComplete;
this.inflight = 0;
this.pending = {};
};
Loader.prototype = {
addNodes: function (nodes) {
this.inflight += nodes.length;
for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
this.require(n);
}
this.checkDone();
},
addNode: function (node) {
this.inflight++;
this.require(node);
this.checkDone();
},
require: function (elt) {
var url = elt.src || elt.href;
elt.__nodeUrl = url;
if (!this.dedupe(url, elt)) {
this.fetch(url, elt);
}
},
dedupe: function (url, elt) {
if (this.pending[url]) {
this.pending[url].push(elt);
return true;
}
var resource;
if (this.cache[url]) {
this.onload(url, elt, this.cache[url]);
this.tail();
return true;
}
this.pending[url] = [elt];
return false;
},
fetch: function (url, elt) {
flags.load && console.log('fetch', url, elt);
if (!url) {
setTimeout(function () {
this.receive(url, elt, { error: 'href must be specified' }, null);
}.bind(this), 0);
} else if (url.match(/^data:/)) {
var pieces = url.split(',');
var header = pieces[0];
var body = pieces[1];
if (header.indexOf(';base64') > -1) {
body = atob(body);
} else {
body = decodeURIComponent(body);
}
setTimeout(function () {
this.receive(url, elt, null, body);
}.bind(this), 0);
} else {
var receiveXhr = function (err, resource, redirectedUrl) {
this.receive(url, elt, err, resource, redirectedUrl);
}.bind(this);
xhr.load(url, receiveXhr);
}
},
receive: function (url, elt, err, resource, redirectedUrl) {
this.cache[url] = resource;
var $p = this.pending[url];
for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
this.onload(url, p, resource, err, redirectedUrl);
this.tail();
}
this.pending[url] = null;
},
tail: function () {
--this.inflight;
this.checkDone();
},
checkDone: function () {
if (!this.inflight) {
this.oncomplete();
}
}
};
scope.Loader = Loader;
});
window.HTMLImports.addModule(function (scope) {
var Observer = function (addCallback) {
this.addCallback = addCallback;
this.mo = new MutationObserver(this.handler.bind(this));
};
Observer.prototype = {
handler: function (mutations) {
for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
if (m.type === 'childList' && m.addedNodes.length) {
this.addedNodes(m.addedNodes);
}
}
},
addedNodes: function (nodes) {
if (this.addCallback) {
this.addCallback(nodes);
}
for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
if (n.children && n.children.length) {
this.addedNodes(n.children);
}
}
},
observe: function (root) {
this.mo.observe(root, {
childList: true,
subtree: true
});
}
};
scope.Observer = Observer;
});
window.HTMLImports.addModule(function (scope) {
var path = scope.path;
var rootDocument = scope.rootDocument;
var flags = scope.flags;
var isIE = scope.isIE;
var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
var IMPORT_SELECTOR = 'link[rel=' + IMPORT_LINK_TYPE + ']';
var importParser = {
documentSelectors: IMPORT_SELECTOR,
importsSelectors: [
IMPORT_SELECTOR,
'link[rel=stylesheet]:not([type])',
'style:not([type])',
'script:not([type])',
'script[type="application/javascript"]',
'script[type="text/javascript"]'
].join(','),
map: {
link: 'parseLink',
script: 'parseScript',
style: 'parseStyle'
},
dynamicElements: [],
parseNext: function () {
var next = this.nextToParse();
if (next) {
this.parse(next);
}
},
parse: function (elt) {
if (this.isParsed(elt)) {
flags.parse && console.log('[%s] is already parsed', elt.localName);
return;
}
var fn = this[this.map[elt.localName]];
if (fn) {
this.markParsing(elt);
fn.call(this, elt);
}
},
parseDynamic: function (elt, quiet) {
this.dynamicElements.push(elt);
if (!quiet) {
this.parseNext();
}
},
markParsing: function (elt) {
flags.parse && console.log('parsing', elt);
this.parsingElement = elt;
},
markParsingComplete: function (elt) {
elt.__importParsed = true;
this.markDynamicParsingComplete(elt);
if (elt.__importElement) {
elt.__importElement.__importParsed = true;
this.markDynamicParsingComplete(elt.__importElement);
}
this.parsingElement = null;
flags.parse && console.log('completed', elt);
},
markDynamicParsingComplete: function (elt) {
var i = this.dynamicElements.indexOf(elt);
if (i >= 0) {
this.dynamicElements.splice(i, 1);
}
},
parseImport: function (elt) {
elt.import = elt.__doc;
if (window.HTMLImports.__importsParsingHook) {
window.HTMLImports.__importsParsingHook(elt);
}
if (elt.import) {
elt.import.__importParsed = true;
}
this.markParsingComplete(elt);
if (elt.__resource && !elt.__error) {
elt.dispatchEvent(new CustomEvent('load', { bubbles: false }));
} else {
elt.dispatchEvent(new CustomEvent('error', { bubbles: false }));
}
if (elt.__pending) {
var fn;
while (elt.__pending.length) {
fn = elt.__pending.shift();
if (fn) {
fn({ target: elt });
}
}
}
this.parseNext();
},
parseLink: function (linkElt) {
if (nodeIsImport(linkElt)) {
this.parseImport(linkElt);
} else {
linkElt.href = linkElt.href;
this.parseGeneric(linkElt);
}
},
parseStyle: function (elt) {
var src = elt;
elt = cloneStyle(elt);
src.__appliedElement = elt;
elt.__importElement = src;
this.parseGeneric(elt);
},
parseGeneric: function (elt) {
this.trackElement(elt);
this.addElementToDocument(elt);
},
rootImportForElement: function (elt) {
var n = elt;
while (n.ownerDocument.__importLink) {
n = n.ownerDocument.__importLink;
}
return n;
},
addElementToDocument: function (elt) {
var port = this.rootImportForElement(elt.__importElement || elt);
port.parentNode.insertBefore(elt, port);
},
trackElement: function (elt, callback) {
var self = this;
var done = function (e) {
elt.removeEventListener('load', done);
elt.removeEventListener('error', done);
if (callback) {
callback(e);
}
self.markParsingComplete(elt);
self.parseNext();
};
elt.addEventListener('load', done);
elt.addEventListener('error', done);
if (isIE && elt.localName === 'style') {
var fakeLoad = false;
if (elt.textContent.indexOf('@import') == -1) {
fakeLoad = true;
} else if (elt.sheet) {
fakeLoad = true;
var csr = elt.sheet.cssRules;
var len = csr ? csr.length : 0;
for (var i = 0, r; i < len && (r = csr[i]); i++) {
if (r.type === CSSRule.IMPORT_RULE) {
fakeLoad = fakeLoad && Boolean(r.styleSheet);
}
}
}
if (fakeLoad) {
setTimeout(function () {
elt.dispatchEvent(new CustomEvent('load', { bubbles: false }));
});
}
}
},
parseScript: function (scriptElt) {
var script = document.createElement('script');
script.__importElement = scriptElt;
script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
scope.currentScript = scriptElt;
this.trackElement(script, function (e) {
if (script.parentNode) {
script.parentNode.removeChild(script);
}
scope.currentScript = null;
});
this.addElementToDocument(script);
},
nextToParse: function () {
this._mayParse = [];
return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
},
nextToParseInDoc: function (doc, link) {
if (doc && this._mayParse.indexOf(doc) < 0) {
this._mayParse.push(doc);
var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
if (!this.isParsed(n)) {
if (this.hasResource(n)) {
return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
} else {
return;
}
}
}
}
return link;
},
nextToParseDynamic: function () {
return this.dynamicElements[0];
},
parseSelectorsForNode: function (node) {
var doc = node.ownerDocument || node;
return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
},
isParsed: function (node) {
return node.__importParsed;
},
needsDynamicParsing: function (elt) {
return this.dynamicElements.indexOf(elt) >= 0;
},
hasResource: function (node) {
if (nodeIsImport(node) && node.__doc === undefined) {
return false;
}
return true;
}
};
function nodeIsImport(elt) {
return elt.localName === 'link' && elt.rel === IMPORT_LINK_TYPE;
}
function generateScriptDataUrl(script) {
var scriptContent = generateScriptContent(script);
return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(scriptContent);
}
function generateScriptContent(script) {
return script.textContent + generateSourceMapHint(script);
}
function generateSourceMapHint(script) {
var owner = script.ownerDocument;
owner.__importedScripts = owner.__importedScripts || 0;
var moniker = script.ownerDocument.baseURI;
var num = owner.__importedScripts ? '-' + owner.__importedScripts : '';
owner.__importedScripts++;
return '\n//# sourceURL=' + moniker + num + '.js\n';
}
function cloneStyle(style) {
var clone = style.ownerDocument.createElement('style');
clone.textContent = style.textContent;
path.resolveUrlsInStyle(clone);
return clone;
}
scope.parser = importParser;
scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
});
window.HTMLImports.addModule(function (scope) {
var flags = scope.flags;
var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
var rootDocument = scope.rootDocument;
var Loader = scope.Loader;
var Observer = scope.Observer;
var parser = scope.parser;
var importer = {
documents: {},
documentPreloadSelectors: IMPORT_SELECTOR,
importsPreloadSelectors: [IMPORT_SELECTOR].join(','),
loadNode: function (node) {
importLoader.addNode(node);
},
loadSubtree: function (parent) {
var nodes = this.marshalNodes(parent);
importLoader.addNodes(nodes);
},
marshalNodes: function (parent) {
return parent.querySelectorAll(this.loadSelectorsForNode(parent));
},
loadSelectorsForNode: function (node) {
var doc = node.ownerDocument || node;
return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
},
loaded: function (url, elt, resource, err, redirectedUrl) {
flags.load && console.log('loaded', url, elt);
elt.__resource = resource;
elt.__error = err;
if (isImportLink(elt)) {
var doc = this.documents[url];
if (doc === undefined) {
doc = err ? null : makeDocument(resource, redirectedUrl || url);
if (doc) {
doc.__importLink = elt;
this.bootDocument(doc);
}
this.documents[url] = doc;
}
elt.__doc = doc;
}
parser.parseNext();
},
bootDocument: function (doc) {
this.loadSubtree(doc);
this.observer.observe(doc);
parser.parseNext();
},
loadedAll: function () {
parser.parseNext();
}
};
var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
importer.observer = new Observer();
function isImportLink(elt) {
return isLinkRel(elt, IMPORT_LINK_TYPE);
}
function isLinkRel(elt, rel) {
return elt.localName === 'link' && elt.getAttribute('rel') === rel;
}
function hasBaseURIAccessor(doc) {
return !!Object.getOwnPropertyDescriptor(doc, 'baseURI');
}
function makeDocument(resource, url) {
var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
doc._URL = url;
var base = doc.createElement('base');
base.setAttribute('href', url);
if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
Object.defineProperty(doc, 'baseURI', { value: url });
}
var meta = doc.createElement('meta');
meta.setAttribute('charset', 'utf-8');
doc.head.appendChild(meta);
doc.head.appendChild(base);
doc.body.innerHTML = resource;
if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
HTMLTemplateElement.bootstrap(doc);
}
return doc;
}
if (!document.baseURI) {
var baseURIDescriptor = {
get: function () {
var base = document.querySelector('base');
return base ? base.href : window.location.href;
},
configurable: true
};
Object.defineProperty(document, 'baseURI', baseURIDescriptor);
Object.defineProperty(rootDocument, 'baseURI', baseURIDescriptor);
}
scope.importer = importer;
scope.importLoader = importLoader;
});
window.HTMLImports.addModule(function (scope) {
var parser = scope.parser;
var importer = scope.importer;
var dynamic = {
added: function (nodes) {
var owner, parsed, loading;
for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
if (!owner) {
owner = n.ownerDocument;
parsed = parser.isParsed(owner);
}
loading = this.shouldLoadNode(n);
if (loading) {
importer.loadNode(n);
}
if (this.shouldParseNode(n) && parsed) {
parser.parseDynamic(n, loading);
}
}
},
shouldLoadNode: function (node) {
return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
},
shouldParseNode: function (node) {
return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
}
};
importer.observer.addCallback = dynamic.added.bind(dynamic);
var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
});
(function (scope) {
var initializeModules = scope.initializeModules;
var isIE = scope.isIE;
if (scope.useNative) {
return;
}
initializeModules();
var rootDocument = scope.rootDocument;
function bootstrap() {
window.HTMLImports.importer.bootDocument(rootDocument);
}
if (document.readyState === 'complete' || document.readyState === 'interactive' && !window.attachEvent) {
bootstrap();
} else {
document.addEventListener('DOMContentLoaded', bootstrap);
}
}(window.HTMLImports));
window.CustomElements = window.CustomElements || { flags: {} };
(function (scope) {
var flags = scope.flags;
var modules = [];
var addModule = function (module) {
modules.push(module);
};
var initializeModules = function () {
modules.forEach(function (module) {
module(scope);
});
};
scope.addModule = addModule;
scope.initializeModules = initializeModules;
scope.hasNative = Boolean(document.registerElement);
scope.isIE = /Trident/.test(navigator.userAgent);
scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
}(window.CustomElements));
window.CustomElements.addModule(function (scope) {
var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : 'none';
function forSubtree(node, cb) {
findAllElements(node, function (e) {
if (cb(e)) {
return true;
}
forRoots(e, cb);
});
forRoots(node, cb);
}
function findAllElements(node, find, data) {
var e = node.firstElementChild;
if (!e) {
e = node.firstChild;
while (e && e.nodeType !== Node.ELEMENT_NODE) {
e = e.nextSibling;
}
}
while (e) {
if (find(e, data) !== true) {
findAllElements(e, find, data);
}
e = e.nextElementSibling;
}
return null;
}
function forRoots(node, cb) {
var root = node.shadowRoot;
while (root) {
forSubtree(root, cb);
root = root.olderShadowRoot;
}
}
function forDocumentTree(doc, cb) {
_forDocumentTree(doc, cb, []);
}
function _forDocumentTree(doc, cb, processingDocuments) {
doc = window.wrap(doc);
if (processingDocuments.indexOf(doc) >= 0) {
return;
}
processingDocuments.push(doc);
var imports = doc.querySelectorAll('link[rel=' + IMPORT_LINK_TYPE + ']');
for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
if (n.import) {
_forDocumentTree(n.import, cb, processingDocuments);
}
}
cb(doc);
}
scope.forDocumentTree = forDocumentTree;
scope.forSubtree = forSubtree;
});
window.CustomElements.addModule(function (scope) {
var flags = scope.flags;
var forSubtree = scope.forSubtree;
var forDocumentTree = scope.forDocumentTree;
function addedNode(node, isAttached) {
return added(node, isAttached) || addedSubtree(node, isAttached);
}
function added(node, isAttached) {
if (scope.upgrade(node, isAttached)) {
return true;
}
if (isAttached) {
attached(node);
}
}
function addedSubtree(node, isAttached) {
forSubtree(node, function (e) {
if (added(e, isAttached)) {
return true;
}
});
}
var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags['throttle-attached'];
scope.hasPolyfillMutations = hasThrottledAttached;
scope.hasThrottledAttached = hasThrottledAttached;
var isPendingMutations = false;
var pendingMutations = [];
function deferMutation(fn) {
pendingMutations.push(fn);
if (!isPendingMutations) {
isPendingMutations = true;
setTimeout(takeMutations);
}
}
function takeMutations() {
isPendingMutations = false;
var $p = pendingMutations;
for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
p();
}
pendingMutations = [];
}
function attached(element) {
if (hasThrottledAttached) {
deferMutation(function () {
_attached(element);
});
} else {
_attached(element);
}
}
function _attached(element) {
if (element.__upgraded__ && !element.__attached) {
element.__attached = true;
if (element.attachedCallback) {
element.attachedCallback();
}
}
}
function detachedNode(node) {
detached(node);
forSubtree(node, function (e) {
detached(e);
});
}
function detached(element) {
if (hasThrottledAttached) {
deferMutation(function () {
_detached(element);
});
} else {
_detached(element);
}
}
function _detached(element) {
if (element.__upgraded__ && element.__attached) {
element.__attached = false;
if (element.detachedCallback) {
element.detachedCallback();
}
}
}
function inDocument(element) {
var p = element;
var doc = window.wrap(document);
while (p) {
if (p == doc) {
return true;
}
p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
}
}
function watchShadow(node) {
if (node.shadowRoot && !node.shadowRoot.__watched) {
flags.dom && console.log('watching shadow-root for: ', node.localName);
var root = node.shadowRoot;
while (root) {
observe(root);
root = root.olderShadowRoot;
}
}
}
function handler(root, mutations) {
if (flags.dom) {
var mx = mutations[0];
if (mx && mx.type === 'childList' && mx.addedNodes) {
if (mx.addedNodes) {
var d = mx.addedNodes[0];
while (d && d !== document && !d.host) {
d = d.parentNode;
}
var u = d && (d.URL || d._URL || d.host && d.host.localName) || '';
u = u.split('/?').shift().split('/').pop();
}
}
console.group('mutations (%d) [%s]', mutations.length, u || '');
}
var isAttached = inDocument(root);
mutations.forEach(function (mx) {
if (mx.type === 'childList') {
forEach(mx.addedNodes, function (n) {
if (!n.localName) {
return;
}
addedNode(n, isAttached);
});
forEach(mx.removedNodes, function (n) {
if (!n.localName) {
return;
}
detachedNode(n);
});
}
});
flags.dom && console.groupEnd();
}
function takeRecords(node) {
node = window.wrap(node);
if (!node) {
node = window.wrap(document);
}
while (node.parentNode) {
node = node.parentNode;
}
var observer = node.__observer;
if (observer) {
handler(node, observer.takeRecords());
takeMutations();
}
}
var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
function observe(inRoot) {
if (inRoot.__observer) {
return;
}
var observer = new MutationObserver(handler.bind(this, inRoot));
observer.observe(inRoot, {
childList: true,
subtree: true
});
inRoot.__observer = observer;
}
function upgradeDocument(doc) {
doc = window.wrap(doc);
flags.dom && console.group('upgradeDocument: ', doc.baseURI.split('/').pop());
var isMainDocument = doc === window.wrap(document);
addedNode(doc, isMainDocument);
observe(doc);
flags.dom && console.groupEnd();
}
function upgradeDocumentTree(doc) {
forDocumentTree(doc, upgradeDocument);
}
var originalCreateShadowRoot = Element.prototype.createShadowRoot;
if (originalCreateShadowRoot) {
Element.prototype.createShadowRoot = function () {
var root = originalCreateShadowRoot.call(this);
window.CustomElements.watchShadow(this);
return root;
};
}
scope.watchShadow = watchShadow;
scope.upgradeDocumentTree = upgradeDocumentTree;
scope.upgradeDocument = upgradeDocument;
scope.upgradeSubtree = addedSubtree;
scope.upgradeAll = addedNode;
scope.attached = attached;
scope.takeRecords = takeRecords;
});
window.CustomElements.addModule(function (scope) {
var flags = scope.flags;
function upgrade(node, isAttached) {
if (node.localName === 'template') {
if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(node);
}
}
if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
var is = node.getAttribute('is');
var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
if (definition) {
if (is && definition.tag == node.localName || !is && !definition.extends) {
return upgradeWithDefinition(node, definition, isAttached);
}
}
}
}
function upgradeWithDefinition(element, definition, isAttached) {
flags.upgrade && console.group('upgrade:', element.localName);
if (definition.is) {
element.setAttribute('is', definition.is);
}
implementPrototype(element, definition);
element.__upgraded__ = true;
created(element);
if (isAttached) {
scope.attached(element);
}
scope.upgradeSubtree(element, isAttached);
flags.upgrade && console.groupEnd();
return element;
}
function implementPrototype(element, definition) {
if (Object.__proto__) {
element.__proto__ = definition.prototype;
} else {
customMixin(element, definition.prototype, definition.native);
element.__proto__ = definition.prototype;
}
}
function customMixin(inTarget, inSrc, inNative) {
var used = {};
var p = inSrc;
while (p !== inNative && p !== HTMLElement.prototype) {
var keys = Object.getOwnPropertyNames(p);
for (var i = 0, k; k = keys[i]; i++) {
if (!used[k]) {
Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
used[k] = 1;
}
}
p = Object.getPrototypeOf(p);
}
}
function created(element) {
if (element.createdCallback) {
element.createdCallback();
}
}
scope.upgrade = upgrade;
scope.upgradeWithDefinition = upgradeWithDefinition;
scope.implementPrototype = implementPrototype;
});
window.CustomElements.addModule(function (scope) {
var isIE = scope.isIE;
var upgradeDocumentTree = scope.upgradeDocumentTree;
var upgradeAll = scope.upgradeAll;
var upgradeWithDefinition = scope.upgradeWithDefinition;
var implementPrototype = scope.implementPrototype;
var useNative = scope.useNative;
function register(name, options) {
var definition = options || {};
if (!name) {
throw new Error('document.registerElement: first argument `name` must not be empty');
}
if (name.indexOf('-') < 0) {
throw new Error('document.registerElement: first argument (\'name\') must contain a dash (\'-\'). Argument provided was \'' + String(name) + '\'.');
}
if (isReservedTag(name)) {
throw new Error('Failed to execute \'registerElement\' on \'Document\': Registration failed for type \'' + String(name) + '\'. The type name is invalid.');
}
if (getRegisteredDefinition(name)) {
throw new Error('DuplicateDefinitionError: a type with name \'' + String(name) + '\' is already registered');
}
if (!definition.prototype) {
definition.prototype = Object.create(HTMLElement.prototype);
}
definition.__name = name.toLowerCase();
if (definition.extends) {
definition.extends = definition.extends.toLowerCase();
}
definition.lifecycle = definition.lifecycle || {};
definition.ancestry = ancestry(definition.extends);
resolveTagName(definition);
resolvePrototypeChain(definition);
overrideAttributeApi(definition.prototype);
registerDefinition(definition.__name, definition);
definition.ctor = generateConstructor(definition);
definition.ctor.prototype = definition.prototype;
definition.prototype.constructor = definition.ctor;
if (scope.ready) {
upgradeDocumentTree(document);
}
return definition.ctor;
}
function overrideAttributeApi(prototype) {
if (prototype.setAttribute._polyfilled) {
return;
}
var setAttribute = prototype.setAttribute;
prototype.setAttribute = function (name, value) {
changeAttribute.call(this, name, value, setAttribute);
};
var removeAttribute = prototype.removeAttribute;
prototype.removeAttribute = function (name) {
changeAttribute.call(this, name, null, removeAttribute);
};
prototype.setAttribute._polyfilled = true;
}
function changeAttribute(name, value, operation) {
name = name.toLowerCase();
var oldValue = this.getAttribute(name);
operation.apply(this, arguments);
var newValue = this.getAttribute(name);
if (this.attributeChangedCallback && newValue !== oldValue) {
this.attributeChangedCallback(name, oldValue, newValue);
}
}
function isReservedTag(name) {
for (var i = 0; i < reservedTagList.length; i++) {
if (name === reservedTagList[i]) {
return true;
}
}
}
var reservedTagList = [
'annotation-xml',
'color-profile',
'font-face',
'font-face-src',
'font-face-uri',
'font-face-format',
'font-face-name',
'missing-glyph'
];
function ancestry(extnds) {
var extendee = getRegisteredDefinition(extnds);
if (extendee) {
return ancestry(extendee.extends).concat([extendee]);
}
return [];
}
function resolveTagName(definition) {
var baseTag = definition.extends;
for (var i = 0, a; a = definition.ancestry[i]; i++) {
baseTag = a.is && a.tag;
}
definition.tag = baseTag || definition.__name;
if (baseTag) {
definition.is = definition.__name;
}
}
function resolvePrototypeChain(definition) {
if (!Object.__proto__) {
var nativePrototype = HTMLElement.prototype;
if (definition.is) {
var inst = document.createElement(definition.tag);
nativePrototype = Object.getPrototypeOf(inst);
}
var proto = definition.prototype, ancestor;
var foundPrototype = false;
while (proto) {
if (proto == nativePrototype) {
foundPrototype = true;
}
ancestor = Object.getPrototypeOf(proto);
if (ancestor) {
proto.__proto__ = ancestor;
}
proto = ancestor;
}
if (!foundPrototype) {
console.warn(definition.tag + ' prototype not found in prototype chain for ' + definition.is);
}
definition.native = nativePrototype;
}
}
function instantiate(definition) {
return upgradeWithDefinition(domCreateElement(definition.tag), definition);
}
var registry = {};
function getRegisteredDefinition(name) {
if (name) {
return registry[name.toLowerCase()];
}
}
function registerDefinition(name, definition) {
registry[name] = definition;
}
function generateConstructor(definition) {
return function () {
return instantiate(definition);
};
}
var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
function createElementNS(namespace, tag, typeExtension) {
if (namespace === HTML_NAMESPACE) {
return createElement(tag, typeExtension);
} else {
return domCreateElementNS(namespace, tag);
}
}
function createElement(tag, typeExtension) {
if (tag) {
tag = tag.toLowerCase();
}
if (typeExtension) {
typeExtension = typeExtension.toLowerCase();
}
var definition = getRegisteredDefinition(typeExtension || tag);
if (definition) {
if (tag == definition.tag && typeExtension == definition.is) {
return new definition.ctor();
}
if (!typeExtension && !definition.is) {
return new definition.ctor();
}
}
var element;
if (typeExtension) {
element = createElement(tag);
element.setAttribute('is', typeExtension);
return element;
}
element = domCreateElement(tag);
if (tag.indexOf('-') >= 0) {
implementPrototype(element, HTMLElement);
}
return element;
}
var domCreateElement = document.createElement.bind(document);
var domCreateElementNS = document.createElementNS.bind(document);
var isInstance;
if (!Object.__proto__ && !useNative) {
isInstance = function (obj, ctor) {
if (obj instanceof ctor) {
return true;
}
var p = obj;
while (p) {
if (p === ctor.prototype) {
return true;
}
p = p.__proto__;
}
return false;
};
} else {
isInstance = function (obj, base) {
return obj instanceof base;
};
}
function wrapDomMethodToForceUpgrade(obj, methodName) {
var orig = obj[methodName];
obj[methodName] = function () {
var n = orig.apply(this, arguments);
upgradeAll(n);
return n;
};
}
wrapDomMethodToForceUpgrade(Node.prototype, 'cloneNode');
wrapDomMethodToForceUpgrade(document, 'importNode');
document.registerElement = register;
document.createElement = createElement;
document.createElementNS = createElementNS;
scope.registry = registry;
scope.instanceof = isInstance;
scope.reservedTagList = reservedTagList;
scope.getRegisteredDefinition = getRegisteredDefinition;
document.register = document.registerElement;
});
(function (scope) {
var useNative = scope.useNative;
var initializeModules = scope.initializeModules;
var isIE = scope.isIE;
if (useNative) {
var nop = function () {
};
scope.watchShadow = nop;
scope.upgrade = nop;
scope.upgradeAll = nop;
scope.upgradeDocumentTree = nop;
scope.upgradeSubtree = nop;
scope.takeRecords = nop;
scope.instanceof = function (obj, base) {
return obj instanceof base;
};
} else {
initializeModules();
}
var upgradeDocumentTree = scope.upgradeDocumentTree;
var upgradeDocument = scope.upgradeDocument;
if (!window.wrap) {
if (window.ShadowDOMPolyfill) {
window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
} else {
window.wrap = window.unwrap = function (node) {
return node;
};
}
}
if (window.HTMLImports) {
window.HTMLImports.__importsParsingHook = function (elt) {
if (elt.import) {
upgradeDocument(wrap(elt.import));
}
};
}
function bootstrap() {
upgradeDocumentTree(window.wrap(document));
window.CustomElements.ready = true;
var requestAnimationFrame = window.requestAnimationFrame || function (f) {
setTimeout(f, 16);
};
requestAnimationFrame(function () {
setTimeout(function () {
window.CustomElements.readyTime = Date.now();
if (window.HTMLImports) {
window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
}
document.dispatchEvent(new CustomEvent('WebComponentsReady', { bubbles: true }));
});
});
}
if (document.readyState === 'complete' || scope.flags.eager) {
bootstrap();
} else if (document.readyState === 'interactive' && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
bootstrap();
} else {
var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? 'HTMLImportsLoaded' : 'DOMContentLoaded';
window.addEventListener(loadEvent, bootstrap);
}
}(window.CustomElements));
(function (scope) {
if (!Function.prototype.bind) {
Function.prototype.bind = function (scope) {
var self = this;
var args = Array.prototype.slice.call(arguments, 1);
return function () {
var args2 = args.slice();
args2.push.apply(args2, arguments);
return self.apply(scope, args2);
};
};
}
}(window.WebComponents));
(function (scope) {
var style = document.createElement('style');
style.textContent = '' + 'body {' + 'transition: opacity ease-in 0.2s;' + ' } \n' + 'body[unresolved] {' + 'opacity: 0; display: block; overflow: hidden; position: relative;' + ' } \n';
var head = document.querySelector('head');
head.insertBefore(style, head.firstChild);
}(window.WebComponents));
(function (scope) {
window.Platform = scope;
}(window.WebComponents));
(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
settings.isIE = navigator.userAgent.match('Trident');
settings.passiveTouchGestures = settings.passiveTouchGestures || false;
return settings;
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
prototype = desugar(prototype);
var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
var ctor = document.registerElement(prototype.is, options);
return customCtor || ctor;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = function (prototype) {
if (!prototype.factoryImpl) {
prototype.factoryImpl = function () {
};
}
return desugar(prototype).constructor;
};
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript || {}).ownerDocument;
}
});
Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.mixin(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(this);
}
}
if (this.beforeRegister) {
this.beforeRegister();
}
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (settings.disableUpgradeEnabled) {
if (this.hasAttribute('disable-upgrade')) {
this._propertySetter = disableUpgradePropertySetter;
this._configValue = null;
this.__data__ = {};
return;
} else {
this.__hasInitialized = true;
}
}
this.__initialize();
},
__initialize: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.created) {
b.created.call(this);
}
}
if (this.created) {
this.created();
}
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
for (var i = 0, b; i < proto.behaviors.length; i++) {
b = proto.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(proto);
}
}
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
for (var j = 0, pb; j < proto.behaviors.length; j++) {
pb = proto.behaviors[j];
if (pb.registered) {
pb.registered.call(proto);
}
}
if (proto.registered) {
proto.registered();
}
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.attached) {
b.attached.call(self);
}
}
if (self.attached) {
self.attached();
}
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.detached) {
b.detached.call(self);
}
}
if (self.detached) {
self.detached();
}
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.attributeChanged) {
b.attributeChanged.call(this, name, oldValue, newValue);
}
}
if (this.attributeChanged) {
this.attributeChanged(name, oldValue, newValue);
}
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.BaseDescriptors = {};
var disableUpgradePropertySetter;
if (settings.disableUpgradeEnabled) {
disableUpgradePropertySetter = function (property, value) {
this.__data__[property] = value;
};
var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
Polymer.Base.attributeChangedCallback = function (name, oldValue, newValue) {
if (!this.__hasInitialized && name === 'disable-upgrade') {
this.__hasInitialized = true;
this._propertySetter = Polymer.Bind._modelApi._propertySetter;
this._configValue = Polymer.Base._configValue;
this.__initialize();
}
origAttributeChangedCallback.call(this, name, oldValue, newValue);
};
}
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());
(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.mixin(DomModule.prototype, {
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
Object.defineProperty(DomModule.prototype, 'constructor', {
value: DomModule,
configurable: true,
writable: true
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
var useAssignment = b._noAccessors;
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
if (useAssignment) {
this[n] = b[n];
} else {
this.copyOwnProperty(n, b, this);
}
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true,
_noAccessors: true
};
Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
p = Object.create(this.getNativePrototype(tag));
var p$ = Object.getOwnPropertyNames(Polymer.Base);
for (var i = 0, n; i < p$.length && (n = p$[i]); i++) {
if (!Polymer.BaseDescriptors[n]) {
p[n] = Polymer.Base[n];
}
}
Object.defineProperties(p, Polymer.BaseDescriptors);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});
(function () {
var propertiesDesc = {
configurable: true,
writable: true,
enumerable: true,
value: {}
};
Polymer.BaseDescriptors.properties = propertiesDesc;
Object.defineProperty(Polymer.Base, 'properties', propertiesDesc);
}());
Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};
Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.version = '1.11.2';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement('a'));
}
function pathFromUrl(url) {
return url.substring(0, url.lastIndexOf('/') + 1);
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl,
pathFromUrl: pathFromUrl
};
Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href);
}());
Polymer.Base._addFeature({
_prepTemplate: function () {
var module;
if (this._template === undefined) {
module = Polymer.DomModule.import(this.is);
this._template = module && module.querySelector('template');
}
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL);
} else {
this._importPath = '';
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
var baseDetachedCallback = Polymer.Base.detachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.ready) {
b.ready.call(this);
}
}
if (this.ready) {
this.ready();
}
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
},
detachedCallback: function () {
if (this._readied) {
baseDetachedCallback.call(this);
} else {
this._attachedPending = false;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();
(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.mixin(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());
(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.mixin(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());
Polymer.Base.mixin(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});
Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());
(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());
(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var domHostDesc = {
get: function () {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
configurable: true
};
Object.defineProperty(Polymer.Base, 'domHost', domHostDesc);
Polymer.BaseDescriptors.domHost = domHostDesc;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});
(function () {
Polymer.nar = [];
var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
Polymer.Annotations = {
parseAnnotations: function (template, stripWhiteSpace) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote, stripWhiteSpace);
}
if (node.localName == 'slot') {
node = this._replaceSlotWithContent(node);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_replaceSlotWithContent: function (slot) {
var content = slot.ownerDocument.createElement('content');
while (slot.firstChild) {
content.appendChild(slot.firstChild);
}
var attrs = slot.attributes;
for (var i = 0; i < attrs.length; i++) {
var attr = attrs[i];
content.setAttribute(attr.name, attr.value);
}
var name = slot.getAttribute('name');
if (name) {
content.setAttribute('select', '[slot=\'' + name + '\']');
}
slot.parentNode.replaceChild(content, slot);
return content;
},
_parseTemplate: function (node, index, list, parent, stripWhiteSpace) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node, stripWhiteSpace);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
if (disableUpgradeEnabled && origName === 'disable-upgrade$') {
node.setAttribute(name, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};
}());
Polymer.Path = {
root: function (path) {
var dotIndex = path.indexOf('.');
if (dotIndex === -1) {
return path;
}
return path.slice(0, dotIndex);
},
isDeep: function (path) {
return path.indexOf('.') !== -1;
},
isAncestor: function (base, path) {
return base.indexOf(path + '.') === 0;
},
isDescendant: function (base, path) {
return path.indexOf(base + '.') === 0;
},
translate: function (base, newBase, path) {
return newBase + path.slice(base.length);
},
matches: function (base, wildcard, path) {
return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
}
};
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = Polymer.Path.root(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
if (!Polymer.Settings.isIE || target != window) {
hbl.set(target, bl);
}
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
function isMouseEvent(name) {
return MOUSE_EVENTS.indexOf(name) > -1;
}
var SUPPORTS_PASSIVE = false;
(function () {
try {
var opts = Object.defineProperty({}, 'passive', {
get: function () {
SUPPORTS_PASSIVE = true;
}
});
window.addEventListener('test', null, opts);
window.removeEventListener('test', null, opts);
} catch (e) {
}
}());
function PASSIVE_TOUCH(eventName) {
if (isMouseEvent(eventName) || eventName === 'touchend') {
return;
}
if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && Polymer.Settings.passiveTouchGestures) {
return { passive: true };
}
}
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
for (var i = 0, en; i < events.length; i++) {
en = events[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse(ev) {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (!isMouseEvent(type)) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep));
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep));
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onload.call(self, e);
};
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
if (onload) {
imprt.addEventListener('load', loadListener);
}
if (onerror) {
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());
Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (Polymer.Path.isDescendant(path, prop)) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
var newPath = Polymer.Path.translate(property, path, targetPath);
this._notifyPath(newPath, value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};
Polymer.Base.mixin(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = Polymer.Path.isAncestor(path, name);
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = Polymer.Path.root(arg);
a.structured = Polymer.Path.isDeep(arg);
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, 'properties'));
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this.importPath = this._importPath;
this.rootPath = Polymer.rootPath;
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());
(function () {
'use strict';
var Path = Polymer.Path;
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = Path.root(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (Path.matches(effect.value, false, path)) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (!effect.negate && Path.isDescendant(effect.value, path)) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var newPath = Path.translate(effect.value, effect.name, path);
node._notifyPath(newPath, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (Path.isDescendant(a, path)) {
this._notifyPath(Path.translate(a, b, path), value);
} else if (Path.isDescendant(b, path)) {
this._notifyPath(Path.translate(b, a, path), value);
}
}
},
_notifyPathUp: function (path, value) {
var rootName = Path.root(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
return Polymer.ResolveUrl.resolveUrl(url, this._importPath);
}
});
Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();
Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
unscopedStyleImports: new WeakMap(),
SHADY_UNSCOPED_ATTR: 'shady-unscoped',
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(/\s+/);
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
if (!e.hasAttribute('preserve-content')) {
cssText += this.cssFromElement(e);
}
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
var css = this.resolveCss(e.textContent, element.ownerDocument);
if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
e.textContent = css;
document.head.insertBefore(e, document.head.firstChild);
} else {
cssText += css;
}
} else if (e.import && e.import.body) {
var importCss = this.resolveCss(e.import.body.textContent, e.import);
if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
if (!this.unscopedStyleImports.has(e.import)) {
this.unscopedStyleImports.set(e.import, true);
var importStyle = document.createElement('style');
importStyle.setAttribute(this.SHADY_UNSCOPED_ATTR, '');
importStyle.textContent = importCss;
document.head.insertBefore(importStyle, document.head.firstChild);
}
} else {
cssText += importCss;
}
}
}
}
return cssText;
},
styleIncludesToTemplate: function (targetTemplate) {
var styles = targetTemplate.content.querySelectorAll('style[include]');
for (var i = 0, s; i < styles.length; i++) {
s = styles[i];
s.parentNode.insertBefore(this._includesToFragment(s.getAttribute('include')), s);
}
},
_includesToFragment: function (styleIncludes) {
var includeArray = styleIncludes.trim().split(' ');
var frag = document.createDocumentFragment();
for (var i = 0; i < includeArray.length; i++) {
var t = Polymer.DomModule.import(includeArray[i], 'template');
if (t) {
this._addStylesToFragment(frag, t.content);
}
}
return frag;
},
_addStylesToFragment: function (frag, source) {
var s$ = source.querySelectorAll('style');
for (var i = 0, s; i < s$.length; i++) {
s = s$[i];
var include = s.getAttribute('include');
if (include) {
frag.appendChild(this._includesToFragment(include));
}
if (s.textContent) {
frag.appendChild(s.cloneNode(true));
}
}
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
var cb;
if (passthrough) {
var self = this;
cb = function (rule) {
rule.selector = self._slottedToContent(rule.selector);
rule.selector = rule.selector.replace(ROOT, ':host > *');
rule.selector = self._dirShadowTransform(rule.selector);
if (callback) {
callback(rule);
}
};
}
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_splitSelectorList: function (selector) {
var parts = [];
var part = '';
for (var i = 0; i >= 0 && i < selector.length; i++) {
if (selector[i] === '(') {
var end = styleUtil._findMatchingParen(selector, i);
part += selector.slice(i, end + 1);
i = end;
} else if (selector[i] === COMPLEX_SELECTOR_SEP) {
parts.push(part);
part = '';
} else {
part += selector[i];
}
}
if (part) {
parts.push(part);
}
if (parts.length === 0) {
parts.push(selector);
}
return parts;
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = this._splitSelectorList(rule.selector);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_ensureScopedDir: function (s) {
var m = s.match(DIR_PAREN);
if (m && m[1] === '' && m[0].length === s.length) {
s = '*' + s;
}
return s;
},
_additionalDirSelectors: function (dir, after, prefix) {
if (!dir || !after) {
return '';
}
prefix = prefix || '';
return COMPLEX_SELECTOR_SEP + prefix + ' ' + dir + ' ' + after;
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var dir = false;
var self = this;
selector = selector.trim();
selector = this._slottedToContent(selector);
selector = selector.replace(ROOT, ':host > *');
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = this._ensureScopedDir(selector);
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
dir = dir || info.dir;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
var replacement = pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
if (dir) {
replacement += self._additionalDirSelectors(paren, post, hostScope);
}
return replacement;
});
}
return selector;
},
_transformDir: function (s) {
s = s.replace(HOST_DIR, HOST_DIR_REPLACE);
s = s.replace(DIR_PAREN, DIR_REPLACE);
return s;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
var dir = false;
if (selector.match(DIR_PAREN)) {
selector = this._transformDir(selector);
dir = true;
}
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext,
dir: dir
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
rule.selector = rule.selector.replace(ROOT, 'html');
var parts = this._splitSelectorList(rule.selector);
parts = parts.filter(function (part) {
return !part.match(HOST_OR_HOST_GT_STAR);
});
rule.selector = parts.join(COMPLEX_SELECTOR_SEP);
},
_transformDocumentSelector: function (selector) {
return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR);
},
_slottedToContent: function (cssText) {
return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
},
_dirShadowTransform: function (selector) {
if (!selector.match(/:dir\(/)) {
return selector;
}
return this._splitSelectorList(selector).map(function (s) {
s = this._ensureScopedDir(s);
s = this._transformDir(s);
var m = HOST_CONTEXT_PAREN.exec(s);
if (m) {
s += this._additionalDirSelectors(m[2], m[3], '');
}
return s;
}, this).join(COMPLEX_SELECTOR_SEP);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/;
var DIR_PAREN = /(.*):dir\((ltr|rtl)\)/;
var DIR_REPLACE = ':host-context([dir="$2"]) $1';
var HOST_DIR = /:host\(:dir\((rtl|ltr)\)\)/g;
var HOST_DIR_REPLACE = ':host-context([dir="$1"])';
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '))';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
styleUtil.forRulesInStyles(styles, this._boundFindApplications);
if (elementProto) {
elementProto.__applyShimInvalid = false;
}
this.__currentElementProto = null;
},
_findDefinitions: function (rule) {
var cssText = rule.parsedCssText;
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
rule.cssText = cssText;
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
_findApplications: function (rule) {
rule.cssText = consumeCssProperties(rule.cssText);
},
transformRule: function (rule) {
this._findDefinitions(rule);
this._findApplications(rule);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
return ApplyShim;
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
if (settings.preserveStyleIncludes) {
styleUtil.styleIncludesToTemplate(this._template);
}
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
_rootSelector: /:root|:host\s*>\s*\*/,
_checkRoot: function (hostScope, selector) {
return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = this._checkRoot(hostScope, parsedSelector);
var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
if (isRoot && hostScope === 'html') {
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_hasDirOrHostContext: function (parsedSelector) {
return /:host-context|:dir/.test(parsedSelector);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = styleTransformer._calcElementScope(scopeId, viaAttr);
var hostScope = styleTransformer._calcElementScope(hostSelector, viaAttr);
var parts = selector.split(',');
var isDirOrHostContextSelector = this._hasDirOrHostContext(rule.parsedSelector);
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : isDirOrHostContextSelector ? p.replace(hostScope, scope + ' ' + hostScope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
if (IS_IE && cssText.indexOf('@media') > -1) {
style.textContent = cssText;
}
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
if (!nativeVariables && !this._styleProperties) {
this._computeStyleProperties();
}
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
if (this.factoryImpl) {
this._prepConstructor();
}
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure(this.__data__);
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});
(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
if (this.ownerDocument !== window.document && this.__appliedElement === this) {
document.head.appendChild(this);
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
});
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transform([e]);
}
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());
Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
proto._propertyEffects = proto._propertyEffects || {};
proto._propertyEffects[parentProp] = effects;
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
if (val && n == '_propertyEffects') {
var pe = Polymer.Base.mixin({}, val);
template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects);
} else {
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var root = Polymer.Path.root(path);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = Polymer.Path.root(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};
Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: !Polymer.Settings.suppressTemplateNotifications,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
notifyDomChange: { type: Boolean },
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
var parent = Polymer.dom(parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent, refNode);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent, refNode) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, refNode);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
if (beforeNode == this) {
beforeNode = parentNode;
}
parentNode = Polymer.dom(parentNode).parentNode;
}
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
if (!this._instances[i].isPlaceholder)
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
},
notifyDomChange: { type: Boolean }
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
var parentNode = this.parentNode;
if (parentNode && parentNode.localName == this.is) {
parentNode = Polymer.dom(parentNode).parentNode;
}
if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode && parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
if (parentNode) {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
Polymer.dom(parentNode).insertBefore(root, refNode);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(refNode).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
Polymer.dom(parentNode).insertBefore(n, refNode);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});
Polymer({
is: 'dom-bind',
properties: { notifyDomChange: { type: Boolean } },
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
Polymer.dom(parentNode).insertBefore(this.root, refNode);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
}
});
(function () {
var metaDatas = {};
var metaArrays = {};
var singleton = null;
Polymer.IronMeta = Polymer({
is: 'iron-meta',
properties: {
type: {
type: String,
value: 'default',
observer: '_typeChanged'
},
key: {
type: String,
observer: '_keyChanged'
},
value: {
type: Object,
notify: true,
observer: '_valueChanged'
},
self: {
type: Boolean,
observer: '_selfChanged'
},
list: {
type: Array,
notify: true
}
},
hostAttributes: { hidden: true },
factoryImpl: function (config) {
if (config) {
for (var n in config) {
switch (n) {
case 'type':
case 'key':
case 'value':
this[n] = config[n];
break;
}
}
}
},
created: function () {
this._metaDatas = metaDatas;
this._metaArrays = metaArrays;
},
_keyChanged: function (key, old) {
this._resetRegistration(old);
},
_valueChanged: function (value) {
this._resetRegistration(this.key);
},
_selfChanged: function (self) {
if (self) {
this.value = this;
}
},
_typeChanged: function (type) {
this._unregisterKey(this.key);
if (!metaDatas[type]) {
metaDatas[type] = {};
}
this._metaData = metaDatas[type];
if (!metaArrays[type]) {
metaArrays[type] = [];
}
this.list = metaArrays[type];
this._registerKeyValue(this.key, this.value);
},
byKey: function (key) {
return this._metaData && this._metaData[key];
},
_resetRegistration: function (oldKey) {
this._unregisterKey(oldKey);
this._registerKeyValue(this.key, this.value);
},
_unregisterKey: function (key) {
this._unregister(key, this._metaData, this.list);
},
_registerKeyValue: function (key, value) {
this._register(key, value, this._metaData, this.list);
},
_register: function (key, value, data, list) {
if (key && data && value !== undefined) {
data[key] = value;
list.push(value);
}
},
_unregister: function (key, data, list) {
if (key && data) {
if (key in data) {
var value = data[key];
delete data[key];
this.arrayDelete(list, value);
}
}
}
});
Polymer.IronMeta.getIronMeta = function getIronMeta() {
if (singleton === null) {
singleton = new Polymer.IronMeta();
}
return singleton;
};
Polymer.IronMetaQuery = Polymer({
is: 'iron-meta-query',
properties: {
type: {
type: String,
value: 'default',
observer: '_typeChanged'
},
key: {
type: String,
observer: '_keyChanged'
},
value: {
type: Object,
notify: true,
readOnly: true
},
list: {
type: Array,
notify: true
}
},
factoryImpl: function (config) {
if (config) {
for (var n in config) {
switch (n) {
case 'type':
case 'key':
this[n] = config[n];
break;
}
}
}
},
created: function () {
this._metaDatas = metaDatas;
this._metaArrays = metaArrays;
},
_keyChanged: function (key) {
this._setValue(this._metaData && this._metaData[key]);
},
_typeChanged: function (type) {
this._metaData = metaDatas[type];
this.list = metaArrays[type];
if (this.key) {
this._keyChanged(this.key);
}
},
byKey: function (key) {
return this._metaData && this._metaData[key];
}
});
}());
Polymer({
is: 'iron-icon',
properties: {
icon: { type: String },
theme: { type: String },
src: { type: String },
_meta: { value: Polymer.Base.create('iron-meta', { type: 'iconset' }) }
},
observers: [
'_updateIcon(_meta, isAttached)',
'_updateIcon(theme, isAttached)',
'_srcChanged(src, isAttached)',
'_iconChanged(icon, isAttached)'
],
_DEFAULT_ICONSET: 'icons',
_iconChanged: function (icon) {
var parts = (icon || '').split(':');
this._iconName = parts.pop();
this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
this._updateIcon();
},
_srcChanged: function (src) {
this._updateIcon();
},
_usesIconset: function () {
return this.icon || !this.src;
},
_updateIcon: function () {
if (this._usesIconset()) {
if (this._img && this._img.parentNode) {
Polymer.dom(this.root).removeChild(this._img);
}
if (this._iconName === '') {
if (this._iconset) {
this._iconset.removeIcon(this);
}
} else if (this._iconsetName && this._meta) {
this._iconset = this._meta.byKey(this._iconsetName);
if (this._iconset) {
this._iconset.applyIcon(this, this._iconName, this.theme);
this.unlisten(window, 'iron-iconset-added', '_updateIcon');
} else {
this.listen(window, 'iron-iconset-added', '_updateIcon');
}
}
} else {
if (this._iconset) {
this._iconset.removeIcon(this);
}
if (!this._img) {
this._img = document.createElement('img');
this._img.style.width = '100%';
this._img.style.height = '100%';
this._img.draggable = false;
}
this._img.src = this.src;
Polymer.dom(this.root).appendChild(this._img);
}
}
});
Polymer({
is: 'iron-iconset-svg',
properties: {
name: {
type: String,
observer: '_nameChanged'
},
size: {
type: Number,
value: 24
},
rtlMirroring: {
type: Boolean,
value: false
}
},
attached: function () {
this.style.display = 'none';
},
getIconNames: function () {
this._icons = this._createIconMap();
return Object.keys(this._icons).map(function (n) {
return this.name + ':' + n;
}, this);
},
applyIcon: function (element, iconName) {
element = element.root || element;
this.removeIcon(element);
var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
if (svg) {
var pde = Polymer.dom(element);
pde.insertBefore(svg, pde.childNodes[0]);
return element._svgIcon = svg;
}
return null;
},
removeIcon: function (element) {
element = element.root || element;
if (element._svgIcon) {
Polymer.dom(element).removeChild(element._svgIcon);
element._svgIcon = null;
}
},
_targetIsRTL: function (target) {
if (this.__targetIsRTL == null) {
if (target && target.nodeType !== Node.ELEMENT_NODE) {
target = target.host;
}
this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
}
return this.__targetIsRTL;
},
_nameChanged: function () {
new Polymer.IronMeta({
type: 'iconset',
key: this.name,
value: this
});
this.async(function () {
this.fire('iron-iconset-added', this, { node: window });
});
},
_createIconMap: function () {
var icons = Object.create(null);
Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
icons[icon.id] = icon;
});
return icons;
},
_cloneIcon: function (id, mirrorAllowed) {
this._icons = this._icons || this._createIconMap();
return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
},
_prepareSvgClone: function (sourceSvg, size, mirrorAllowed) {
if (sourceSvg) {
var content = sourceSvg.cloneNode(true), svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size, cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
}
svg.setAttribute('viewBox', viewBox);
svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
svg.setAttribute('focusable', 'false');
svg.style.cssText = cssText;
svg.appendChild(content).removeAttribute('id');
return svg;
}
return null;
}
});
Polymer.IronResizableBehavior = {
properties: {
_parentResizable: {
type: Object,
observer: '_parentResizableChanged'
},
_notifyingDescendant: {
type: Boolean,
value: false
}
},
listeners: { 'iron-request-resize-notifications': '_onIronRequestResizeNotifications' },
created: function () {
this._interestedResizables = [];
this._boundNotifyResize = this.notifyResize.bind(this);
},
attached: function () {
this.fire('iron-request-resize-notifications', null, {
node: this,
bubbles: true,
cancelable: true
});
if (!this._parentResizable) {
window.addEventListener('resize', this._boundNotifyResize);
this.notifyResize();
}
},
detached: function () {
if (this._parentResizable) {
this._parentResizable.stopResizeNotificationsFor(this);
} else {
window.removeEventListener('resize', this._boundNotifyResize);
}
this._parentResizable = null;
},
notifyResize: function () {
if (!this.isAttached) {
return;
}
this._interestedResizables.forEach(function (resizable) {
if (this.resizerShouldNotify(resizable)) {
this._notifyDescendant(resizable);
}
}, this);
this._fireResize();
},
assignParentResizable: function (parentResizable) {
this._parentResizable = parentResizable;
},
stopResizeNotificationsFor: function (target) {
var index = this._interestedResizables.indexOf(target);
if (index > -1) {
this._interestedResizables.splice(index, 1);
this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
}
},
resizerShouldNotify: function (element) {
return true;
},
_onDescendantIronResize: function (event) {
if (this._notifyingDescendant) {
event.stopPropagation();
return;
}
if (!Polymer.Settings.useShadow) {
this._fireResize();
}
},
_fireResize: function () {
this.fire('iron-resize', null, {
node: this,
bubbles: false
});
},
_onIronRequestResizeNotifications: function (event) {
var target = event.path ? event.path[0] : event.target;
if (target === this) {
return;
}
if (this._interestedResizables.indexOf(target) === -1) {
this._interestedResizables.push(target);
this.listen(target, 'iron-resize', '_onDescendantIronResize');
}
target.assignParentResizable(this);
this._notifyDescendant(target);
event.stopPropagation();
},
_parentResizableChanged: function (parentResizable) {
if (parentResizable) {
window.removeEventListener('resize', this._boundNotifyResize);
}
},
_notifyDescendant: function (descendant) {
if (!this.isAttached) {
return;
}
this._notifyingDescendant = true;
descendant.notifyResize();
this._notifyingDescendant = false;
}
};
Polymer.IronSelection = function (selectCallback) {
this.selection = [];
this.selectCallback = selectCallback;
};
Polymer.IronSelection.prototype = {
get: function () {
return this.multi ? this.selection.slice() : this.selection[0];
},
clear: function (excludes) {
this.selection.slice().forEach(function (item) {
if (!excludes || excludes.indexOf(item) < 0) {
this.setItemSelected(item, false);
}
}, this);
},
isSelected: function (item) {
return this.selection.indexOf(item) >= 0;
},
setItemSelected: function (item, isSelected) {
if (item != null) {
if (isSelected !== this.isSelected(item)) {
if (isSelected) {
this.selection.push(item);
} else {
var i = this.selection.indexOf(item);
if (i >= 0) {
this.selection.splice(i, 1);
}
}
if (this.selectCallback) {
this.selectCallback(item, isSelected);
}
}
}
},
select: function (item) {
if (this.multi) {
this.toggle(item);
} else if (this.get() !== item) {
this.setItemSelected(this.get(), false);
this.setItemSelected(item, true);
}
},
toggle: function (item) {
this.setItemSelected(item, !this.isSelected(item));
}
};
Polymer.IronSelectableBehavior = {
properties: {
attrForSelected: {
type: String,
value: null
},
selected: {
type: String,
notify: true
},
selectedItem: {
type: Object,
readOnly: true,
notify: true
},
activateEvent: {
type: String,
value: 'tap',
observer: '_activateEventChanged'
},
selectable: String,
selectedClass: {
type: String,
value: 'iron-selected'
},
selectedAttribute: {
type: String,
value: null
},
fallbackSelection: {
type: String,
value: null
},
items: {
type: Array,
readOnly: true,
notify: true,
value: function () {
return [];
}
},
_excludedLocalNames: {
type: Object,
value: function () {
return { 'template': 1 };
}
}
},
observers: [
'_updateAttrForSelected(attrForSelected)',
'_updateSelected(selected)',
'_checkFallback(fallbackSelection)'
],
created: function () {
this._bindFilterItem = this._filterItem.bind(this);
this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
},
attached: function () {
this._observer = this._observeItems(this);
this._updateItems();
if (!this._shouldUpdateSelection) {
this._updateSelected();
}
this._addListener(this.activateEvent);
},
detached: function () {
if (this._observer) {
Polymer.dom(this).unobserveNodes(this._observer);
}
this._removeListener(this.activateEvent);
},
indexOf: function (item) {
return this.items.indexOf(item);
},
select: function (value) {
this.selected = value;
},
selectPrevious: function () {
var length = this.items.length;
var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
this.selected = this._indexToValue(index);
},
selectNext: function () {
var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
this.selected = this._indexToValue(index);
},
selectIndex: function (index) {
this.select(this._indexToValue(index));
},
forceSynchronousItemUpdate: function () {
this._updateItems();
},
get _shouldUpdateSelection() {
return this.selected != null;
},
_checkFallback: function () {
if (this._shouldUpdateSelection) {
this._updateSelected();
}
},
_addListener: function (eventName) {
this.listen(this, eventName, '_activateHandler');
},
_removeListener: function (eventName) {
this.unlisten(this, eventName, '_activateHandler');
},
_activateEventChanged: function (eventName, old) {
this._removeListener(old);
this._addListener(eventName);
},
_updateItems: function () {
var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
this._setItems(nodes);
},
_updateAttrForSelected: function () {
if (this._shouldUpdateSelection) {
this.selected = this._indexToValue(this.indexOf(this.selectedItem));
}
},
_updateSelected: function () {
this._selectSelected(this.selected);
},
_selectSelected: function (selected) {
this._selection.select(this._valueToItem(this.selected));
if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
this.selected = this.fallbackSelection;
}
},
_filterItem: function (node) {
return !this._excludedLocalNames[node.localName];
},
_valueToItem: function (value) {
return value == null ? null : this.items[this._valueToIndex(value)];
},
_valueToIndex: function (value) {
if (this.attrForSelected) {
for (var i = 0, item; item = this.items[i]; i++) {
if (this._valueForItem(item) == value) {
return i;
}
}
} else {
return Number(value);
}
},
_indexToValue: function (index) {
if (this.attrForSelected) {
var item = this.items[index];
if (item) {
return this._valueForItem(item);
}
} else {
return index;
}
},
_valueForItem: function (item) {
var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
},
_applySelection: function (item, isSelected) {
if (this.selectedClass) {
this.toggleClass(this.selectedClass, isSelected, item);
}
if (this.selectedAttribute) {
this.toggleAttribute(this.selectedAttribute, isSelected, item);
}
this._selectionChange();
this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
},
_selectionChange: function () {
this._setSelectedItem(this._selection.get());
},
_observeItems: function (node) {
return Polymer.dom(node).observeNodes(function (mutation) {
this._updateItems();
if (this._shouldUpdateSelection) {
this._updateSelected();
}
this.fire('iron-items-changed', mutation, {
bubbles: false,
cancelable: false
});
});
},
_activateHandler: function (e) {
var t = e.target;
var items = this.items;
while (t && t != this) {
var i = items.indexOf(t);
if (i >= 0) {
var value = this._indexToValue(i);
this._itemActivate(value, t);
return;
}
t = t.parentNode;
}
},
_itemActivate: function (value, item) {
if (!this.fire('iron-activate', {
selected: value,
item: item
}, { cancelable: true }).defaultPrevented) {
this.select(value);
}
}
};
Polymer({
is: 'iron-pages',
behaviors: [
Polymer.IronResizableBehavior,
Polymer.IronSelectableBehavior
],
properties: {
activateEvent: {
type: String,
value: null
}
},
observers: ['_selectedPageChanged(selected)'],
_selectedPageChanged: function (selected, old) {
this.async(this.notifyResize);
}
});
Polymer({
is: 'paper-material',
properties: {
elevation: {
type: Number,
reflectToAttribute: true,
value: 1
},
animated: {
type: Boolean,
reflectToAttribute: true,
value: false
}
}
});
(function () {
'use strict';
var KEY_IDENTIFIER = {
'U+0008': 'backspace',
'U+0009': 'tab',
'U+001B': 'esc',
'U+0020': 'space',
'U+007F': 'del'
};
var KEY_CODE = {
8: 'backspace',
9: 'tab',
13: 'enter',
27: 'esc',
33: 'pageup',
34: 'pagedown',
35: 'end',
36: 'home',
32: 'space',
37: 'left',
38: 'up',
39: 'right',
40: 'down',
46: 'del',
106: '*'
};
var MODIFIER_KEYS = {
'shift': 'shiftKey',
'ctrl': 'ctrlKey',
'alt': 'altKey',
'meta': 'metaKey'
};
var KEY_CHAR = /[a-z0-9*]/;
var IDENT_CHAR = /U\+/;
var ARROW_KEY = /^arrow/;
var SPACE_KEY = /^space(bar)?/;
var ESC_KEY = /^escape$/;
function transformKey(key, noSpecialChars) {
var validKey = '';
if (key) {
var lKey = key.toLowerCase();
if (lKey === ' ' || SPACE_KEY.test(lKey)) {
validKey = 'space';
} else if (ESC_KEY.test(lKey)) {
validKey = 'esc';
} else if (lKey.length == 1) {
if (!noSpecialChars || KEY_CHAR.test(lKey)) {
validKey = lKey;
}
} else if (ARROW_KEY.test(lKey)) {
validKey = lKey.replace('arrow', '');
} else if (lKey == 'multiply') {
validKey = '*';
} else {
validKey = lKey;
}
}
return validKey;
}
function transformKeyIdentifier(keyIdent) {
var validKey = '';
if (keyIdent) {
if (keyIdent in KEY_IDENTIFIER) {
validKey = KEY_IDENTIFIER[keyIdent];
} else if (IDENT_CHAR.test(keyIdent)) {
keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
validKey = String.fromCharCode(keyIdent).toLowerCase();
} else {
validKey = keyIdent.toLowerCase();
}
}
return validKey;
}
function transformKeyCode(keyCode) {
var validKey = '';
if (Number(keyCode)) {
if (keyCode >= 65 && keyCode <= 90) {
validKey = String.fromCharCode(32 + keyCode);
} else if (keyCode >= 112 && keyCode <= 123) {
validKey = 'f' + (keyCode - 112);
} else if (keyCode >= 48 && keyCode <= 57) {
validKey = String(keyCode - 48);
} else if (keyCode >= 96 && keyCode <= 105) {
validKey = String(keyCode - 96);
} else {
validKey = KEY_CODE[keyCode];
}
}
return validKey;
}
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
if (keyEvent.key) {
return transformKey(keyEvent.key, noSpecialChars);
}
if (keyEvent.detail && keyEvent.detail.key) {
return transformKey(keyEvent.detail.key, noSpecialChars);
}
return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
}
function keyComboMatchesEvent(keyCombo, event) {
var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
}
function parseKeyComboString(keyComboString) {
if (keyComboString.length === 1) {
return {
combo: keyComboString,
key: keyComboString,
event: 'keydown'
};
}
return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
var eventParts = keyComboPart.split(':');
var keyName = eventParts[0];
var event = eventParts[1];
if (keyName in MODIFIER_KEYS) {
parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
parsedKeyCombo.hasModifiers = true;
} else {
parsedKeyCombo.key = keyName;
parsedKeyCombo.event = event || 'keydown';
}
return parsedKeyCombo;
}, { combo: keyComboString.split(':').shift() });
}
function parseEventString(eventString) {
return eventString.trim().split(' ').map(function (keyComboString) {
return parseKeyComboString(keyComboString);
});
}
Polymer.IronA11yKeysBehavior = {
properties: {
keyEventTarget: {
type: Object,
value: function () {
return this;
}
},
stopKeyboardEventPropagation: {
type: Boolean,
value: false
},
_boundKeyHandlers: {
type: Array,
value: function () {
return [];
}
},
_imperativeKeyBindings: {
type: Object,
value: function () {
return {};
}
}
},
observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],
keyBindings: {},
registered: function () {
this._prepKeyBindings();
},
attached: function () {
this._listenKeyEventListeners();
},
detached: function () {
this._unlistenKeyEventListeners();
},
addOwnKeyBinding: function (eventString, handlerName) {
this._imperativeKeyBindings[eventString] = handlerName;
this._prepKeyBindings();
this._resetKeyEventListeners();
},
removeOwnKeyBindings: function () {
this._imperativeKeyBindings = {};
this._prepKeyBindings();
this._resetKeyEventListeners();
},
keyboardEventMatchesKeys: function (event, eventString) {
var keyCombos = parseEventString(eventString);
for (var i = 0; i < keyCombos.length; ++i) {
if (keyComboMatchesEvent(keyCombos[i], event)) {
return true;
}
}
return false;
},
_collectKeyBindings: function () {
var keyBindings = this.behaviors.map(function (behavior) {
return behavior.keyBindings;
});
if (keyBindings.indexOf(this.keyBindings) === -1) {
keyBindings.push(this.keyBindings);
}
return keyBindings;
},
_prepKeyBindings: function () {
this._keyBindings = {};
this._collectKeyBindings().forEach(function (keyBindings) {
for (var eventString in keyBindings) {
this._addKeyBinding(eventString, keyBindings[eventString]);
}
}, this);
for (var eventString in this._imperativeKeyBindings) {
this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
}
for (var eventName in this._keyBindings) {
this._keyBindings[eventName].sort(function (kb1, kb2) {
var b1 = kb1[0].hasModifiers;
var b2 = kb2[0].hasModifiers;
return b1 === b2 ? 0 : b1 ? -1 : 1;
});
}
},
_addKeyBinding: function (eventString, handlerName) {
parseEventString(eventString).forEach(function (keyCombo) {
this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];
this._keyBindings[keyCombo.event].push([
keyCombo,
handlerName
]);
}, this);
},
_resetKeyEventListeners: function () {
this._unlistenKeyEventListeners();
if (this.isAttached) {
this._listenKeyEventListeners();
}
},
_listenKeyEventListeners: function () {
if (!this.keyEventTarget) {
return;
}
Object.keys(this._keyBindings).forEach(function (eventName) {
var keyBindings = this._keyBindings[eventName];
var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);
this._boundKeyHandlers.push([
this.keyEventTarget,
eventName,
boundKeyHandler
]);
this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
}, this);
},
_unlistenKeyEventListeners: function () {
var keyHandlerTuple;
var keyEventTarget;
var eventName;
var boundKeyHandler;
while (this._boundKeyHandlers.length) {
keyHandlerTuple = this._boundKeyHandlers.pop();
keyEventTarget = keyHandlerTuple[0];
eventName = keyHandlerTuple[1];
boundKeyHandler = keyHandlerTuple[2];
keyEventTarget.removeEventListener(eventName, boundKeyHandler);
}
},
_onKeyBindingEvent: function (keyBindings, event) {
if (this.stopKeyboardEventPropagation) {
event.stopPropagation();
}
if (event.defaultPrevented) {
return;
}
for (var i = 0; i < keyBindings.length; i++) {
var keyCombo = keyBindings[i][0];
var handlerName = keyBindings[i][1];
if (keyComboMatchesEvent(keyCombo, event)) {
this._triggerKeyHandler(keyCombo, handlerName, event);
if (event.defaultPrevented) {
return;
}
}
}
},
_triggerKeyHandler: function (keyCombo, handlerName, keyboardEvent) {
var detail = Object.create(keyCombo);
detail.keyboardEvent = keyboardEvent;
var event = new CustomEvent(keyCombo.event, {
detail: detail,
cancelable: true
});
this[handlerName].call(this, event);
if (event.defaultPrevented) {
keyboardEvent.preventDefault();
}
}
};
}());
Polymer.IronControlState = {
properties: {
focused: {
type: Boolean,
value: false,
notify: true,
readOnly: true,
reflectToAttribute: true
},
disabled: {
type: Boolean,
value: false,
notify: true,
observer: '_disabledChanged',
reflectToAttribute: true
},
_oldTabIndex: { type: Number },
_boundFocusBlurHandler: {
type: Function,
value: function () {
return this._focusBlurHandler.bind(this);
}
}
},
observers: ['_changedControlState(focused, disabled)'],
ready: function () {
this.addEventListener('focus', this._boundFocusBlurHandler, true);
this.addEventListener('blur', this._boundFocusBlurHandler, true);
},
_focusBlurHandler: function (event) {
if (event.target === this) {
this._setFocused(event.type === 'focus');
} else if (!this.shadowRoot) {
var target = Polymer.dom(event).localTarget;
if (!this.isLightDescendant(target)) {
this.fire(event.type, { sourceEvent: event }, {
node: this,
bubbles: event.bubbles,
cancelable: event.cancelable
});
}
}
},
_disabledChanged: function (disabled, old) {
this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
this.style.pointerEvents = disabled ? 'none' : '';
if (disabled) {
this._oldTabIndex = this.tabIndex;
this._setFocused(false);
this.tabIndex = -1;
this.blur();
} else if (this._oldTabIndex !== undefined) {
this.tabIndex = this._oldTabIndex;
}
},
_changedControlState: function () {
if (this._controlStateChanged) {
this._controlStateChanged();
}
}
};
Polymer.IronButtonStateImpl = {
properties: {
pressed: {
type: Boolean,
readOnly: true,
value: false,
reflectToAttribute: true,
observer: '_pressedChanged'
},
toggles: {
type: Boolean,
value: false,
reflectToAttribute: true
},
active: {
type: Boolean,
value: false,
notify: true,
reflectToAttribute: true
},
pointerDown: {
type: Boolean,
readOnly: true,
value: false
},
receivedFocusFromKeyboard: {
type: Boolean,
readOnly: true
},
ariaActiveAttribute: {
type: String,
value: 'aria-pressed',
observer: '_ariaActiveAttributeChanged'
}
},
listeners: {
down: '_downHandler',
up: '_upHandler',
tap: '_tapHandler'
},
observers: [
'_focusChanged(focused)',
'_activeChanged(active, ariaActiveAttribute)'
],
keyBindings: {
'enter:keydown': '_asyncClick',
'space:keydown': '_spaceKeyDownHandler',
'space:keyup': '_spaceKeyUpHandler'
},
_mouseEventRe: /^mouse/,
_tapHandler: function () {
if (this.toggles) {
this._userActivate(!this.active);
} else {
this.active = false;
}
},
_focusChanged: function (focused) {
this._detectKeyboardFocus(focused);
if (!focused) {
this._setPressed(false);
}
},
_detectKeyboardFocus: function (focused) {
this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
},
_userActivate: function (active) {
if (this.active !== active) {
this.active = active;
this.fire('change');
}
},
_downHandler: function (event) {
this._setPointerDown(true);
this._setPressed(true);
this._setReceivedFocusFromKeyboard(false);
},
_upHandler: function () {
this._setPointerDown(false);
this._setPressed(false);
},
_spaceKeyDownHandler: function (event) {
var keyboardEvent = event.detail.keyboardEvent;
var target = Polymer.dom(keyboardEvent).localTarget;
if (this.isLightDescendant(target))
return;
keyboardEvent.preventDefault();
keyboardEvent.stopImmediatePropagation();
this._setPressed(true);
},
_spaceKeyUpHandler: function (event) {
var keyboardEvent = event.detail.keyboardEvent;
var target = Polymer.dom(keyboardEvent).localTarget;
if (this.isLightDescendant(target))
return;
if (this.pressed) {
this._asyncClick();
}
this._setPressed(false);
},
_asyncClick: function () {
this.async(function () {
this.click();
}, 1);
},
_pressedChanged: function (pressed) {
this._changedButtonState();
},
_ariaActiveAttributeChanged: function (value, oldValue) {
if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
this.removeAttribute(oldValue);
}
},
_activeChanged: function (active, ariaActiveAttribute) {
if (this.toggles) {
this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
} else {
this.removeAttribute(this.ariaActiveAttribute);
}
this._changedButtonState();
},
_controlStateChanged: function () {
if (this.disabled) {
this._setPressed(false);
} else {
this._changedButtonState();
}
},
_changedButtonState: function () {
if (this._buttonStateChanged) {
this._buttonStateChanged();
}
}
};
Polymer.IronButtonState = [
Polymer.IronA11yKeysBehavior,
Polymer.IronButtonStateImpl
];
(function () {
var Utility = {
distance: function (x1, y1, x2, y2) {
var xDelta = x1 - x2;
var yDelta = y1 - y2;
return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
},
now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
};
function ElementMetrics(element) {
this.element = element;
this.width = this.boundingRect.width;
this.height = this.boundingRect.height;
this.size = Math.max(this.width, this.height);
}
ElementMetrics.prototype = {
get boundingRect() {
return this.element.getBoundingClientRect();
},
furthestCornerDistanceFrom: function (x, y) {
var topLeft = Utility.distance(x, y, 0, 0);
var topRight = Utility.distance(x, y, this.width, 0);
var bottomLeft = Utility.distance(x, y, 0, this.height);
var bottomRight = Utility.distance(x, y, this.width, this.height);
return Math.max(topLeft, topRight, bottomLeft, bottomRight);
}
};
function Ripple(element) {
this.element = element;
this.color = window.getComputedStyle(element).color;
this.wave = document.createElement('div');
this.waveContainer = document.createElement('div');
this.wave.style.backgroundColor = this.color;
this.wave.classList.add('wave');
this.waveContainer.classList.add('wave-container');
Polymer.dom(this.waveContainer).appendChild(this.wave);
this.resetInteractionState();
}
Ripple.MAX_RADIUS = 300;
Ripple.prototype = {
get recenters() {
return this.element.recenters;
},
get center() {
return this.element.center;
},
get mouseDownElapsed() {
var elapsed;
if (!this.mouseDownStart) {
return 0;
}
elapsed = Utility.now() - this.mouseDownStart;
if (this.mouseUpStart) {
elapsed -= this.mouseUpElapsed;
}
return elapsed;
},
get mouseUpElapsed() {
return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
},
get mouseDownElapsedSeconds() {
return this.mouseDownElapsed / 1000;
},
get mouseUpElapsedSeconds() {
return this.mouseUpElapsed / 1000;
},
get mouseInteractionSeconds() {
return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
},
get initialOpacity() {
return this.element.initialOpacity;
},
get opacityDecayVelocity() {
return this.element.opacityDecayVelocity;
},
get radius() {
var width2 = this.containerMetrics.width * this.containerMetrics.width;
var height2 = this.containerMetrics.height * this.containerMetrics.height;
var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;
var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
var timeNow = this.mouseInteractionSeconds / duration;
var size = waveRadius * (1 - Math.pow(80, -timeNow));
return Math.abs(size);
},
get opacity() {
if (!this.mouseUpStart) {
return this.initialOpacity;
}
return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
},
get outerOpacity() {
var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
var waveOpacity = this.opacity;
return Math.max(0, Math.min(outerOpacity, waveOpacity));
},
get isOpacityFullyDecayed() {
return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
},
get isRestingAtMaxRadius() {
return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
},
get isAnimationComplete() {
return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
},
get translationFraction() {
return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
},
get xNow() {
if (this.xEnd) {
return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
}
return this.xStart;
},
get yNow() {
if (this.yEnd) {
return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
}
return this.yStart;
},
get isMouseDown() {
return this.mouseDownStart && !this.mouseUpStart;
},
resetInteractionState: function () {
this.maxRadius = 0;
this.mouseDownStart = 0;
this.mouseUpStart = 0;
this.xStart = 0;
this.yStart = 0;
this.xEnd = 0;
this.yEnd = 0;
this.slideDistance = 0;
this.containerMetrics = new ElementMetrics(this.element);
},
draw: function () {
var scale;
var translateString;
var dx;
var dy;
this.wave.style.opacity = this.opacity;
scale = this.radius / (this.containerMetrics.size / 2);
dx = this.xNow - this.containerMetrics.width / 2;
dy = this.yNow - this.containerMetrics.height / 2;
this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
},
downAction: function (event) {
var xCenter = this.containerMetrics.width / 2;
var yCenter = this.containerMetrics.height / 2;
this.resetInteractionState();
this.mouseDownStart = Utility.now();
if (this.center) {
this.xStart = xCenter;
this.yStart = yCenter;
this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
} else {
this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
}
if (this.recenters) {
this.xEnd = xCenter;
this.yEnd = yCenter;
this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
}
this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);
this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';
this.waveContainer.style.width = this.containerMetrics.size + 'px';
this.waveContainer.style.height = this.containerMetrics.size + 'px';
},
upAction: function (event) {
if (!this.isMouseDown) {
return;
}
this.mouseUpStart = Utility.now();
},
remove: function () {
Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
}
};
Polymer({
is: 'paper-ripple',
behaviors: [Polymer.IronA11yKeysBehavior],
properties: {
initialOpacity: {
type: Number,
value: 0.25
},
opacityDecayVelocity: {
type: Number,
value: 0.8
},
recenters: {
type: Boolean,
value: false
},
center: {
type: Boolean,
value: false
},
ripples: {
type: Array,
value: function () {
return [];
}
},
animating: {
type: Boolean,
readOnly: true,
reflectToAttribute: true,
value: false
},
holdDown: {
type: Boolean,
value: false,
observer: '_holdDownChanged'
},
noink: {
type: Boolean,
value: false
},
_animating: { type: Boolean },
_boundAnimate: {
type: Function,
value: function () {
return this.animate.bind(this);
}
}
},
get target() {
return this.keyEventTarget;
},
keyBindings: {
'enter:keydown': '_onEnterKeydown',
'space:keydown': '_onSpaceKeydown',
'space:keyup': '_onSpaceKeyup'
},
attached: function () {
if (this.parentNode.nodeType == 11) {
this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
} else {
this.keyEventTarget = this.parentNode;
}
var keyEventTarget = this.keyEventTarget;
this.listen(keyEventTarget, 'up', 'uiUpAction');
this.listen(keyEventTarget, 'down', 'uiDownAction');
},
detached: function () {
this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
this.keyEventTarget = null;
},
get shouldKeepAnimating() {
for (var index = 0; index < this.ripples.length; ++index) {
if (!this.ripples[index].isAnimationComplete) {
return true;
}
}
return false;
},
simulatedRipple: function () {
this.downAction(null);
this.async(function () {
this.upAction();
}, 1);
},
uiDownAction: function (event) {
if (!this.noink) {
this.downAction(event);
}
},
downAction: function (event) {
if (this.holdDown && this.ripples.length > 0) {
return;
}
var ripple = this.addRipple();
ripple.downAction(event);
if (!this._animating) {
this._animating = true;
this.animate();
}
},
uiUpAction: function (event) {
if (!this.noink) {
this.upAction(event);
}
},
upAction: function (event) {
if (this.holdDown) {
return;
}
this.ripples.forEach(function (ripple) {
ripple.upAction(event);
});
this._animating = true;
this.animate();
},
onAnimationComplete: function () {
this._animating = false;
this.$.background.style.backgroundColor = null;
this.fire('transitionend');
},
addRipple: function () {
var ripple = new Ripple(this);
Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
this.$.background.style.backgroundColor = ripple.color;
this.ripples.push(ripple);
this._setAnimating(true);
return ripple;
},
removeRipple: function (ripple) {
var rippleIndex = this.ripples.indexOf(ripple);
if (rippleIndex < 0) {
return;
}
this.ripples.splice(rippleIndex, 1);
ripple.remove();
if (!this.ripples.length) {
this._setAnimating(false);
}
},
animate: function () {
if (!this._animating) {
return;
}
var index;
var ripple;
for (index = 0; index < this.ripples.length; ++index) {
ripple = this.ripples[index];
ripple.draw();
this.$.background.style.opacity = ripple.outerOpacity;
if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
this.removeRipple(ripple);
}
}
if (!this.shouldKeepAnimating && this.ripples.length === 0) {
this.onAnimationComplete();
} else {
window.requestAnimationFrame(this._boundAnimate);
}
},
_onEnterKeydown: function () {
this.uiDownAction();
this.async(this.uiUpAction, 1);
},
_onSpaceKeydown: function () {
this.uiDownAction();
},
_onSpaceKeyup: function () {
this.uiUpAction();
},
_holdDownChanged: function (newVal, oldVal) {
if (oldVal === undefined) {
return;
}
if (newVal) {
this.downAction();
} else {
this.upAction();
}
}
});
}());
Polymer.PaperRippleBehavior = {
properties: {
noink: {
type: Boolean,
observer: '_noinkChanged'
},
_rippleContainer: { type: Object }
},
_buttonStateChanged: function () {
if (this.focused) {
this.ensureRipple();
}
},
_downHandler: function (event) {
Polymer.IronButtonStateImpl._downHandler.call(this, event);
if (this.pressed) {
this.ensureRipple(event);
}
},
ensureRipple: function (optTriggeringEvent) {
if (!this.hasRipple()) {
this._ripple = this._createRipple();
this._ripple.noink = this.noink;
var rippleContainer = this._rippleContainer || this.root;
if (rippleContainer) {
Polymer.dom(rippleContainer).appendChild(this._ripple);
}
if (optTriggeringEvent) {
var domContainer = Polymer.dom(this._rippleContainer || this);
var target = Polymer.dom(optTriggeringEvent).rootTarget;
if (domContainer.deepContains(target)) {
this._ripple.uiDownAction(optTriggeringEvent);
}
}
}
},
getRipple: function () {
this.ensureRipple();
return this._ripple;
},
hasRipple: function () {
return Boolean(this._ripple);
},
_createRipple: function () {
return document.createElement('paper-ripple');
},
_noinkChanged: function (noink) {
if (this.hasRipple()) {
this._ripple.noink = noink;
}
}
};
Polymer.PaperInkyFocusBehaviorImpl = {
observers: ['_focusedChanged(receivedFocusFromKeyboard)'],
_focusedChanged: function (receivedFocusFromKeyboard) {
if (receivedFocusFromKeyboard) {
this.ensureRipple();
}
if (this.hasRipple()) {
this._ripple.holdDown = receivedFocusFromKeyboard;
}
},
_createRipple: function () {
var ripple = Polymer.PaperRippleBehavior._createRipple();
ripple.id = 'ink';
ripple.setAttribute('center', '');
ripple.classList.add('circle');
return ripple;
}
};
Polymer.PaperInkyFocusBehavior = [
Polymer.IronButtonState,
Polymer.IronControlState,
Polymer.PaperRippleBehavior,
Polymer.PaperInkyFocusBehaviorImpl
];
Polymer({
is: 'paper-icon-button',
hostAttributes: {
role: 'button',
tabindex: '0'
},
behaviors: [Polymer.PaperInkyFocusBehavior],
properties: {
src: { type: String },
icon: { type: String },
alt: {
type: String,
observer: '_altChanged'
}
},
_altChanged: function (newValue, oldValue) {
var label = this.getAttribute('aria-label');
if (!label || oldValue == label) {
this.setAttribute('aria-label', newValue);
}
}
});
console.warn('This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead');
console.warn('This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead');
Polymer.IronMultiSelectableBehaviorImpl = {
properties: {
multi: {
type: Boolean,
value: false,
observer: 'multiChanged'
},
selectedValues: {
type: Array,
notify: true
},
selectedItems: {
type: Array,
readOnly: true,
notify: true
}
},
observers: ['_updateSelected(selectedValues.splices)'],
select: function (value) {
if (this.multi) {
if (this.selectedValues) {
this._toggleSelected(value);
} else {
this.selectedValues = [value];
}
} else {
this.selected = value;
}
},
multiChanged: function (multi) {
this._selection.multi = multi;
},
get _shouldUpdateSelection() {
return this.selected != null || this.selectedValues != null && this.selectedValues.length;
},
_updateAttrForSelected: function () {
if (!this.multi) {
Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
} else if (this._shouldUpdateSelection) {
this.selectedValues = this.selectedItems.map(function (selectedItem) {
return this._indexToValue(this.indexOf(selectedItem));
}, this).filter(function (unfilteredValue) {
return unfilteredValue != null;
}, this);
}
},
_updateSelected: function () {
if (this.multi) {
this._selectMulti(this.selectedValues);
} else {
this._selectSelected(this.selected);
}
},
_selectMulti: function (values) {
if (values) {
var selectedItems = this._valuesToItems(values);
this._selection.clear(selectedItems);
for (var i = 0; i < selectedItems.length; i++) {
this._selection.setItemSelected(selectedItems[i], true);
}
if (this.fallbackSelection && this.items.length && !this._selection.get().length) {
var fallback = this._valueToItem(this.fallbackSelection);
if (fallback) {
this.selectedValues = [this.fallbackSelection];
}
}
} else {
this._selection.clear();
}
},
_selectionChange: function () {
var s = this._selection.get();
if (this.multi) {
this._setSelectedItems(s);
} else {
this._setSelectedItems([s]);
this._setSelectedItem(s);
}
},
_toggleSelected: function (value) {
var i = this.selectedValues.indexOf(value);
var unselected = i < 0;
if (unselected) {
this.push('selectedValues', value);
} else {
this.splice('selectedValues', i, 1);
}
},
_valuesToItems: function (values) {
return values == null ? null : values.map(function (value) {
return this._valueToItem(value);
}, this);
}
};
Polymer.IronMultiSelectableBehavior = [
Polymer.IronSelectableBehavior,
Polymer.IronMultiSelectableBehaviorImpl
];
Polymer.IronMenuBehaviorImpl = {
properties: {
focusedItem: {
observer: '_focusedItemChanged',
readOnly: true,
type: Object
},
attrForItemTitle: { type: String },
disabled: {
type: Boolean,
value: false,
observer: '_disabledChanged'
}
},
_SEARCH_RESET_TIMEOUT_MS: 1000,
_previousTabIndex: 0,
hostAttributes: { 'role': 'menu' },
observers: ['_updateMultiselectable(multi)'],
listeners: {
'focus': '_onFocus',
'keydown': '_onKeydown',
'iron-items-changed': '_onIronItemsChanged'
},
keyBindings: {
'up': '_onUpKey',
'down': '_onDownKey',
'esc': '_onEscKey',
'shift+tab:keydown': '_onShiftTabDown'
},
attached: function () {
this._resetTabindices();
},
select: function (value) {
if (this._defaultFocusAsync) {
this.cancelAsync(this._defaultFocusAsync);
this._defaultFocusAsync = null;
}
var item = this._valueToItem(value);
if (item && item.hasAttribute('disabled'))
return;
this._setFocusedItem(item);
Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
},
_resetTabindices: function () {
var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
this.items.forEach(function (item) {
item.setAttribute('tabindex', item === selectedItem ? '0' : '-1');
}, this);
},
_updateMultiselectable: function (multi) {
if (multi) {
this.setAttribute('aria-multiselectable', 'true');
} else {
this.removeAttribute('aria-multiselectable');
}
},
_focusWithKeyboardEvent: function (event) {
this.cancelDebouncer('_clearSearchText');
var searchText = this._searchText || '';
var key = event.key && event.key.length == 1 ? event.key : String.fromCharCode(event.keyCode);
searchText += key.toLocaleLowerCase();
var searchLength = searchText.length;
for (var i = 0, item; item = this.items[i]; i++) {
if (item.hasAttribute('disabled')) {
continue;
}
var attr = this.attrForItemTitle || 'textContent';
var title = (item[attr] || item.getAttribute(attr) || '').trim();
if (title.length < searchLength) {
continue;
}
if (title.slice(0, searchLength).toLocaleLowerCase() == searchText) {
this._setFocusedItem(item);
break;
}
}
this._searchText = searchText;
this.debounce('_clearSearchText', this._clearSearchText, this._SEARCH_RESET_TIMEOUT_MS);
},
_clearSearchText: function () {
this._searchText = '';
},
_focusPrevious: function () {
var length = this.items.length;
var curFocusIndex = Number(this.indexOf(this.focusedItem));
for (var i = 1; i < length + 1; i++) {
var item = this.items[(curFocusIndex - i + length) % length];
if (!item.hasAttribute('disabled')) {
var owner = Polymer.dom(item).getOwnerRoot() || document;
this._setFocusedItem(item);
if (Polymer.dom(owner).activeElement == item) {
return;
}
}
}
},
_focusNext: function () {
var length = this.items.length;
var curFocusIndex = Number(this.indexOf(this.focusedItem));
for (var i = 1; i < length + 1; i++) {
var item = this.items[(curFocusIndex + i) % length];
if (!item.hasAttribute('disabled')) {
var owner = Polymer.dom(item).getOwnerRoot() || document;
this._setFocusedItem(item);
if (Polymer.dom(owner).activeElement == item) {
return;
}
}
}
},
_applySelection: function (item, isSelected) {
if (isSelected) {
item.setAttribute('aria-selected', 'true');
} else {
item.removeAttribute('aria-selected');
}
Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
},
_focusedItemChanged: function (focusedItem, old) {
old && old.setAttribute('tabindex', '-1');
if (focusedItem && !focusedItem.hasAttribute('disabled') && !this.disabled) {
focusedItem.setAttribute('tabindex', '0');
focusedItem.focus();
}
},
_onIronItemsChanged: function (event) {
if (event.detail.addedNodes.length) {
this._resetTabindices();
}
},
_onShiftTabDown: function (event) {
var oldTabIndex = this.getAttribute('tabindex');
Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;
this._setFocusedItem(null);
this.setAttribute('tabindex', '-1');
this.async(function () {
this.setAttribute('tabindex', oldTabIndex);
Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
}, 1);
},
_onFocus: function (event) {
if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
return;
}
var rootTarget = Polymer.dom(event).rootTarget;
if (rootTarget !== this && typeof rootTarget.tabIndex !== 'undefined' && !this.isLightDescendant(rootTarget)) {
return;
}
this._defaultFocusAsync = this.async(function () {
var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
this._setFocusedItem(null);
if (selectedItem) {
this._setFocusedItem(selectedItem);
} else if (this.items[0]) {
this._focusNext();
}
});
},
_onUpKey: function (event) {
this._focusPrevious();
event.detail.keyboardEvent.preventDefault();
},
_onDownKey: function (event) {
this._focusNext();
event.detail.keyboardEvent.preventDefault();
},
_onEscKey: function (event) {
this.focusedItem.blur();
},
_onKeydown: function (event) {
if (!this.keyboardEventMatchesKeys(event, 'up down esc')) {
this._focusWithKeyboardEvent(event);
}
event.stopPropagation();
},
_activateHandler: function (event) {
Polymer.IronSelectableBehavior._activateHandler.call(this, event);
event.stopPropagation();
},
_disabledChanged: function (disabled) {
if (disabled) {
this._previousTabIndex = this.hasAttribute('tabindex') ? this.tabIndex : 0;
this.removeAttribute('tabindex');
} else if (!this.hasAttribute('tabindex')) {
this.setAttribute('tabindex', this._previousTabIndex);
}
}
};
Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
Polymer.IronMenuBehavior = [
Polymer.IronMultiSelectableBehavior,
Polymer.IronA11yKeysBehavior,
Polymer.IronMenuBehaviorImpl
];
(function () {
Polymer({
is: 'paper-menu',
behaviors: [Polymer.IronMenuBehavior]
});
}());
Polymer.PaperItemBehaviorImpl = {
hostAttributes: {
role: 'option',
tabindex: '0'
}
};
Polymer.PaperItemBehavior = [
Polymer.IronButtonState,
Polymer.IronControlState,
Polymer.PaperItemBehaviorImpl
];
Polymer({
is: 'paper-item',
behaviors: [Polymer.PaperItemBehavior]
});
Polymer.PaperButtonBehaviorImpl = {
properties: {
elevation: {
type: Number,
reflectToAttribute: true,
readOnly: true
}
},
observers: [
'_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
'_computeKeyboardClass(receivedFocusFromKeyboard)'
],
hostAttributes: {
role: 'button',
tabindex: '0',
animated: true
},
_calculateElevation: function () {
var e = 1;
if (this.disabled) {
e = 0;
} else if (this.active || this.pressed) {
e = 4;
} else if (this.receivedFocusFromKeyboard) {
e = 3;
}
this._setElevation(e);
},
_computeKeyboardClass: function (receivedFocusFromKeyboard) {
this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
},
_spaceKeyDownHandler: function (event) {
Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, event);
if (this.hasRipple() && this.getRipple().ripples.length < 1) {
this._ripple.uiDownAction();
}
},
_spaceKeyUpHandler: function (event) {
Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, event);
if (this.hasRipple()) {
this._ripple.uiUpAction();
}
}
};
Polymer.PaperButtonBehavior = [
Polymer.IronButtonState,
Polymer.IronControlState,
Polymer.PaperRippleBehavior,
Polymer.PaperButtonBehaviorImpl
];
Polymer({
is: 'paper-button',
behaviors: [Polymer.PaperButtonBehavior],
properties: {
raised: {
type: Boolean,
reflectToAttribute: true,
value: false,
observer: '_calculateElevation'
}
},
_calculateElevation: function () {
if (!this.raised) {
this._setElevation(0);
} else {
Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
}
}
});
Polymer.IronFormElementBehavior = {
properties: {
name: { type: String },
value: {
notify: true,
type: String
},
required: {
type: Boolean,
value: false
},
_parentForm: { type: Object }
},
attached: function () {
this.fire('iron-form-element-register');
},
detached: function () {
if (this._parentForm) {
this._parentForm.fire('iron-form-element-unregister', { target: this });
}
}
};
Polymer.IronValidatableBehaviorMeta = null;
Polymer.IronValidatableBehavior = {
properties: {
validator: { type: String },
invalid: {
notify: true,
reflectToAttribute: true,
type: Boolean,
value: false
},
_validatorMeta: { type: Object },
validatorType: {
type: String,
value: 'validator'
},
_validator: {
type: Object,
computed: '__computeValidator(validator)'
}
},
observers: ['_invalidChanged(invalid)'],
registered: function () {
Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({ type: 'validator' });
},
_invalidChanged: function () {
if (this.invalid) {
this.setAttribute('aria-invalid', 'true');
} else {
this.removeAttribute('aria-invalid');
}
},
hasValidator: function () {
return this._validator != null;
},
validate: function (value) {
this.invalid = !this._getValidity(value);
return !this.invalid;
},
_getValidity: function (value) {
if (this.hasValidator()) {
return this._validator.validate(value);
}
return true;
},
__computeValidator: function () {
return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator);
}
};
(function () {
'use strict';
Polymer.IronA11yAnnouncer = Polymer({
is: 'iron-a11y-announcer',
properties: {
mode: {
type: String,
value: 'polite'
},
_text: {
type: String,
value: ''
}
},
created: function () {
if (!Polymer.IronA11yAnnouncer.instance) {
Polymer.IronA11yAnnouncer.instance = this;
}
document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
},
announce: function (text) {
this._text = '';
this.async(function () {
this._text = text;
}, 100);
},
_onIronAnnounce: function (event) {
if (event.detail && event.detail.text) {
this.announce(event.detail.text);
}
}
});
Polymer.IronA11yAnnouncer.instance = null;
Polymer.IronA11yAnnouncer.requestAvailability = function () {
if (!Polymer.IronA11yAnnouncer.instance) {
Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
}
document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
};
}());
Polymer({
is: 'iron-input',
extends: 'input',
behaviors: [Polymer.IronValidatableBehavior],
properties: {
bindValue: {
observer: '_bindValueChanged',
type: String
},
preventInvalidInput: { type: Boolean },
allowedPattern: {
type: String,
observer: '_allowedPatternChanged'
},
_previousValidInput: {
type: String,
value: ''
},
_patternAlreadyChecked: {
type: Boolean,
value: false
}
},
listeners: {
'input': '_onInput',
'keypress': '_onKeypress'
},
registered: function () {
if (!this._canDispatchEventOnDisabled()) {
this._origDispatchEvent = this.dispatchEvent;
this.dispatchEvent = this._dispatchEventFirefoxIE;
}
},
created: function () {
Polymer.IronA11yAnnouncer.requestAvailability();
},
_canDispatchEventOnDisabled: function () {
var input = document.createElement('input');
var canDispatch = false;
input.disabled = true;
input.addEventListener('feature-check-dispatch-event', function () {
canDispatch = true;
});
try {
input.dispatchEvent(new Event('feature-check-dispatch-event'));
} catch (e) {
}
return canDispatch;
},
_dispatchEventFirefoxIE: function (event) {
var disabled = this.disabled;
this.disabled = false;
var defaultPrevented = this._origDispatchEvent(event);
this.disabled = disabled;
return defaultPrevented;
},
get _patternRegExp() {
var pattern;
if (this.allowedPattern) {
pattern = new RegExp(this.allowedPattern);
} else {
switch (this.type) {
case 'number':
pattern = /[0-9.,e-]/;
break;
}
}
return pattern;
},
ready: function () {
this.bindValue = this.value;
},
_bindValueChanged: function () {
if (this.value !== this.bindValue) {
this.value = !(this.bindValue || this.bindValue === 0 || this.bindValue === false) ? '' : this.bindValue;
}
this.fire('bind-value-changed', { value: this.bindValue });
},
_allowedPatternChanged: function () {
this.preventInvalidInput = this.allowedPattern ? true : false;
},
_onInput: function () {
if (this.preventInvalidInput && !this._patternAlreadyChecked) {
var valid = this._checkPatternValidity();
if (!valid) {
this._announceInvalidCharacter('Invalid string of characters not entered.');
this.value = this._previousValidInput;
}
}
this.bindValue = this.value;
this._previousValidInput = this.value;
this._patternAlreadyChecked = false;
},
_isPrintable: function (event) {
var anyNonPrintable = event.keyCode == 8 || event.keyCode == 9 || event.keyCode == 13 || event.keyCode == 27;
var mozNonPrintable = event.keyCode == 19 || event.keyCode == 20 || event.keyCode == 45 || event.keyCode == 46 || event.keyCode == 144 || event.keyCode == 145 || event.keyCode > 32 && event.keyCode < 41 || event.keyCode > 111 && event.keyCode < 124;
return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
},
_onKeypress: function (event) {
if (!this.preventInvalidInput && this.type !== 'number') {
return;
}
var regexp = this._patternRegExp;
if (!regexp) {
return;
}
if (event.metaKey || event.ctrlKey || event.altKey)
return;
this._patternAlreadyChecked = true;
var thisChar = String.fromCharCode(event.charCode);
if (this._isPrintable(event) && !regexp.test(thisChar)) {
event.preventDefault();
this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
}
},
_checkPatternValidity: function () {
var regexp = this._patternRegExp;
if (!regexp) {
return true;
}
for (var i = 0; i < this.value.length; i++) {
if (!regexp.test(this.value[i])) {
return false;
}
}
return true;
},
validate: function () {
var valid = this.checkValidity();
if (valid) {
if (this.required && this.value === '') {
valid = false;
} else if (this.hasValidator()) {
valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
}
}
this.invalid = !valid;
this.fire('iron-input-validate');
return valid;
},
_announceInvalidCharacter: function (message) {
this.fire('iron-announce', { text: message });
}
});
Polymer.PaperInputHelper = {};
Polymer.PaperInputHelper.NextLabelID = 1;
Polymer.PaperInputHelper.NextAddonID = 1;
Polymer.PaperInputBehaviorImpl = {
properties: {
label: { type: String },
value: {
notify: true,
type: String
},
disabled: {
type: Boolean,
value: false
},
invalid: {
type: Boolean,
value: false,
notify: true
},
preventInvalidInput: { type: Boolean },
allowedPattern: { type: String },
type: { type: String },
list: { type: String },
pattern: { type: String },
required: {
type: Boolean,
value: false
},
errorMessage: { type: String },
charCounter: {
type: Boolean,
value: false
},
noLabelFloat: {
type: Boolean,
value: false
},
alwaysFloatLabel: {
type: Boolean,
value: false
},
autoValidate: {
type: Boolean,
value: false
},
validator: { type: String },
autocomplete: {
type: String,
value: 'off'
},
autofocus: {
type: Boolean,
observer: '_autofocusChanged'
},
inputmode: { type: String },
minlength: { type: Number },
maxlength: { type: Number },
min: { type: String },
max: { type: String },
step: { type: String },
name: { type: String },
placeholder: {
type: String,
value: ''
},
readonly: {
type: Boolean,
value: false
},
size: { type: Number },
autocapitalize: {
type: String,
value: 'none'
},
autocorrect: {
type: String,
value: 'off'
},
autosave: { type: String },
results: { type: Number },
accept: { type: String },
multiple: { type: Boolean },
_ariaDescribedBy: {
type: String,
value: ''
},
_ariaLabelledBy: {
type: String,
value: ''
}
},
listeners: { 'addon-attached': '_onAddonAttached' },
keyBindings: { 'shift+tab:keydown': '_onShiftTabDown' },
hostAttributes: { tabindex: 0 },
get inputElement() {
return this.$.input;
},
get _focusableElement() {
return this.inputElement;
},
registered: function () {
this._typesThatHaveText = [
'date',
'datetime',
'datetime-local',
'month',
'time',
'week',
'file'
];
},
attached: function () {
this._updateAriaLabelledBy();
if (this.inputElement && this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
this.alwaysFloatLabel = true;
}
},
_appendStringWithSpace: function (str, more) {
if (str) {
str = str + ' ' + more;
} else {
str = more;
}
return str;
},
_onAddonAttached: function (event) {
var target = event.path ? event.path[0] : event.target;
if (target.id) {
this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
} else {
var id = 'paper-input-add-on-' + Polymer.PaperInputHelper.NextAddonID++;
target.id = id;
this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
}
},
validate: function () {
return this.inputElement.validate();
},
_focusBlurHandler: function (event) {
Polymer.IronControlState._focusBlurHandler.call(this, event);
if (this.focused && !this._shiftTabPressed)
this._focusableElement.focus();
},
_onShiftTabDown: function (event) {
var oldTabIndex = this.getAttribute('tabindex');
this._shiftTabPressed = true;
this.setAttribute('tabindex', '-1');
this.async(function () {
this.setAttribute('tabindex', oldTabIndex);
this._shiftTabPressed = false;
}, 1);
},
_handleAutoValidate: function () {
if (this.autoValidate)
this.validate();
},
updateValueAndPreserveCaret: function (newValue) {
try {
var start = this.inputElement.selectionStart;
this.value = newValue;
this.inputElement.selectionStart = start;
this.inputElement.selectionEnd = start;
} catch (e) {
this.value = newValue;
}
},
_computeAlwaysFloatLabel: function (alwaysFloatLabel, placeholder) {
return placeholder || alwaysFloatLabel;
},
_updateAriaLabelledBy: function () {
var label = Polymer.dom(this.root).querySelector('label');
if (!label) {
this._ariaLabelledBy = '';
return;
}
var labelledBy;
if (label.id) {
labelledBy = label.id;
} else {
labelledBy = 'paper-input-label-' + Polymer.PaperInputHelper.NextLabelID++;
label.id = labelledBy;
}
this._ariaLabelledBy = labelledBy;
},
_onChange: function (event) {
if (this.shadowRoot) {
this.fire(event.type, { sourceEvent: event }, {
node: this,
bubbles: event.bubbles,
cancelable: event.cancelable
});
}
},
_autofocusChanged: function () {
if (this.autofocus && this._focusableElement) {
var activeElement = document.activeElement;
var isActiveElementValid = activeElement instanceof HTMLElement;
var isSomeElementActive = isActiveElementValid && activeElement !== document.body && activeElement !== document.documentElement;
if (!isSomeElementActive) {
this._focusableElement.focus();
}
}
}
};
Polymer.PaperInputBehavior = [
Polymer.IronControlState,
Polymer.IronA11yKeysBehavior,
Polymer.PaperInputBehaviorImpl
];
Polymer.PaperInputAddonBehavior = {
hostAttributes: { 'add-on': '' },
attached: function () {
this.fire('addon-attached');
},
update: function (state) {
}
};
Polymer({
is: 'paper-input-char-counter',
behaviors: [Polymer.PaperInputAddonBehavior],
properties: {
_charCounterStr: {
type: String,
value: '0'
}
},
update: function (state) {
if (!state.inputElement) {
return;
}
state.value = state.value || '';
var counter = state.value.toString().length.toString();
if (state.inputElement.hasAttribute('maxlength')) {
counter += '/' + state.inputElement.getAttribute('maxlength');
}
this._charCounterStr = counter;
}
});
Polymer({
is: 'paper-input-container',
properties: {
noLabelFloat: {
type: Boolean,
value: false
},
alwaysFloatLabel: {
type: Boolean,
value: false
},
attrForValue: {
type: String,
value: 'bind-value'
},
autoValidate: {
type: Boolean,
value: false
},
invalid: {
observer: '_invalidChanged',
type: Boolean,
value: false
},
focused: {
readOnly: true,
type: Boolean,
value: false,
notify: true
},
_addons: { type: Array },
_inputHasContent: {
type: Boolean,
value: false
},
_inputSelector: {
type: String,
value: 'input,textarea,.paper-input-input'
},
_boundOnFocus: {
type: Function,
value: function () {
return this._onFocus.bind(this);
}
},
_boundOnBlur: {
type: Function,
value: function () {
return this._onBlur.bind(this);
}
},
_boundOnInput: {
type: Function,
value: function () {
return this._onInput.bind(this);
}
},
_boundValueChanged: {
type: Function,
value: function () {
return this._onValueChanged.bind(this);
}
}
},
listeners: {
'addon-attached': '_onAddonAttached',
'iron-input-validate': '_onIronInputValidate'
},
get _valueChangedEvent() {
return this.attrForValue + '-changed';
},
get _propertyForValue() {
return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
},
get _inputElement() {
return Polymer.dom(this).querySelector(this._inputSelector);
},
get _inputElementValue() {
return this._inputElement[this._propertyForValue] || this._inputElement.value;
},
ready: function () {
if (!this._addons) {
this._addons = [];
}
this.addEventListener('focus', this._boundOnFocus, true);
this.addEventListener('blur', this._boundOnBlur, true);
},
attached: function () {
if (this.attrForValue) {
this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
} else {
this.addEventListener('input', this._onInput);
}
if (this._inputElementValue != '') {
this._handleValueAndAutoValidate(this._inputElement);
} else {
this._handleValue(this._inputElement);
}
},
_onAddonAttached: function (event) {
if (!this._addons) {
this._addons = [];
}
var target = event.target;
if (this._addons.indexOf(target) === -1) {
this._addons.push(target);
if (this.isAttached) {
this._handleValue(this._inputElement);
}
}
},
_onFocus: function () {
this._setFocused(true);
},
_onBlur: function () {
this._setFocused(false);
this._handleValueAndAutoValidate(this._inputElement);
},
_onInput: function (event) {
this._handleValueAndAutoValidate(event.target);
},
_onValueChanged: function (event) {
this._handleValueAndAutoValidate(event.target);
},
_handleValue: function (inputElement) {
var value = this._inputElementValue;
if (value || value === 0 || inputElement.type === 'number' && !inputElement.checkValidity()) {
this._inputHasContent = true;
} else {
this._inputHasContent = false;
}
this.updateAddons({
inputElement: inputElement,
value: value,
invalid: this.invalid
});
},
_handleValueAndAutoValidate: function (inputElement) {
if (this.autoValidate) {
var valid;
if (inputElement.validate) {
valid = inputElement.validate(this._inputElementValue);
} else {
valid = inputElement.checkValidity();
}
this.invalid = !valid;
}
this._handleValue(inputElement);
},
_onIronInputValidate: function (event) {
this.invalid = this._inputElement.invalid;
},
_invalidChanged: function () {
if (this._addons) {
this.updateAddons({ invalid: this.invalid });
}
},
updateAddons: function (state) {
for (var addon, index = 0; addon = this._addons[index]; index++) {
addon.update(state);
}
},
_computeInputContentClass: function (noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
var cls = 'input-content';
if (!noLabelFloat) {
var label = this.querySelector('label');
if (alwaysFloatLabel || _inputHasContent) {
cls += ' label-is-floating';
this.$.labelAndInputContainer.style.position = 'static';
if (invalid) {
cls += ' is-invalid';
} else if (focused) {
cls += ' label-is-highlighted';
}
} else {
if (label) {
this.$.labelAndInputContainer.style.position = 'relative';
}
if (invalid) {
cls += ' is-invalid';
}
}
} else {
if (_inputHasContent) {
cls += ' label-is-hidden';
}
if (invalid) {
cls += ' is-invalid';
}
}
if (focused) {
cls += ' focused';
}
return cls;
},
_computeUnderlineClass: function (focused, invalid) {
var cls = 'underline';
if (invalid) {
cls += ' is-invalid';
} else if (focused) {
cls += ' is-highlighted';
}
return cls;
},
_computeAddOnContentClass: function (focused, invalid) {
var cls = 'add-on-content';
if (invalid) {
cls += ' is-invalid';
} else if (focused) {
cls += ' is-highlighted';
}
return cls;
}
});
Polymer({
is: 'paper-input-error',
behaviors: [Polymer.PaperInputAddonBehavior],
properties: {
invalid: {
readOnly: true,
reflectToAttribute: true,
type: Boolean
}
},
update: function (state) {
this._setInvalid(state.invalid);
}
});
Polymer({
is: 'paper-input',
behaviors: [
Polymer.IronFormElementBehavior,
Polymer.PaperInputBehavior
]
});
Polymer.IronFitBehavior = {
properties: {
sizingTarget: {
type: Object,
value: function () {
return this;
}
},
fitInto: {
type: Object,
value: window
},
noOverlap: { type: Boolean },
positionTarget: { type: Element },
horizontalAlign: { type: String },
verticalAlign: { type: String },
dynamicAlign: { type: Boolean },
horizontalOffset: {
type: Number,
value: 0,
notify: true
},
verticalOffset: {
type: Number,
value: 0,
notify: true
},
autoFitOnAttach: {
type: Boolean,
value: false
},
_fitInfo: { type: Object }
},
get _fitWidth() {
var fitWidth;
if (this.fitInto === window) {
fitWidth = this.fitInto.innerWidth;
} else {
fitWidth = this.fitInto.getBoundingClientRect().width;
}
return fitWidth;
},
get _fitHeight() {
var fitHeight;
if (this.fitInto === window) {
fitHeight = this.fitInto.innerHeight;
} else {
fitHeight = this.fitInto.getBoundingClientRect().height;
}
return fitHeight;
},
get _fitLeft() {
var fitLeft;
if (this.fitInto === window) {
fitLeft = 0;
} else {
fitLeft = this.fitInto.getBoundingClientRect().left;
}
return fitLeft;
},
get _fitTop() {
var fitTop;
if (this.fitInto === window) {
fitTop = 0;
} else {
fitTop = this.fitInto.getBoundingClientRect().top;
}
return fitTop;
},
get _defaultPositionTarget() {
var parent = Polymer.dom(this).parentNode;
if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
parent = parent.host;
}
return parent;
},
get _localeHorizontalAlign() {
if (this._isRTL) {
if (this.horizontalAlign === 'right') {
return 'left';
}
if (this.horizontalAlign === 'left') {
return 'right';
}
}
return this.horizontalAlign;
},
attached: function () {
if (typeof this._isRTL === 'undefined') {
this._isRTL = window.getComputedStyle(this).direction == 'rtl';
}
this.positionTarget = this.positionTarget || this._defaultPositionTarget;
if (this.autoFitOnAttach) {
if (window.getComputedStyle(this).display === 'none') {
setTimeout(function () {
this.fit();
}.bind(this));
} else {
this.fit();
}
}
},
fit: function () {
this.position();
this.constrain();
this.center();
},
_discoverInfo: function () {
if (this._fitInfo) {
return;
}
var target = window.getComputedStyle(this);
var sizer = window.getComputedStyle(this.sizingTarget);
this._fitInfo = {
inlineStyle: {
top: this.style.top || '',
left: this.style.left || '',
position: this.style.position || ''
},
sizerInlineStyle: {
maxWidth: this.sizingTarget.style.maxWidth || '',
maxHeight: this.sizingTarget.style.maxHeight || '',
boxSizing: this.sizingTarget.style.boxSizing || ''
},
positionedBy: {
vertically: target.top !== 'auto' ? 'top' : target.bottom !== 'auto' ? 'bottom' : null,
horizontally: target.left !== 'auto' ? 'left' : target.right !== 'auto' ? 'right' : null
},
sizedBy: {
height: sizer.maxHeight !== 'none',
width: sizer.maxWidth !== 'none',
minWidth: parseInt(sizer.minWidth, 10) || 0,
minHeight: parseInt(sizer.minHeight, 10) || 0
},
margin: {
top: parseInt(target.marginTop, 10) || 0,
right: parseInt(target.marginRight, 10) || 0,
bottom: parseInt(target.marginBottom, 10) || 0,
left: parseInt(target.marginLeft, 10) || 0
}
};
},
resetFit: function () {
var info = this._fitInfo || {};
for (var property in info.sizerInlineStyle) {
this.sizingTarget.style[property] = info.sizerInlineStyle[property];
}
for (var property in info.inlineStyle) {
this.style[property] = info.inlineStyle[property];
}
this._fitInfo = null;
},
refit: function () {
var scrollLeft = this.sizingTarget.scrollLeft;
var scrollTop = this.sizingTarget.scrollTop;
this.resetFit();
this.fit();
this.sizingTarget.scrollLeft = scrollLeft;
this.sizingTarget.scrollTop = scrollTop;
},
position: function () {
if (!this.horizontalAlign && !this.verticalAlign) {
return;
}
this._discoverInfo();
this.style.position = 'fixed';
this.sizingTarget.style.boxSizing = 'border-box';
this.style.left = '0px';
this.style.top = '0px';
var rect = this.getBoundingClientRect();
var positionRect = this.__getNormalizedRect(this.positionTarget);
var fitRect = this.__getNormalizedRect(this.fitInto);
var margin = this._fitInfo.margin;
var size = {
width: rect.width + margin.left + margin.right,
height: rect.height + margin.top + margin.bottom
};
var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect, fitRect);
var left = position.left + margin.left;
var top = position.top + margin.top;
var right = Math.min(fitRect.right - margin.right, left + rect.width);
var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);
left = Math.max(fitRect.left + margin.left, Math.min(left, right - this._fitInfo.sizedBy.minWidth));
top = Math.max(fitRect.top + margin.top, Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));
this.sizingTarget.style.maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
this.sizingTarget.style.maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';
this.style.left = left - rect.left + 'px';
this.style.top = top - rect.top + 'px';
},
constrain: function () {
if (this.horizontalAlign || this.verticalAlign) {
return;
}
this._discoverInfo();
var info = this._fitInfo;
if (!info.positionedBy.vertically) {
this.style.position = 'fixed';
this.style.top = '0px';
}
if (!info.positionedBy.horizontally) {
this.style.position = 'fixed';
this.style.left = '0px';
}
this.sizingTarget.style.boxSizing = 'border-box';
var rect = this.getBoundingClientRect();
if (!info.sizedBy.height) {
this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
}
if (!info.sizedBy.width) {
this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
}
},
_sizeDimension: function (rect, positionedBy, start, end, extent) {
this.__sizeDimension(rect, positionedBy, start, end, extent);
},
__sizeDimension: function (rect, positionedBy, start, end, extent) {
var info = this._fitInfo;
var fitRect = this.__getNormalizedRect(this.fitInto);
var max = extent === 'Width' ? fitRect.width : fitRect.height;
var flip = positionedBy === end;
var offset = flip ? max - rect[end] : rect[start];
var margin = info.margin[flip ? start : end];
var offsetExtent = 'offset' + extent;
var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
this.sizingTarget.style['max' + extent] = max - margin - offset - sizingOffset + 'px';
},
center: function () {
if (this.horizontalAlign || this.verticalAlign) {
return;
}
this._discoverInfo();
var positionedBy = this._fitInfo.positionedBy;
if (positionedBy.vertically && positionedBy.horizontally) {
return;
}
this.style.position = 'fixed';
if (!positionedBy.vertically) {
this.style.top = '0px';
}
if (!positionedBy.horizontally) {
this.style.left = '0px';
}
var rect = this.getBoundingClientRect();
var fitRect = this.__getNormalizedRect(this.fitInto);
if (!positionedBy.vertically) {
var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
this.style.top = top + 'px';
}
if (!positionedBy.horizontally) {
var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
this.style.left = left + 'px';
}
},
__getNormalizedRect: function (target) {
if (target === document.documentElement || target === window) {
return {
top: 0,
left: 0,
width: window.innerWidth,
height: window.innerHeight,
right: window.innerWidth,
bottom: window.innerHeight
};
}
return target.getBoundingClientRect();
},
__getCroppedArea: function (position, size, fitRect) {
var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
},
__getPosition: function (hAlign, vAlign, size, positionRect, fitRect) {
var positions = [
{
verticalAlign: 'top',
horizontalAlign: 'left',
top: positionRect.top + this.verticalOffset,
left: positionRect.left + this.horizontalOffset
},
{
verticalAlign: 'top',
horizontalAlign: 'right',
top: positionRect.top + this.verticalOffset,
left: positionRect.right - size.width - this.horizontalOffset
},
{
verticalAlign: 'bottom',
horizontalAlign: 'left',
top: positionRect.bottom - size.height - this.verticalOffset,
left: positionRect.left + this.horizontalOffset
},
{
verticalAlign: 'bottom',
horizontalAlign: 'right',
top: positionRect.bottom - size.height - this.verticalOffset,
left: positionRect.right - size.width - this.horizontalOffset
}
];
if (this.noOverlap) {
for (var i = 0, l = positions.length; i < l; i++) {
var copy = {};
for (var key in positions[i]) {
copy[key] = positions[i][key];
}
positions.push(copy);
}
positions[0].top = positions[1].top += positionRect.height;
positions[2].top = positions[3].top -= positionRect.height;
positions[4].left = positions[6].left += positionRect.width;
positions[5].left = positions[7].left -= positionRect.width;
}
vAlign = vAlign === 'auto' ? null : vAlign;
hAlign = hAlign === 'auto' ? null : hAlign;
var position;
for (var i = 0; i < positions.length; i++) {
var pos = positions[i];
if (!this.dynamicAlign && !this.noOverlap && pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
position = pos;
break;
}
var alignOk = (!vAlign || pos.verticalAlign === vAlign) && (!hAlign || pos.horizontalAlign === hAlign);
if (!this.dynamicAlign && !alignOk) {
continue;
}
position = position || pos;
pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
var diff = pos.croppedArea - position.croppedArea;
if (diff < 0 || diff === 0 && alignOk) {
position = pos;
}
if (position.croppedArea === 0 && alignOk) {
break;
}
}
return position;
}
};
(function () {
'use strict';
Polymer({
is: 'iron-overlay-backdrop',
properties: {
opened: {
reflectToAttribute: true,
type: Boolean,
value: false,
observer: '_openedChanged'
}
},
listeners: { 'transitionend': '_onTransitionend' },
created: function () {
this.__openedRaf = null;
},
attached: function () {
this.opened && this._openedChanged(this.opened);
},
prepare: function () {
if (this.opened && !this.parentNode) {
Polymer.dom(document.body).appendChild(this);
}
},
open: function () {
this.opened = true;
},
close: function () {
this.opened = false;
},
complete: function () {
if (!this.opened && this.parentNode === document.body) {
Polymer.dom(this.parentNode).removeChild(this);
}
},
_onTransitionend: function (event) {
if (event && event.target === this) {
this.complete();
}
},
_openedChanged: function (opened) {
if (opened) {
this.prepare();
} else {
var cs = window.getComputedStyle(this);
if (cs.transitionDuration === '0s' || cs.opacity == 0) {
this.complete();
}
}
if (!this.isAttached) {
return;
}
if (this.__openedRaf) {
window.cancelAnimationFrame(this.__openedRaf);
this.__openedRaf = null;
}
this.scrollTop = this.scrollTop;
this.__openedRaf = window.requestAnimationFrame(function () {
this.__openedRaf = null;
this.toggleClass('opened', this.opened);
}.bind(this));
}
});
}());
Polymer.IronOverlayManagerClass = function () {
this._overlays = [];
this._minimumZ = 101;
this._backdropElement = null;
Polymer.Gestures.add(document.documentElement, 'tap', null);
document.addEventListener('tap', this._onCaptureClick.bind(this), true);
document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};
Polymer.IronOverlayManagerClass.prototype = {
constructor: Polymer.IronOverlayManagerClass,
get backdropElement() {
if (!this._backdropElement) {
this._backdropElement = document.createElement('iron-overlay-backdrop');
}
return this._backdropElement;
},
get deepActiveElement() {
var active = document.activeElement || document.body;
while (active.root && Polymer.dom(active.root).activeElement) {
active = Polymer.dom(active.root).activeElement;
}
return active;
},
_bringOverlayAtIndexToFront: function (i) {
var overlay = this._overlays[i];
if (!overlay) {
return;
}
var lastI = this._overlays.length - 1;
var currentOverlay = this._overlays[lastI];
if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
lastI--;
}
if (i >= lastI) {
return;
}
var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
if (this._getZ(overlay) <= minimumZ) {
this._applyOverlayZ(overlay, minimumZ);
}
while (i < lastI) {
this._overlays[i] = this._overlays[i + 1];
i++;
}
this._overlays[lastI] = overlay;
},
addOrRemoveOverlay: function (overlay) {
if (overlay.opened) {
this.addOverlay(overlay);
} else {
this.removeOverlay(overlay);
}
},
addOverlay: function (overlay) {
var i = this._overlays.indexOf(overlay);
if (i >= 0) {
this._bringOverlayAtIndexToFront(i);
this.trackBackdrop();
return;
}
var insertionIndex = this._overlays.length;
var currentOverlay = this._overlays[insertionIndex - 1];
var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
var newZ = this._getZ(overlay);
if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
this._applyOverlayZ(currentOverlay, minimumZ);
insertionIndex--;
var previousOverlay = this._overlays[insertionIndex - 1];
minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
}
if (newZ <= minimumZ) {
this._applyOverlayZ(overlay, minimumZ);
}
this._overlays.splice(insertionIndex, 0, overlay);
this.trackBackdrop();
},
removeOverlay: function (overlay) {
var i = this._overlays.indexOf(overlay);
if (i === -1) {
return;
}
this._overlays.splice(i, 1);
this.trackBackdrop();
},
currentOverlay: function () {
var i = this._overlays.length - 1;
return this._overlays[i];
},
currentOverlayZ: function () {
return this._getZ(this.currentOverlay());
},
ensureMinimumZ: function (minimumZ) {
this._minimumZ = Math.max(this._minimumZ, minimumZ);
},
focusOverlay: function () {
var current = this.currentOverlay();
if (current) {
current._applyFocus();
}
},
trackBackdrop: function () {
var overlay = this._overlayWithBackdrop();
if (!overlay && !this._backdropElement) {
return;
}
this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
this.backdropElement.opened = !!overlay;
},
getBackdrops: function () {
var backdrops = [];
for (var i = 0; i < this._overlays.length; i++) {
if (this._overlays[i].withBackdrop) {
backdrops.push(this._overlays[i]);
}
}
return backdrops;
},
backdropZ: function () {
return this._getZ(this._overlayWithBackdrop()) - 1;
},
_overlayWithBackdrop: function () {
for (var i = 0; i < this._overlays.length; i++) {
if (this._overlays[i].withBackdrop) {
return this._overlays[i];
}
}
},
_getZ: function (overlay) {
var z = this._minimumZ;
if (overlay) {
var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
if (z1 === z1) {
z = z1;
}
}
return z;
},
_setZ: function (element, z) {
element.style.zIndex = z;
},
_applyOverlayZ: function (overlay, aboveZ) {
this._setZ(overlay, aboveZ + 2);
},
_overlayInPath: function (path) {
path = path || [];
for (var i = 0; i < path.length; i++) {
if (path[i]._manager === this) {
return path[i];
}
}
},
_onCaptureClick: function (event) {
var overlay = this.currentOverlay();
if (overlay && this._overlayInPath(Polymer.dom(event).path) !== overlay) {
overlay._onCaptureClick(event);
}
},
_onCaptureFocus: function (event) {
var overlay = this.currentOverlay();
if (overlay) {
overlay._onCaptureFocus(event);
}
},
_onCaptureKeyDown: function (event) {
var overlay = this.currentOverlay();
if (overlay) {
if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
overlay._onCaptureEsc(event);
} else if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
overlay._onCaptureTab(event);
}
}
},
_shouldBeBehindOverlay: function (overlay1, overlay2) {
return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
}
};
Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass();
(function () {
'use strict';
var p = Element.prototype;
var matches = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
Polymer.IronFocusablesHelper = {
getTabbableNodes: function (node) {
var result = [];
var needsSortByTabIndex = this._collectTabbableNodes(node, result);
if (needsSortByTabIndex) {
return this._sortByTabIndex(result);
}
return result;
},
isFocusable: function (element) {
if (matches.call(element, 'input, select, textarea, button, object')) {
return matches.call(element, ':not([disabled])');
}
return matches.call(element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');
},
isTabbable: function (element) {
return this.isFocusable(element) && matches.call(element, ':not([tabindex="-1"])') && this._isVisible(element);
},
_normalizedTabIndex: function (element) {
if (this.isFocusable(element)) {
var tabIndex = element.getAttribute('tabindex') || 0;
return Number(tabIndex);
}
return -1;
},
_collectTabbableNodes: function (node, result) {
if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
return false;
}
var element = node;
var tabIndex = this._normalizedTabIndex(element);
var needsSortByTabIndex = tabIndex > 0;
if (tabIndex >= 0) {
result.push(element);
}
var children;
if (element.localName === 'content') {
children = Polymer.dom(element).getDistributedNodes();
} else {
children = Polymer.dom(element.root || element).children;
}
for (var i = 0; i < children.length; i++) {
var needsSort = this._collectTabbableNodes(children[i], result);
needsSortByTabIndex = needsSortByTabIndex || needsSort;
}
return needsSortByTabIndex;
},
_isVisible: function (element) {
var style = element.style;
if (style.visibility !== 'hidden' && style.display !== 'none') {
style = window.getComputedStyle(element);
return style.visibility !== 'hidden' && style.display !== 'none';
}
return false;
},
_sortByTabIndex: function (tabbables) {
var len = tabbables.length;
if (len < 2) {
return tabbables;
}
var pivot = Math.ceil(len / 2);
var left = this._sortByTabIndex(tabbables.slice(0, pivot));
var right = this._sortByTabIndex(tabbables.slice(pivot));
return this._mergeSortByTabIndex(left, right);
},
_mergeSortByTabIndex: function (left, right) {
var result = [];
while (left.length > 0 && right.length > 0) {
if (this._hasLowerTabOrder(left[0], right[0])) {
result.push(right.shift());
} else {
result.push(left.shift());
}
}
return result.concat(left, right);
},
_hasLowerTabOrder: function (a, b) {
var ati = Math.max(a.tabIndex, 0);
var bti = Math.max(b.tabIndex, 0);
return ati === 0 || bti === 0 ? bti > ati : ati > bti;
}
};
}());
(function () {
'use strict';
Polymer.IronOverlayBehaviorImpl = {
properties: {
opened: {
observer: '_openedChanged',
type: Boolean,
value: false,
notify: true
},
canceled: {
observer: '_canceledChanged',
readOnly: true,
type: Boolean,
value: false
},
withBackdrop: {
observer: '_withBackdropChanged',
type: Boolean
},
noAutoFocus: {
type: Boolean,
value: false
},
noCancelOnEscKey: {
type: Boolean,
value: false
},
noCancelOnOutsideClick: {
type: Boolean,
value: false
},
closingReason: { type: Object },
restoreFocusOnClose: {
type: Boolean,
value: false
},
alwaysOnTop: { type: Boolean },
_manager: {
type: Object,
value: Polymer.IronOverlayManager
},
_focusedChild: { type: Object }
},
listeners: { 'iron-resize': '_onIronResize' },
get backdropElement() {
return this._manager.backdropElement;
},
get _focusNode() {
return this._focusedChild || Polymer.dom(this).querySelector('[autofocus]') || this;
},
get _focusableNodes() {
return Polymer.IronFocusablesHelper.getTabbableNodes(this);
},
ready: function () {
this.__isAnimating = false;
this.__shouldRemoveTabIndex = false;
this.__firstFocusableNode = this.__lastFocusableNode = null;
this.__raf = null;
this.__restoreFocusNode = null;
this._ensureSetup();
},
attached: function () {
if (this.opened) {
this._openedChanged(this.opened);
}
this._observer = Polymer.dom(this).observeNodes(this._onNodesChange);
},
detached: function () {
Polymer.dom(this).unobserveNodes(this._observer);
this._observer = null;
if (this.__raf) {
window.cancelAnimationFrame(this.__raf);
this.__raf = null;
}
this._manager.removeOverlay(this);
},
toggle: function () {
this._setCanceled(false);
this.opened = !this.opened;
},
open: function () {
this._setCanceled(false);
this.opened = true;
},
close: function () {
this._setCanceled(false);
this.opened = false;
},
cancel: function (event) {
var cancelEvent = this.fire('iron-overlay-canceled', event, { cancelable: true });
if (cancelEvent.defaultPrevented) {
return;
}
this._setCanceled(true);
this.opened = false;
},
invalidateTabbables: function () {
this.__firstFocusableNode = this.__lastFocusableNode = null;
},
_ensureSetup: function () {
if (this._overlaySetup) {
return;
}
this._overlaySetup = true;
this.style.outline = 'none';
this.style.display = 'none';
},
_openedChanged: function (opened) {
if (opened) {
this.removeAttribute('aria-hidden');
} else {
this.setAttribute('aria-hidden', 'true');
}
if (!this.isAttached) {
return;
}
this.__isAnimating = true;
this.__onNextAnimationFrame(this.__openedChanged);
},
_canceledChanged: function () {
this.closingReason = this.closingReason || {};
this.closingReason.canceled = this.canceled;
},
_withBackdropChanged: function () {
if (this.withBackdrop && !this.hasAttribute('tabindex')) {
this.setAttribute('tabindex', '-1');
this.__shouldRemoveTabIndex = true;
} else if (this.__shouldRemoveTabIndex) {
this.removeAttribute('tabindex');
this.__shouldRemoveTabIndex = false;
}
if (this.opened && this.isAttached) {
this._manager.trackBackdrop();
}
},
_prepareRenderOpened: function () {
this.__restoreFocusNode = this._manager.deepActiveElement;
this._preparePositioning();
this.refit();
this._finishPositioning();
if (this.noAutoFocus && document.activeElement === this._focusNode) {
this._focusNode.blur();
this.__restoreFocusNode.focus();
}
},
_renderOpened: function () {
this._finishRenderOpened();
},
_renderClosed: function () {
this._finishRenderClosed();
},
_finishRenderOpened: function () {
this.notifyResize();
this.__isAnimating = false;
this.fire('iron-overlay-opened');
},
_finishRenderClosed: function () {
this.style.display = 'none';
this.style.zIndex = '';
this.notifyResize();
this.__isAnimating = false;
this.fire('iron-overlay-closed', this.closingReason);
},
_preparePositioning: function () {
this.style.transition = this.style.webkitTransition = 'none';
this.style.transform = this.style.webkitTransform = 'none';
this.style.display = '';
},
_finishPositioning: function () {
this.style.display = 'none';
this.scrollTop = this.scrollTop;
this.style.transition = this.style.webkitTransition = '';
this.style.transform = this.style.webkitTransform = '';
this.style.display = '';
this.scrollTop = this.scrollTop;
},
_applyFocus: function () {
if (this.opened) {
if (!this.noAutoFocus) {
this._focusNode.focus();
}
} else {
this._focusNode.blur();
this._focusedChild = null;
if (this.restoreFocusOnClose && this.__restoreFocusNode) {
this.__restoreFocusNode.focus();
}
this.__restoreFocusNode = null;
var currentOverlay = this._manager.currentOverlay();
if (currentOverlay && this !== currentOverlay) {
currentOverlay._applyFocus();
}
}
},
_onCaptureClick: function (event) {
if (!this.noCancelOnOutsideClick) {
this.cancel(event);
}
},
_onCaptureFocus: function (event) {
if (!this.withBackdrop) {
return;
}
var path = Polymer.dom(event).path;
if (path.indexOf(this) === -1) {
event.stopPropagation();
this._applyFocus();
} else {
this._focusedChild = path[0];
}
},
_onCaptureEsc: function (event) {
if (!this.noCancelOnEscKey) {
this.cancel(event);
}
},
_onCaptureTab: function (event) {
if (!this.withBackdrop) {
return;
}
this.__ensureFirstLastFocusables();
var shift = event.shiftKey;
var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
var shouldWrap = false;
if (nodeToCheck === nodeToSet) {
shouldWrap = true;
} else {
var focusedNode = this._manager.deepActiveElement;
shouldWrap = focusedNode === nodeToCheck || focusedNode === this;
}
if (shouldWrap) {
event.preventDefault();
this._focusedChild = nodeToSet;
this._applyFocus();
}
},
_onIronResize: function () {
if (this.opened && !this.__isAnimating) {
this.__onNextAnimationFrame(this.refit);
}
},
_onNodesChange: function () {
if (this.opened && !this.__isAnimating) {
this.invalidateTabbables();
this.notifyResize();
}
},
__ensureFirstLastFocusables: function () {
if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
var focusableNodes = this._focusableNodes;
this.__firstFocusableNode = focusableNodes[0];
this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
}
},
__openedChanged: function () {
if (this.opened) {
this._prepareRenderOpened();
this._manager.addOverlay(this);
this._applyFocus();
this._renderOpened();
} else {
this._manager.removeOverlay(this);
this._applyFocus();
this._renderClosed();
}
},
__onNextAnimationFrame: function (callback) {
if (this.__raf) {
window.cancelAnimationFrame(this.__raf);
}
var self = this;
this.__raf = window.requestAnimationFrame(function nextAnimationFrame() {
self.__raf = null;
callback.call(self);
});
}
};
Polymer.IronOverlayBehavior = [
Polymer.IronFitBehavior,
Polymer.IronResizableBehavior,
Polymer.IronOverlayBehaviorImpl
];
}());
Polymer.NeonAnimatableBehavior = {
properties: {
animationConfig: { type: Object },
entryAnimation: {
observer: '_entryAnimationChanged',
type: String
},
exitAnimation: {
observer: '_exitAnimationChanged',
type: String
}
},
_entryAnimationChanged: function () {
this.animationConfig = this.animationConfig || {};
this.animationConfig['entry'] = [{
name: this.entryAnimation,
node: this
}];
},
_exitAnimationChanged: function () {
this.animationConfig = this.animationConfig || {};
this.animationConfig['exit'] = [{
name: this.exitAnimation,
node: this
}];
},
_copyProperties: function (config1, config2) {
for (var property in config2) {
config1[property] = config2[property];
}
},
_cloneConfig: function (config) {
var clone = { isClone: true };
this._copyProperties(clone, config);
return clone;
},
_getAnimationConfigRecursive: function (type, map, allConfigs) {
if (!this.animationConfig) {
return;
}
if (this.animationConfig.value && typeof this.animationConfig.value === 'function') {
this._warn(this._logf('playAnimation', 'Please put \'animationConfig\' inside of your components \'properties\' object instead of outside of it.'));
return;
}
var thisConfig;
if (type) {
thisConfig = this.animationConfig[type];
} else {
thisConfig = this.animationConfig;
}
if (!Array.isArray(thisConfig)) {
thisConfig = [thisConfig];
}
if (thisConfig) {
for (var config, index = 0; config = thisConfig[index]; index++) {
if (config.animatable) {
config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
} else {
if (config.id) {
var cachedConfig = map[config.id];
if (cachedConfig) {
if (!cachedConfig.isClone) {
map[config.id] = this._cloneConfig(cachedConfig);
cachedConfig = map[config.id];
}
this._copyProperties(cachedConfig, config);
} else {
map[config.id] = config;
}
} else {
allConfigs.push(config);
}
}
}
}
},
getAnimationConfig: function (type) {
var map = {};
var allConfigs = [];
this._getAnimationConfigRecursive(type, map, allConfigs);
for (var key in map) {
allConfigs.push(map[key]);
}
return allConfigs;
}
};
Polymer.NeonAnimationRunnerBehaviorImpl = {
_configureAnimations: function (configs) {
var results = [];
if (configs.length > 0) {
for (var config, index = 0; config = configs[index]; index++) {
var neonAnimation = document.createElement(config.name);
if (neonAnimation.isNeonAnimation) {
var result = null;
try {
result = neonAnimation.configure(config);
if (typeof result.cancel != 'function') {
result = document.timeline.play(result);
}
} catch (e) {
result = null;
console.warn('Couldnt play', '(', config.name, ').', e);
}
if (result) {
results.push({
neonAnimation: neonAnimation,
config: config,
animation: result
});
}
} else {
console.warn(this.is + ':', config.name, 'not found!');
}
}
}
return results;
},
_shouldComplete: function (activeEntries) {
var finished = true;
for (var i = 0; i < activeEntries.length; i++) {
if (activeEntries[i].animation.playState != 'finished') {
finished = false;
break;
}
}
return finished;
},
_complete: function (activeEntries) {
for (var i = 0; i < activeEntries.length; i++) {
activeEntries[i].neonAnimation.complete(activeEntries[i].config);
}
for (var i = 0; i < activeEntries.length; i++) {
activeEntries[i].animation.cancel();
}
},
playAnimation: function (type, cookie) {
var configs = this.getAnimationConfig(type);
if (!configs) {
return;
}
this._active = this._active || {};
if (this._active[type]) {
this._complete(this._active[type]);
delete this._active[type];
}
var activeEntries = this._configureAnimations(configs);
if (activeEntries.length == 0) {
this.fire('neon-animation-finish', cookie, { bubbles: false });
return;
}
this._active[type] = activeEntries;
for (var i = 0; i < activeEntries.length; i++) {
activeEntries[i].animation.onfinish = function () {
if (this._shouldComplete(activeEntries)) {
this._complete(activeEntries);
delete this._active[type];
this.fire('neon-animation-finish', cookie, { bubbles: false });
}
}.bind(this);
}
},
cancelAnimation: function () {
for (var k in this._animations) {
this._animations[k].cancel();
}
this._animations = {};
}
};
Polymer.NeonAnimationRunnerBehavior = [
Polymer.NeonAnimatableBehavior,
Polymer.NeonAnimationRunnerBehaviorImpl
];
Polymer.NeonAnimationBehavior = {
properties: {
animationTiming: {
type: Object,
value: function () {
return {
duration: 500,
easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
fill: 'both'
};
}
}
},
isNeonAnimation: true,
timingFromConfig: function (config) {
if (config.timing) {
for (var property in config.timing) {
this.animationTiming[property] = config.timing[property];
}
}
return this.animationTiming;
},
setPrefixedProperty: function (node, property, value) {
var map = {
'transform': ['webkitTransform'],
'transformOrigin': [
'mozTransformOrigin',
'webkitTransformOrigin'
]
};
var prefixes = map[property];
for (var prefix, index = 0; prefix = prefixes[index]; index++) {
node.style[prefix] = value;
}
node.style[property] = value;
},
complete: function () {
}
};
!function (a, b) {
var c = {}, d = {}, e = {};
!function (a, b) {
function c(a) {
if ('number' == typeof a)
return a;
var b = {};
for (var c in a)
b[c] = a[c];
return b;
}
function d() {
this._delay = 0, this._endDelay = 0, this._fill = 'none', this._iterationStart = 0, this._iterations = 1, this._duration = 0, this._playbackRate = 1, this._direction = 'normal', this._easing = 'linear', this._easingFunction = x;
}
function e() {
return a.isDeprecated('Invalid timing inputs', '2016-03-02', 'TypeError exceptions will be thrown instead.', !0);
}
function f(b, c, e) {
var f = new d();
return c && (f.fill = 'both', f.duration = 'auto'), 'number' != typeof b || isNaN(b) ? void 0 !== b && Object.getOwnPropertyNames(b).forEach(function (c) {
if ('auto' != b[c]) {
if (('number' == typeof f[c] || 'duration' == c) && ('number' != typeof b[c] || isNaN(b[c])))
return;
if ('fill' == c && -1 == v.indexOf(b[c]))
return;
if ('direction' == c && -1 == w.indexOf(b[c]))
return;
if ('playbackRate' == c && 1 !== b[c] && a.isDeprecated('AnimationEffectTiming.playbackRate', '2014-11-28', 'Use Animation.playbackRate instead.'))
return;
f[c] = b[c];
}
}) : f.duration = b, f;
}
function g(a) {
return 'number' == typeof a && (a = isNaN(a) ? { duration: 0 } : { duration: a }), a;
}
function h(b, c) {
return b = a.numericTimingToObject(b), f(b, c);
}
function i(a, b, c, d) {
return a < 0 || a > 1 || c < 0 || c > 1 ? x : function (e) {
function f(a, b, c) {
return 3 * a * (1 - c) * (1 - c) * c + 3 * b * (1 - c) * c * c + c * c * c;
}
if (e <= 0) {
var g = 0;
return a > 0 ? g = b / a : !b && c > 0 && (g = d / c), g * e;
}
if (e >= 1) {
var h = 0;
return c < 1 ? h = (d - 1) / (c - 1) : 1 == c && a < 1 && (h = (b - 1) / (a - 1)), 1 + h * (e - 1);
}
for (var i = 0, j = 1; i < j;) {
var k = (i + j) / 2, l = f(a, c, k);
if (Math.abs(e - l) < 0.00001)
return f(b, d, k);
l < e ? i = k : j = k;
}
return f(b, d, k);
};
}
function j(a, b) {
return function (c) {
if (c >= 1)
return 1;
var d = 1 / a;
return (c += b * d) - c % d;
};
}
function k(a) {
C || (C = document.createElement('div').style), C.animationTimingFunction = '', C.animationTimingFunction = a;
var b = C.animationTimingFunction;
if ('' == b && e())
throw new TypeError(a + ' is not a valid value for easing');
return b;
}
function l(a) {
if ('linear' == a)
return x;
var b = E.exec(a);
if (b)
return i.apply(this, b.slice(1).map(Number));
var c = F.exec(a);
return c ? j(Number(c[1]), {
start: y,
middle: z,
end: A
}[c[2]]) : B[a] || x;
}
function m(a) {
return Math.abs(n(a) / a.playbackRate);
}
function n(a) {
return 0 === a.duration || 0 === a.iterations ? 0 : a.duration * a.iterations;
}
function o(a, b, c) {
if (null == b)
return G;
var d = c.delay + a + c.endDelay;
return b < Math.min(c.delay, d) ? H : b >= Math.min(c.delay + a, d) ? I : J;
}
function p(a, b, c, d, e) {
switch (d) {
case H:
return 'backwards' == b || 'both' == b ? 0 : null;
case J:
return c - e;
case I:
return 'forwards' == b || 'both' == b ? a : null;
case G:
return null;
}
}
function q(a, b, c, d, e) {
var f = e;
return 0 === a ? b !== H && (f += c) : f += d / a, f;
}
function r(a, b, c, d, e, f) {
var g = a === 1 / 0 ? b % 1 : a % 1;
return 0 !== g || c !== I || 0 === d || 0 === e && 0 !== f || (g = 1), g;
}
function s(a, b, c, d) {
return a === I && b === 1 / 0 ? 1 / 0 : 1 === c ? Math.floor(d) - 1 : Math.floor(d);
}
function t(a, b, c) {
var d = a;
if ('normal' !== a && 'reverse' !== a) {
var e = b;
'alternate-reverse' === a && (e += 1), d = 'normal', e !== 1 / 0 && e % 2 != 0 && (d = 'reverse');
}
return 'normal' === d ? c : 1 - c;
}
function u(a, b, c) {
var d = o(a, b, c), e = p(a, c.fill, b, d, c.delay);
if (null === e)
return null;
var f = q(c.duration, d, c.iterations, e, c.iterationStart), g = r(f, c.iterationStart, d, c.iterations, e, c.duration), h = s(d, c.iterations, g, f), i = t(c.direction, h, g);
return c._easingFunction(i);
}
var v = 'backwards|forwards|both|none'.split('|'), w = 'reverse|alternate|alternate-reverse'.split('|'), x = function (a) {
return a;
};
d.prototype = {
_setMember: function (b, c) {
this['_' + b] = c, this._effect && (this._effect._timingInput[b] = c, this._effect._timing = a.normalizeTimingInput(this._effect._timingInput), this._effect.activeDuration = a.calculateActiveDuration(this._effect._timing), this._effect._animation && this._effect._animation._rebuildUnderlyingAnimation());
},
get playbackRate() {
return this._playbackRate;
},
set delay(a) {
this._setMember('delay', a);
},
get delay() {
return this._delay;
},
set endDelay(a) {
this._setMember('endDelay', a);
},
get endDelay() {
return this._endDelay;
},
set fill(a) {
this._setMember('fill', a);
},
get fill() {
return this._fill;
},
set iterationStart(a) {
if ((isNaN(a) || a < 0) && e())
throw new TypeError('iterationStart must be a non-negative number, received: ' + timing.iterationStart);
this._setMember('iterationStart', a);
},
get iterationStart() {
return this._iterationStart;
},
set duration(a) {
if ('auto' != a && (isNaN(a) || a < 0) && e())
throw new TypeError('duration must be non-negative or auto, received: ' + a);
this._setMember('duration', a);
},
get duration() {
return this._duration;
},
set direction(a) {
this._setMember('direction', a);
},
get direction() {
return this._direction;
},
set easing(a) {
this._easingFunction = l(k(a)), this._setMember('easing', a);
},
get easing() {
return this._easing;
},
set iterations(a) {
if ((isNaN(a) || a < 0) && e())
throw new TypeError('iterations must be non-negative, received: ' + a);
this._setMember('iterations', a);
},
get iterations() {
return this._iterations;
}
};
var y = 1, z = 0.5, A = 0, B = {
ease: i(0.25, 0.1, 0.25, 1),
'ease-in': i(0.42, 0, 1, 1),
'ease-out': i(0, 0, 0.58, 1),
'ease-in-out': i(0.42, 0, 0.58, 1),
'step-start': j(1, y),
'step-middle': j(1, z),
'step-end': j(1, A)
}, C = null, D = '\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*', E = new RegExp('cubic-bezier\\(' + D + ',' + D + ',' + D + ',' + D + '\\)'), F = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/, G = 0, H = 1, I = 2, J = 3;
a.cloneTimingInput = c, a.makeTiming = f, a.numericTimingToObject = g, a.normalizeTimingInput = h, a.calculateActiveDuration = m, a.calculateIterationProgress = u, a.calculatePhase = o, a.normalizeEasing = k, a.parseEasingFunction = l;
}(c), function (a, b) {
function c(a, b) {
return a in k ? k[a][b] || b : b;
}
function d(a) {
return 'display' === a || 0 === a.lastIndexOf('animation', 0) || 0 === a.lastIndexOf('transition', 0);
}
function e(a, b, e) {
if (!d(a)) {
var f = h[a];
if (f) {
i.style[a] = b;
for (var g in f) {
var j = f[g], k = i.style[j];
e[j] = c(j, k);
}
} else
e[a] = c(a, b);
}
}
function f(a) {
var b = [];
for (var c in a)
if (!(c in [
'easing',
'offset',
'composite'
])) {
var d = a[c];
Array.isArray(d) || (d = [d]);
for (var e, f = d.length, g = 0; g < f; g++)
e = {}, e.offset = 'offset' in a ? a.offset : 1 == f ? 1 : g / (f - 1), 'easing' in a && (e.easing = a.easing), 'composite' in a && (e.composite = a.composite), e[c] = d[g], b.push(e);
}
return b.sort(function (a, b) {
return a.offset - b.offset;
}), b;
}
function g(b) {
function c() {
var a = d.length;
null == d[a - 1].offset && (d[a - 1].offset = 1), a > 1 && null == d[0].offset && (d[0].offset = 0);
for (var b = 0, c = d[0].offset, e = 1; e < a; e++) {
var f = d[e].offset;
if (null != f) {
for (var g = 1; g < e - b; g++)
d[b + g].offset = c + (f - c) * g / (e - b);
b = e, c = f;
}
}
}
if (null == b)
return [];
window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || (b = f(b));
for (var d = b.map(function (b) {
var c = {};
for (var d in b) {
var f = b[d];
if ('offset' == d) {
if (null != f) {
if (f = Number(f), !isFinite(f))
throw new TypeError('Keyframe offsets must be numbers.');
if (f < 0 || f > 1)
throw new TypeError('Keyframe offsets must be between 0 and 1.');
}
} else if ('composite' == d) {
if ('add' == f || 'accumulate' == f)
throw {
type: DOMException.NOT_SUPPORTED_ERR,
name: 'NotSupportedError',
message: 'add compositing is not supported'
};
if ('replace' != f)
throw new TypeError('Invalid composite mode ' + f + '.');
} else
f = 'easing' == d ? a.normalizeEasing(f) : '' + f;
e(d, f, c);
}
return void 0 == c.offset && (c.offset = null), void 0 == c.easing && (c.easing = 'linear'), c;
}), g = !0, h = -1 / 0, i = 0; i < d.length; i++) {
var j = d[i].offset;
if (null != j) {
if (j < h)
throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.');
h = j;
} else
g = !1;
}
return d = d.filter(function (a) {
return a.offset >= 0 && a.offset <= 1;
}), g || c(), d;
}
var h = {
background: [
'backgroundImage',
'backgroundPosition',
'backgroundSize',
'backgroundRepeat',
'backgroundAttachment',
'backgroundOrigin',
'backgroundClip',
'backgroundColor'
],
border: [
'borderTopColor',
'borderTopStyle',
'borderTopWidth',
'borderRightColor',
'borderRightStyle',
'borderRightWidth',
'borderBottomColor',
'borderBottomStyle',
'borderBottomWidth',
'borderLeftColor',
'borderLeftStyle',
'borderLeftWidth'
],
borderBottom: [
'borderBottomWidth',
'borderBottomStyle',
'borderBottomColor'
],
borderColor: [
'borderTopColor',
'borderRightColor',
'borderBottomColor',
'borderLeftColor'
],
borderLeft: [
'borderLeftWidth',
'borderLeftStyle',
'borderLeftColor'
],
borderRadius: [
'borderTopLeftRadius',
'borderTopRightRadius',
'borderBottomRightRadius',
'borderBottomLeftRadius'
],
borderRight: [
'borderRightWidth',
'borderRightStyle',
'borderRightColor'
],
borderTop: [
'borderTopWidth',
'borderTopStyle',
'borderTopColor'
],
borderWidth: [
'borderTopWidth',
'borderRightWidth',
'borderBottomWidth',
'borderLeftWidth'
],
flex: [
'flexGrow',
'flexShrink',
'flexBasis'
],
font: [
'fontFamily',
'fontSize',
'fontStyle',
'fontVariant',
'fontWeight',
'lineHeight'
],
margin: [
'marginTop',
'marginRight',
'marginBottom',
'marginLeft'
],
outline: [
'outlineColor',
'outlineStyle',
'outlineWidth'
],
padding: [
'paddingTop',
'paddingRight',
'paddingBottom',
'paddingLeft'
]
}, i = document.createElementNS('http://www.w3.org/1999/xhtml', 'div'), j = {
thin: '1px',
medium: '3px',
thick: '5px'
}, k = {
borderBottomWidth: j,
borderLeftWidth: j,
borderRightWidth: j,
borderTopWidth: j,
fontSize: {
'xx-small': '60%',
'x-small': '75%',
small: '89%',
medium: '100%',
large: '120%',
'x-large': '150%',
'xx-large': '200%'
},
fontWeight: {
normal: '400',
bold: '700'
},
outlineWidth: j,
textShadow: { none: '0px 0px 0px transparent' },
boxShadow: { none: '0px 0px 0px 0px transparent' }
};
a.convertToArrayForm = f, a.normalizeKeyframes = g;
}(c), function (a) {
var b = {};
a.isDeprecated = function (a, c, d, e) {
var f = e ? 'are' : 'is', g = new Date(), h = new Date(c);
return h.setMonth(h.getMonth() + 3), !(g < h && (a in b || console.warn('Web Animations: ' + a + ' ' + f + ' deprecated and will stop working on ' + h.toDateString() + '. ' + d), b[a] = !0, 1));
}, a.deprecated = function (b, c, d, e) {
var f = e ? 'are' : 'is';
if (a.isDeprecated(b, c, d, e))
throw new Error(b + ' ' + f + ' no longer supported. ' + d);
};
}(c), function () {
if (document.documentElement.animate) {
var a = document.documentElement.animate([], 0), b = !0;
if (a && (b = !1, 'play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState'.split('|').forEach(function (c) {
void 0 === a[c] && (b = !0);
})), !b)
return;
}
!function (a, b, c) {
function d(a) {
for (var b = {}, c = 0; c < a.length; c++)
for (var d in a[c])
if ('offset' != d && 'easing' != d && 'composite' != d) {
var e = {
offset: a[c].offset,
easing: a[c].easing,
value: a[c][d]
};
b[d] = b[d] || [], b[d].push(e);
}
for (var f in b) {
var g = b[f];
if (0 != g[0].offset || 1 != g[g.length - 1].offset)
throw {
type: DOMException.NOT_SUPPORTED_ERR,
name: 'NotSupportedError',
message: 'Partial keyframes are not supported'
};
}
return b;
}
function e(c) {
var d = [];
for (var e in c)
for (var f = c[e], g = 0; g < f.length - 1; g++) {
var h = g, i = g + 1, j = f[h].offset, k = f[i].offset, l = j, m = k;
0 == g && (l = -1 / 0, 0 == k && (i = h)), g == f.length - 2 && (m = 1 / 0, 1 == j && (h = i)), d.push({
applyFrom: l,
applyTo: m,
startOffset: f[h].offset,
endOffset: f[i].offset,
easingFunction: a.parseEasingFunction(f[h].easing),
property: e,
interpolation: b.propertyInterpolation(e, f[h].value, f[i].value)
});
}
return d.sort(function (a, b) {
return a.startOffset - b.startOffset;
}), d;
}
b.convertEffectInput = function (c) {
var f = a.normalizeKeyframes(c), g = d(f), h = e(g);
return function (a, c) {
if (null != c)
h.filter(function (a) {
return c >= a.applyFrom && c < a.applyTo;
}).forEach(function (d) {
var e = c - d.startOffset, f = d.endOffset - d.startOffset, g = 0 == f ? 0 : d.easingFunction(e / f);
b.apply(a, d.property, d.interpolation(g));
});
else
for (var d in g)
'offset' != d && 'easing' != d && 'composite' != d && b.clear(a, d);
};
};
}(c, d), function (a, b, c) {
function d(a) {
return a.replace(/-(.)/g, function (a, b) {
return b.toUpperCase();
});
}
function e(a, b, c) {
h[c] = h[c] || [], h[c].push([
a,
b
]);
}
function f(a, b, c) {
for (var f = 0; f < c.length; f++) {
e(a, b, d(c[f]));
}
}
function g(c, e, f) {
var g = c;
/-/.test(c) && !a.isDeprecated('Hyphenated property names', '2016-03-22', 'Use camelCase instead.', !0) && (g = d(c)), 'initial' != e && 'initial' != f || ('initial' == e && (e = i[g]), 'initial' == f && (f = i[g]));
for (var j = e == f ? [] : h[g], k = 0; j && k < j.length; k++) {
var l = j[k][0](e), m = j[k][0](f);
if (void 0 !== l && void 0 !== m) {
var n = j[k][1](l, m);
if (n) {
var o = b.Interpolation.apply(null, n);
return function (a) {
return 0 == a ? e : 1 == a ? f : o(a);
};
}
}
}
return b.Interpolation(!1, !0, function (a) {
return a ? f : e;
});
}
var h = {};
b.addPropertiesHandler = f;
var i = {
backgroundColor: 'transparent',
backgroundPosition: '0% 0%',
borderBottomColor: 'currentColor',
borderBottomLeftRadius: '0px',
borderBottomRightRadius: '0px',
borderBottomWidth: '3px',
borderLeftColor: 'currentColor',
borderLeftWidth: '3px',
borderRightColor: 'currentColor',
borderRightWidth: '3px',
borderSpacing: '2px',
borderTopColor: 'currentColor',
borderTopLeftRadius: '0px',
borderTopRightRadius: '0px',
borderTopWidth: '3px',
bottom: 'auto',
clip: 'rect(0px, 0px, 0px, 0px)',
color: 'black',
fontSize: '100%',
fontWeight: '400',
height: 'auto',
left: 'auto',
letterSpacing: 'normal',
lineHeight: '120%',
marginBottom: '0px',
marginLeft: '0px',
marginRight: '0px',
marginTop: '0px',
maxHeight: 'none',
maxWidth: 'none',
minHeight: '0px',
minWidth: '0px',
opacity: '1.0',
outlineColor: 'invert',
outlineOffset: '0px',
outlineWidth: '3px',
paddingBottom: '0px',
paddingLeft: '0px',
paddingRight: '0px',
paddingTop: '0px',
right: 'auto',
strokeDasharray: 'none',
strokeDashoffset: '0px',
textIndent: '0px',
textShadow: '0px 0px 0px transparent',
top: 'auto',
transform: '',
verticalAlign: '0px',
visibility: 'visible',
width: 'auto',
wordSpacing: 'normal',
zIndex: 'auto'
};
b.propertyInterpolation = g;
}(c, d), function (a, b, c) {
function d(b) {
var c = a.calculateActiveDuration(b), d = function (d) {
return a.calculateIterationProgress(c, d, b);
};
return d._totalDuration = b.delay + c + b.endDelay, d;
}
b.KeyframeEffect = function (c, e, f, g) {
var h, i = d(a.normalizeTimingInput(f)), j = b.convertEffectInput(e), k = function () {
j(c, h);
};
return k._update = function (a) {
return null !== (h = i(a));
}, k._clear = function () {
j(c, null);
}, k._hasSameTarget = function (a) {
return c === a;
}, k._target = c, k._totalDuration = i._totalDuration, k._id = g, k;
};
}(c, d), function (a, b) {
a.apply = function (b, c, d) {
b.style[a.propertyName(c)] = d;
}, a.clear = function (b, c) {
b.style[a.propertyName(c)] = '';
};
}(d), function (a) {
window.Element.prototype.animate = function (b, c) {
var d = '';
return c && c.id && (d = c.id), a.timeline._play(a.KeyframeEffect(this, b, c, d));
};
}(d), function (a, b) {
function c(a, b, d) {
if ('number' == typeof a && 'number' == typeof b)
return a * (1 - d) + b * d;
if ('boolean' == typeof a && 'boolean' == typeof b)
return d < 0.5 ? a : b;
if (a.length == b.length) {
for (var e = [], f = 0; f < a.length; f++)
e.push(c(a[f], b[f], d));
return e;
}
throw 'Mismatched interpolation arguments ' + a + ':' + b;
}
a.Interpolation = function (a, b, d) {
return function (e) {
return d(c(a, b, e));
};
};
}(d), function (a, b, c) {
a.sequenceNumber = 0;
var d = function (a, b, c) {
this.target = a, this.currentTime = b, this.timelineTime = c, this.type = 'finish', this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
};
b.Animation = function (b) {
this.id = '', b && b._id && (this.id = b._id), this._sequenceNumber = a.sequenceNumber++, this._currentTime = 0, this._startTime = null, this._paused = !1, this._playbackRate = 1, this._inTimeline = !0, this._finishedFlag = !0, this.onfinish = null, this._finishHandlers = [], this._effect = b, this._inEffect = this._effect._update(0), this._idle = !0, this._currentTimePending = !1;
}, b.Animation.prototype = {
_ensureAlive: function () {
this.playbackRate < 0 && 0 === this.currentTime ? this._inEffect = this._effect._update(-1) : this._inEffect = this._effect._update(this.currentTime), this._inTimeline || !this._inEffect && this._finishedFlag || (this._inTimeline = !0, b.timeline._animations.push(this));
},
_tickCurrentTime: function (a, b) {
a != this._currentTime && (this._currentTime = a, this._isFinished && !b && (this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0), this._ensureAlive());
},
get currentTime() {
return this._idle || this._currentTimePending ? null : this._currentTime;
},
set currentTime(a) {
a = +a, isNaN(a) || (b.restart(), this._paused || null == this._startTime || (this._startTime = this._timeline.currentTime - a / this._playbackRate), this._currentTimePending = !1, this._currentTime != a && (this._idle && (this._idle = !1, this._paused = !0), this._tickCurrentTime(a, !0), b.applyDirtiedAnimation(this)));
},
get startTime() {
return this._startTime;
},
set startTime(a) {
a = +a, isNaN(a) || this._paused || this._idle || (this._startTime = a, this._tickCurrentTime((this._timeline.currentTime - this._startTime) * this.playbackRate), b.applyDirtiedAnimation(this));
},
get playbackRate() {
return this._playbackRate;
},
set playbackRate(a) {
if (a != this._playbackRate) {
var c = this.currentTime;
this._playbackRate = a, this._startTime = null, 'paused' != this.playState && 'idle' != this.playState && (this._finishedFlag = !1, this._idle = !1, this._ensureAlive(), b.applyDirtiedAnimation(this)), null != c && (this.currentTime = c);
}
},
get _isFinished() {
return !this._idle && (this._playbackRate > 0 && this._currentTime >= this._totalDuration || this._playbackRate < 0 && this._currentTime <= 0);
},
get _totalDuration() {
return this._effect._totalDuration;
},
get playState() {
return this._idle ? 'idle' : null == this._startTime && !this._paused && 0 != this.playbackRate || this._currentTimePending ? 'pending' : this._paused ? 'paused' : this._isFinished ? 'finished' : 'running';
},
_rewind: function () {
if (this._playbackRate >= 0)
this._currentTime = 0;
else {
if (!(this._totalDuration < 1 / 0))
throw new DOMException('Unable to rewind negative playback rate animation with infinite duration', 'InvalidStateError');
this._currentTime = this._totalDuration;
}
},
play: function () {
this._paused = !1, (this._isFinished || this._idle) && (this._rewind(), this._startTime = null), this._finishedFlag = !1, this._idle = !1, this._ensureAlive(), b.applyDirtiedAnimation(this);
},
pause: function () {
this._isFinished || this._paused || this._idle ? this._idle && (this._rewind(), this._idle = !1) : this._currentTimePending = !0, this._startTime = null, this._paused = !0;
},
finish: function () {
this._idle || (this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0, this._startTime = this._totalDuration - this.currentTime, this._currentTimePending = !1, b.applyDirtiedAnimation(this));
},
cancel: function () {
this._inEffect && (this._inEffect = !1, this._idle = !0, this._paused = !1, this._isFinished = !0, this._finishedFlag = !0, this._currentTime = 0, this._startTime = null, this._effect._update(null), b.applyDirtiedAnimation(this));
},
reverse: function () {
this.playbackRate *= -1, this.play();
},
addEventListener: function (a, b) {
'function' == typeof b && 'finish' == a && this._finishHandlers.push(b);
},
removeEventListener: function (a, b) {
if ('finish' == a) {
var c = this._finishHandlers.indexOf(b);
c >= 0 && this._finishHandlers.splice(c, 1);
}
},
_fireEvents: function (a) {
if (this._isFinished) {
if (!this._finishedFlag) {
var b = new d(this, this._currentTime, a), c = this._finishHandlers.concat(this.onfinish ? [this.onfinish] : []);
setTimeout(function () {
c.forEach(function (a) {
a.call(b.target, b);
});
}, 0), this._finishedFlag = !0;
}
} else
this._finishedFlag = !1;
},
_tick: function (a, b) {
this._idle || this._paused || (null == this._startTime ? b && (this.startTime = a - this._currentTime / this.playbackRate) : this._isFinished || this._tickCurrentTime((a - this._startTime) * this.playbackRate)), b && (this._currentTimePending = !1, this._fireEvents(a));
},
get _needsTick() {
return this.playState in {
pending: 1,
running: 1
} || !this._finishedFlag;
},
_targetAnimations: function () {
var a = this._effect._target;
return a._activeAnimations || (a._activeAnimations = []), a._activeAnimations;
},
_markTarget: function () {
var a = this._targetAnimations();
-1 === a.indexOf(this) && a.push(this);
},
_unmarkTarget: function () {
var a = this._targetAnimations(), b = a.indexOf(this);
-1 !== b && a.splice(b, 1);
}
};
}(c, d), function (a, b, c) {
function d(a) {
var b = j;
j = [], a < q.currentTime && (a = q.currentTime), q._animations.sort(e), q._animations = h(a, !0, q._animations)[0], b.forEach(function (b) {
b[1](a);
}), g(), l = void 0;
}
function e(a, b) {
return a._sequenceNumber - b._sequenceNumber;
}
function f() {
this._animations = [], this.currentTime = window.performance && performance.now ? performance.now() : 0;
}
function g() {
o.forEach(function (a) {
a();
}), o.length = 0;
}
function h(a, c, d) {
p = !0, n = !1, b.timeline.currentTime = a, m = !1;
var e = [], f = [], g = [], h = [];
return d.forEach(function (b) {
b._tick(a, c), b._inEffect ? (f.push(b._effect), b._markTarget()) : (e.push(b._effect), b._unmarkTarget()), b._needsTick && (m = !0);
var d = b._inEffect || b._needsTick;
b._inTimeline = d, d ? g.push(b) : h.push(b);
}), o.push.apply(o, e), o.push.apply(o, f), m && requestAnimationFrame(function () {
}), p = !1, [
g,
h
];
}
var i = window.requestAnimationFrame, j = [], k = 0;
window.requestAnimationFrame = function (a) {
var b = k++;
return 0 == j.length && i(d), j.push([
b,
a
]), b;
}, window.cancelAnimationFrame = function (a) {
j.forEach(function (b) {
b[0] == a && (b[1] = function () {
});
});
}, f.prototype = {
_play: function (c) {
c._timing = a.normalizeTimingInput(c.timing);
var d = new b.Animation(c);
return d._idle = !1, d._timeline = this, this._animations.push(d), b.restart(), b.applyDirtiedAnimation(d), d;
}
};
var l = void 0, m = !1, n = !1;
b.restart = function () {
return m || (m = !0, requestAnimationFrame(function () {
}), n = !0), n;
}, b.applyDirtiedAnimation = function (a) {
if (!p) {
a._markTarget();
var c = a._targetAnimations();
c.sort(e), h(b.timeline.currentTime, !1, c.slice())[1].forEach(function (a) {
var b = q._animations.indexOf(a);
-1 !== b && q._animations.splice(b, 1);
}), g();
}
};
var o = [], p = !1, q = new f();
b.timeline = q;
}(c, d), function (a) {
function b(a, b) {
var c = a.exec(b);
if (c)
return c = a.ignoreCase ? c[0].toLowerCase() : c[0], [
c,
b.substr(c.length)
];
}
function c(a, b) {
b = b.replace(/^\s*/, '');
var c = a(b);
if (c)
return [
c[0],
c[1].replace(/^\s*/, '')
];
}
function d(a, d, e) {
a = c.bind(null, a);
for (var f = [];;) {
var g = a(e);
if (!g)
return [
f,
e
];
if (f.push(g[0]), e = g[1], !(g = b(d, e)) || '' == g[1])
return [
f,
e
];
e = g[1];
}
}
function e(a, b) {
for (var c = 0, d = 0; d < b.length && (!/\s|,/.test(b[d]) || 0 != c); d++)
if ('(' == b[d])
c++;
else if (')' == b[d] && (c--, 0 == c && d++, c <= 0))
break;
var e = a(b.substr(0, d));
return void 0 == e ? void 0 : [
e,
b.substr(d)
];
}
function f(a, b) {
for (var c = a, d = b; c && d;)
c > d ? c %= d : d %= c;
return c = a * b / (c + d);
}
function g(a) {
return function (b) {
var c = a(b);
return c && (c[0] = void 0), c;
};
}
function h(a, b) {
return function (c) {
return a(c) || [
b,
c
];
};
}
function i(b, c) {
for (var d = [], e = 0; e < b.length; e++) {
var f = a.consumeTrimmed(b[e], c);
if (!f || '' == f[0])
return;
void 0 !== f[0] && d.push(f[0]), c = f[1];
}
if ('' == c)
return d;
}
function j(a, b, c, d, e) {
for (var g = [], h = [], i = [], j = f(d.length, e.length), k = 0; k < j; k++) {
var l = b(d[k % d.length], e[k % e.length]);
if (!l)
return;
g.push(l[0]), h.push(l[1]), i.push(l[2]);
}
return [
g,
h,
function (b) {
var d = b.map(function (a, b) {
return i[b](a);
}).join(c);
return a ? a(d) : d;
}
];
}
function k(a, b, c) {
for (var d = [], e = [], f = [], g = 0, h = 0; h < c.length; h++)
if ('function' == typeof c[h]) {
var i = c[h](a[g], b[g++]);
d.push(i[0]), e.push(i[1]), f.push(i[2]);
} else
!function (a) {
d.push(!1), e.push(!1), f.push(function () {
return c[a];
});
}(h);
return [
d,
e,
function (a) {
for (var b = '', c = 0; c < a.length; c++)
b += f[c](a[c]);
return b;
}
];
}
a.consumeToken = b, a.consumeTrimmed = c, a.consumeRepeated = d, a.consumeParenthesised = e, a.ignore = g, a.optional = h, a.consumeList = i, a.mergeNestedRepeated = j.bind(null, null), a.mergeWrappedNestedRepeated = j, a.mergeList = k;
}(d), function (a) {
function b(b) {
function c(b) {
var c = a.consumeToken(/^inset/i, b);
if (c)
return d.inset = !0, c;
var c = a.consumeLengthOrPercent(b);
if (c)
return d.lengths.push(c[0]), c;
var c = a.consumeColor(b);
return c ? (d.color = c[0], c) : void 0;
}
var d = {
inset: !1,
lengths: [],
color: null
}, e = a.consumeRepeated(c, /^/, b);
if (e && e[0].length)
return [
d,
e[1]
];
}
function c(c) {
var d = a.consumeRepeated(b, /^,/, c);
if (d && '' == d[1])
return d[0];
}
function d(b, c) {
for (; b.lengths.length < Math.max(b.lengths.length, c.lengths.length);)
b.lengths.push({ px: 0 });
for (; c.lengths.length < Math.max(b.lengths.length, c.lengths.length);)
c.lengths.push({ px: 0 });
if (b.inset == c.inset && !!b.color == !!c.color) {
for (var d, e = [], f = [
[],
0
], g = [
[],
0
], h = 0; h < b.lengths.length; h++) {
var i = a.mergeDimensions(b.lengths[h], c.lengths[h], 2 == h);
f[0].push(i[0]), g[0].push(i[1]), e.push(i[2]);
}
if (b.color && c.color) {
var j = a.mergeColors(b.color, c.color);
f[1] = j[0], g[1] = j[1], d = j[2];
}
return [
f,
g,
function (a) {
for (var c = b.inset ? 'inset ' : ' ', f = 0; f < e.length; f++)
c += e[f](a[0][f]) + ' ';
return d && (c += d(a[1])), c;
}
];
}
}
function e(b, c, d, e) {
function f(a) {
return {
inset: a,
color: [
0,
0,
0,
0
],
lengths: [
{ px: 0 },
{ px: 0 },
{ px: 0 },
{ px: 0 }
]
};
}
for (var g = [], h = [], i = 0; i < d.length || i < e.length; i++) {
var j = d[i] || f(e[i].inset), k = e[i] || f(d[i].inset);
g.push(j), h.push(k);
}
return a.mergeNestedRepeated(b, c, g, h);
}
var f = e.bind(null, d, ', ');
a.addPropertiesHandler(c, f, [
'box-shadow',
'text-shadow'
]);
}(d), function (a, b) {
function c(a) {
return a.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
}
function d(a, b, c) {
return Math.min(b, Math.max(a, c));
}
function e(a) {
if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))
return Number(a);
}
function f(a, b) {
return [
a,
b,
c
];
}
function g(a, b) {
if (0 != a)
return i(0, 1 / 0)(a, b);
}
function h(a, b) {
return [
a,
b,
function (a) {
return Math.round(d(1, 1 / 0, a));
}
];
}
function i(a, b) {
return function (e, f) {
return [
e,
f,
function (e) {
return c(d(a, b, e));
}
];
};
}
function j(a) {
var b = a.trim().split(/\s*[\s,]\s*/);
if (0 !== b.length) {
for (var c = [], d = 0; d < b.length; d++) {
var f = e(b[d]);
if (void 0 === f)
return;
c.push(f);
}
return c;
}
}
function k(a, b) {
if (a.length == b.length)
return [
a,
b,
function (a) {
return a.map(c).join(' ');
}
];
}
function l(a, b) {
return [
a,
b,
Math.round
];
}
a.clamp = d, a.addPropertiesHandler(j, k, ['stroke-dasharray']), a.addPropertiesHandler(e, i(0, 1 / 0), [
'border-image-width',
'line-height'
]), a.addPropertiesHandler(e, i(0, 1), [
'opacity',
'shape-image-threshold'
]), a.addPropertiesHandler(e, g, [
'flex-grow',
'flex-shrink'
]), a.addPropertiesHandler(e, h, [
'orphans',
'widows'
]), a.addPropertiesHandler(e, l, ['z-index']), a.parseNumber = e, a.parseNumberList = j, a.mergeNumbers = f, a.numberToString = c;
}(d), function (a, b) {
function c(a, b) {
if ('visible' == a || 'visible' == b)
return [
0,
1,
function (c) {
return c <= 0 ? a : c >= 1 ? b : 'visible';
}
];
}
a.addPropertiesHandler(String, c, ['visibility']);
}(d), function (a, b) {
function c(a) {
a = a.trim(), f.fillStyle = '#000', f.fillStyle = a;
var b = f.fillStyle;
if (f.fillStyle = '#fff', f.fillStyle = a, b == f.fillStyle) {
f.fillRect(0, 0, 1, 1);
var c = f.getImageData(0, 0, 1, 1).data;
f.clearRect(0, 0, 1, 1);
var d = c[3] / 255;
return [
c[0] * d,
c[1] * d,
c[2] * d,
d
];
}
}
function d(b, c) {
return [
b,
c,
function (b) {
function c(a) {
return Math.max(0, Math.min(255, a));
}
if (b[3])
for (var d = 0; d < 3; d++)
b[d] = Math.round(c(b[d] / b[3]));
return b[3] = a.numberToString(a.clamp(0, 1, b[3])), 'rgba(' + b.join(',') + ')';
}
];
}
var e = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
e.width = e.height = 1;
var f = e.getContext('2d');
a.addPropertiesHandler(c, d, [
'background-color',
'border-bottom-color',
'border-left-color',
'border-right-color',
'border-top-color',
'color',
'fill',
'flood-color',
'lighting-color',
'outline-color',
'stop-color',
'stroke',
'text-decoration-color'
]), a.consumeColor = a.consumeParenthesised.bind(null, c), a.mergeColors = d;
}(d), function (a, b) {
function c(a) {
function b() {
var b = h.exec(a);
g = b ? b[0] : void 0;
}
function c() {
var a = Number(g);
return b(), a;
}
function d() {
if ('(' !== g)
return c();
b();
var a = f();
return ')' !== g ? NaN : (b(), a);
}
function e() {
for (var a = d(); '*' === g || '/' === g;) {
var c = g;
b();
var e = d();
'*' === c ? a *= e : a /= e;
}
return a;
}
function f() {
for (var a = e(); '+' === g || '-' === g;) {
var c = g;
b();
var d = e();
'+' === c ? a += d : a -= d;
}
return a;
}
var g, h = /([\+\-\w\.]+|[\(\)\*\/])/g;
return b(), f();
}
function d(a, b) {
if ('0' == (b = b.trim().toLowerCase()) && 'px'.search(a) >= 0)
return { px: 0 };
if (/^[^(]*$|^calc/.test(b)) {
b = b.replace(/calc\(/g, '(');
var d = {};
b = b.replace(a, function (a) {
return d[a] = null, 'U' + a;
});
for (var e = 'U(' + a.source + ')', f = b.replace(/[-+]?(\d*\.)?\d+([Ee][-+]?\d+)?/g, 'N').replace(new RegExp('N' + e, 'g'), 'D').replace(/\s[+-]\s/g, 'O').replace(/\s/g, ''), g = [
/N\*(D)/g,
/(N|D)[*\/]N/g,
/(N|D)O\1/g,
/\((N|D)\)/g
], h = 0; h < g.length;)
g[h].test(f) ? (f = f.replace(g[h], '$1'), h = 0) : h++;
if ('D' == f) {
for (var i in d) {
var j = c(b.replace(new RegExp('U' + i, 'g'), '').replace(new RegExp(e, 'g'), '*0'));
if (!isFinite(j))
return;
d[i] = j;
}
return d;
}
}
}
function e(a, b) {
return f(a, b, !0);
}
function f(b, c, d) {
var e, f = [];
for (e in b)
f.push(e);
for (e in c)
f.indexOf(e) < 0 && f.push(e);
return b = f.map(function (a) {
return b[a] || 0;
}), c = f.map(function (a) {
return c[a] || 0;
}), [
b,
c,
function (b) {
var c = b.map(function (c, e) {
return 1 == b.length && d && (c = Math.max(c, 0)), a.numberToString(c) + f[e];
}).join(' + ');
return b.length > 1 ? 'calc(' + c + ')' : c;
}
];
}
var g = 'px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc', h = d.bind(null, new RegExp(g, 'g')), i = d.bind(null, new RegExp(g + '|%', 'g')), j = d.bind(null, /deg|rad|grad|turn/g);
a.parseLength = h, a.parseLengthOrPercent = i, a.consumeLengthOrPercent = a.consumeParenthesised.bind(null, i), a.parseAngle = j, a.mergeDimensions = f;
var k = a.consumeParenthesised.bind(null, h), l = a.consumeRepeated.bind(void 0, k, /^/), m = a.consumeRepeated.bind(void 0, l, /^,/);
a.consumeSizePairList = m;
var n = function (a) {
var b = m(a);
if (b && '' == b[1])
return b[0];
}, o = a.mergeNestedRepeated.bind(void 0, e, ' '), p = a.mergeNestedRepeated.bind(void 0, o, ',');
a.mergeNonNegativeSizePair = o, a.addPropertiesHandler(n, p, ['background-size']), a.addPropertiesHandler(i, e, [
'border-bottom-width',
'border-image-width',
'border-left-width',
'border-right-width',
'border-top-width',
'flex-basis',
'font-size',
'height',
'line-height',
'max-height',
'max-width',
'outline-width',
'width'
]), a.addPropertiesHandler(i, f, [
'border-bottom-left-radius',
'border-bottom-right-radius',
'border-top-left-radius',
'border-top-right-radius',
'bottom',
'left',
'letter-spacing',
'margin-bottom',
'margin-left',
'margin-right',
'margin-top',
'min-height',
'min-width',
'outline-offset',
'padding-bottom',
'padding-left',
'padding-right',
'padding-top',
'perspective',
'right',
'shape-margin',
'stroke-dashoffset',
'text-indent',
'top',
'vertical-align',
'word-spacing'
]);
}(d), function (a, b) {
function c(b) {
return a.consumeLengthOrPercent(b) || a.consumeToken(/^auto/, b);
}
function d(b) {
var d = a.consumeList([
a.ignore(a.consumeToken.bind(null, /^rect/)),
a.ignore(a.consumeToken.bind(null, /^\(/)),
a.consumeRepeated.bind(null, c, /^,/),
a.ignore(a.consumeToken.bind(null, /^\)/))
], b);
if (d && 4 == d[0].length)
return d[0];
}
function e(b, c) {
return 'auto' == b || 'auto' == c ? [
!0,
!1,
function (d) {
var e = d ? b : c;
if ('auto' == e)
return 'auto';
var f = a.mergeDimensions(e, e);
return f[2](f[0]);
}
] : a.mergeDimensions(b, c);
}
function f(a) {
return 'rect(' + a + ')';
}
var g = a.mergeWrappedNestedRepeated.bind(null, f, e, ', ');
a.parseBox = d, a.mergeBoxes = g, a.addPropertiesHandler(d, g, ['clip']);
}(d), function (a, b) {
function c(a) {
return function (b) {
var c = 0;
return a.map(function (a) {
return a === k ? b[c++] : a;
});
};
}
function d(a) {
return a;
}
function e(b) {
if ('none' == (b = b.toLowerCase().trim()))
return [];
for (var c, d = /\s*(\w+)\(([^)]*)\)/g, e = [], f = 0; c = d.exec(b);) {
if (c.index != f)
return;
f = c.index + c[0].length;
var g = c[1], h = n[g];
if (!h)
return;
var i = c[2].split(','), j = h[0];
if (j.length < i.length)
return;
for (var k = [], o = 0; o < j.length; o++) {
var p, q = i[o], r = j[o];
if (void 0 === (p = q ? {
A: function (b) {
return '0' == b.trim() ? m : a.parseAngle(b);
},
N: a.parseNumber,
T: a.parseLengthOrPercent,
L: a.parseLength
}[r.toUpperCase()](q) : {
a: m,
n: k[0],
t: l
}[r]))
return;
k.push(p);
}
if (e.push({
t: g,
d: k
}), d.lastIndex == b.length)
return e;
}
}
function f(a) {
return a.toFixed(6).replace('.000000', '');
}
function g(b, c) {
if (b.decompositionPair !== c) {
b.decompositionPair = c;
var d = a.makeMatrixDecomposition(b);
}
if (c.decompositionPair !== b) {
c.decompositionPair = b;
var e = a.makeMatrixDecomposition(c);
}
return null == d[0] || null == e[0] ? [
[!1],
[!0],
function (a) {
return a ? c[0].d : b[0].d;
}
] : (d[0].push(0), e[0].push(1), [
d,
e,
function (b) {
var c = a.quat(d[0][3], e[0][3], b[5]);
return a.composeMatrix(b[0], b[1], b[2], c, b[4]).map(f).join(',');
}
]);
}
function h(a) {
return a.replace(/[xy]/, '');
}
function i(a) {
return a.replace(/(x|y|z|3d)?$/, '3d');
}
function j(b, c) {
var d = a.makeMatrixDecomposition && !0, e = !1;
if (!b.length || !c.length) {
b.length || (e = !0, b = c, c = []);
for (var f = 0; f < b.length; f++) {
var j = b[f].t, k = b[f].d, l = 'scale' == j.substr(0, 5) ? 1 : 0;
c.push({
t: j,
d: k.map(function (a) {
if ('number' == typeof a)
return l;
var b = {};
for (var c in a)
b[c] = l;
return b;
})
});
}
}
var m = function (a, b) {
return 'perspective' == a && 'perspective' == b || ('matrix' == a || 'matrix3d' == a) && ('matrix' == b || 'matrix3d' == b);
}, o = [], p = [], q = [];
if (b.length != c.length) {
if (!d)
return;
var r = g(b, c);
o = [r[0]], p = [r[1]], q = [[
'matrix',
[r[2]]
]];
} else
for (var f = 0; f < b.length; f++) {
var j, s = b[f].t, t = c[f].t, u = b[f].d, v = c[f].d, w = n[s], x = n[t];
if (m(s, t)) {
if (!d)
return;
var r = g([b[f]], [c[f]]);
o.push(r[0]), p.push(r[1]), q.push([
'matrix',
[r[2]]
]);
} else {
if (s == t)
j = s;
else if (w[2] && x[2] && h(s) == h(t))
j = h(s), u = w[2](u), v = x[2](v);
else {
if (!w[1] || !x[1] || i(s) != i(t)) {
if (!d)
return;
var r = g(b, c);
o = [r[0]], p = [r[1]], q = [[
'matrix',
[r[2]]
]];
break;
}
j = i(s), u = w[1](u), v = x[1](v);
}
for (var y = [], z = [], A = [], B = 0; B < u.length; B++) {
var C = 'number' == typeof u[B] ? a.mergeNumbers : a.mergeDimensions, r = C(u[B], v[B]);
y[B] = r[0], z[B] = r[1], A.push(r[2]);
}
o.push(y), p.push(z), q.push([
j,
A
]);
}
}
if (e) {
var D = o;
o = p, p = D;
}
return [
o,
p,
function (a) {
return a.map(function (a, b) {
var c = a.map(function (a, c) {
return q[b][1][c](a);
}).join(',');
return 'matrix' == q[b][0] && 16 == c.split(',').length && (q[b][0] = 'matrix3d'), q[b][0] + '(' + c + ')';
}).join(' ');
}
];
}
var k = null, l = { px: 0 }, m = { deg: 0 }, n = {
matrix: [
'NNNNNN',
[
k,
k,
0,
0,
k,
k,
0,
0,
0,
0,
1,
0,
k,
k,
0,
1
],
d
],
matrix3d: [
'NNNNNNNNNNNNNNNN',
d
],
rotate: ['A'],
rotatex: ['A'],
rotatey: ['A'],
rotatez: ['A'],
rotate3d: ['NNNA'],
perspective: ['L'],
scale: [
'Nn',
c([
k,
k,
1
]),
d
],
scalex: [
'N',
c([
k,
1,
1
]),
c([
k,
1
])
],
scaley: [
'N',
c([
1,
k,
1
]),
c([
1,
k
])
],
scalez: [
'N',
c([
1,
1,
k
])
],
scale3d: [
'NNN',
d
],
skew: [
'Aa',
null,
d
],
skewx: [
'A',
null,
c([
k,
m
])
],
skewy: [
'A',
null,
c([
m,
k
])
],
translate: [
'Tt',
c([
k,
k,
l
]),
d
],
translatex: [
'T',
c([
k,
l,
l
]),
c([
k,
l
])
],
translatey: [
'T',
c([
l,
k,
l
]),
c([
l,
k
])
],
translatez: [
'L',
c([
l,
l,
k
])
],
translate3d: [
'TTL',
d
]
};
a.addPropertiesHandler(e, j, ['transform']), a.transformToSvgMatrix = function (b) {
var c = a.transformListToMatrix(e(b));
return 'matrix(' + f(c[0]) + ' ' + f(c[1]) + ' ' + f(c[4]) + ' ' + f(c[5]) + ' ' + f(c[12]) + ' ' + f(c[13]) + ')';
};
}(d), function (a, b) {
function c(a, b) {
b.concat([a]).forEach(function (b) {
b in document.documentElement.style && (d[a] = b), e[b] = a;
});
}
var d = {}, e = {};
c('transform', [
'webkitTransform',
'msTransform'
]), c('transformOrigin', ['webkitTransformOrigin']), c('perspective', ['webkitPerspective']), c('perspectiveOrigin', ['webkitPerspectiveOrigin']), a.propertyName = function (a) {
return d[a] || a;
}, a.unprefixedPropertyName = function (a) {
return e[a] || a;
};
}(d);
}(), function () {
if (void 0 === document.createElement('div').animate([]).oncancel) {
var a;
if (window.performance && performance.now)
var a = function () {
return performance.now();
};
else
var a = function () {
return Date.now();
};
var b = function (a, b, c) {
this.target = a, this.currentTime = b, this.timelineTime = c, this.type = 'cancel', this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
}, c = window.Element.prototype.animate;
window.Element.prototype.animate = function (d, e) {
var f = c.call(this, d, e);
f._cancelHandlers = [], f.oncancel = null;
var g = f.cancel;
f.cancel = function () {
g.call(this);
var c = new b(this, null, a()), d = this._cancelHandlers.concat(this.oncancel ? [this.oncancel] : []);
setTimeout(function () {
d.forEach(function (a) {
a.call(c.target, c);
});
}, 0);
};
var h = f.addEventListener;
f.addEventListener = function (a, b) {
'function' == typeof b && 'cancel' == a ? this._cancelHandlers.push(b) : h.call(this, a, b);
};
var i = f.removeEventListener;
return f.removeEventListener = function (a, b) {
if ('cancel' == a) {
var c = this._cancelHandlers.indexOf(b);
c >= 0 && this._cancelHandlers.splice(c, 1);
} else
i.call(this, a, b);
}, f;
};
}
}(), function (a) {
var b = document.documentElement, c = null, d = !1;
try {
var e = getComputedStyle(b).getPropertyValue('opacity'), f = '0' == e ? '1' : '0';
c = b.animate({
opacity: [
f,
f
]
}, { duration: 1 }), c.currentTime = 0, d = getComputedStyle(b).getPropertyValue('opacity') == f;
} catch (a) {
} finally {
c && c.cancel();
}
if (!d) {
var g = window.Element.prototype.animate;
window.Element.prototype.animate = function (b, c) {
return window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || null === b || (b = a.convertToArrayForm(b)), g.call(this, b, c);
};
}
}(c), function (a, b, c) {
function d(a) {
var c = b.timeline;
c.currentTime = a, c._discardAnimations(), 0 == c._animations.length ? f = !1 : requestAnimationFrame(d);
}
var e = window.requestAnimationFrame;
window.requestAnimationFrame = function (a) {
return e(function (c) {
b.timeline._updateAnimationsPromises(), a(c), b.timeline._updateAnimationsPromises();
});
}, b.AnimationTimeline = function () {
this._animations = [], this.currentTime = void 0;
}, b.AnimationTimeline.prototype = {
getAnimations: function () {
return this._discardAnimations(), this._animations.slice();
},
_updateAnimationsPromises: function () {
b.animationsWithPromises = b.animationsWithPromises.filter(function (a) {
return a._updatePromises();
});
},
_discardAnimations: function () {
this._updateAnimationsPromises(), this._animations = this._animations.filter(function (a) {
return 'finished' != a.playState && 'idle' != a.playState;
});
},
_play: function (a) {
var c = new b.Animation(a, this);
return this._animations.push(c), b.restartWebAnimationsNextTick(), c._updatePromises(), c._animation.play(), c._updatePromises(), c;
},
play: function (a) {
return a && a.remove(), this._play(a);
}
};
var f = !1;
b.restartWebAnimationsNextTick = function () {
f || (f = !0, requestAnimationFrame(d));
};
var g = new b.AnimationTimeline();
b.timeline = g;
try {
Object.defineProperty(window.document, 'timeline', {
configurable: !0,
get: function () {
return g;
}
});
} catch (a) {
}
try {
window.document.timeline = g;
} catch (a) {
}
}(0, e), function (a, b, c) {
b.animationsWithPromises = [], b.Animation = function (b, c) {
if (this.id = '', b && b._id && (this.id = b._id), this.effect = b, b && (b._animation = this), !c)
throw new Error('Animation with null timeline is not supported');
this._timeline = c, this._sequenceNumber = a.sequenceNumber++, this._holdTime = 0, this._paused = !1, this._isGroup = !1, this._animation = null, this._childAnimations = [], this._callback = null, this._oldPlayState = 'idle', this._rebuildUnderlyingAnimation(), this._animation.cancel(), this._updatePromises();
}, b.Animation.prototype = {
_updatePromises: function () {
var a = this._oldPlayState, b = this.playState;
return this._readyPromise && b !== a && ('idle' == b ? (this._rejectReadyPromise(), this._readyPromise = void 0) : 'pending' == a ? this._resolveReadyPromise() : 'pending' == b && (this._readyPromise = void 0)), this._finishedPromise && b !== a && ('idle' == b ? (this._rejectFinishedPromise(), this._finishedPromise = void 0) : 'finished' == b ? this._resolveFinishedPromise() : 'finished' == a && (this._finishedPromise = void 0)), this._oldPlayState = this.playState, this._readyPromise || this._finishedPromise;
},
_rebuildUnderlyingAnimation: function () {
this._updatePromises();
var a, c, d, e, f = !!this._animation;
f && (a = this.playbackRate, c = this._paused, d = this.startTime, e = this.currentTime, this._animation.cancel(), this._animation._wrapper = null, this._animation = null), (!this.effect || this.effect instanceof window.KeyframeEffect) && (this._animation = b.newUnderlyingAnimationForKeyframeEffect(this.effect), b.bindAnimationForKeyframeEffect(this)), (this.effect instanceof window.SequenceEffect || this.effect instanceof window.GroupEffect) && (this._animation = b.newUnderlyingAnimationForGroup(this.effect), b.bindAnimationForGroup(this)), this.effect && this.effect._onsample && b.bindAnimationForCustomEffect(this), f && (1 != a && (this.playbackRate = a), null !== d ? this.startTime = d : null !== e ? this.currentTime = e : null !== this._holdTime && (this.currentTime = this._holdTime), c && this.pause()), this._updatePromises();
},
_updateChildren: function () {
if (this.effect && 'idle' != this.playState) {
var a = this.effect._timing.delay;
this._childAnimations.forEach(function (c) {
this._arrangeChildren(c, a), this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c.effect));
}.bind(this));
}
},
_setExternalAnimation: function (a) {
if (this.effect && this._isGroup)
for (var b = 0; b < this.effect.children.length; b++)
this.effect.children[b]._animation = a, this._childAnimations[b]._setExternalAnimation(a);
},
_constructChildAnimations: function () {
if (this.effect && this._isGroup) {
var a = this.effect._timing.delay;
this._removeChildAnimations(), this.effect.children.forEach(function (c) {
var d = b.timeline._play(c);
this._childAnimations.push(d), d.playbackRate = this.playbackRate, this._paused && d.pause(), c._animation = this.effect._animation, this._arrangeChildren(d, a), this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c));
}.bind(this));
}
},
_arrangeChildren: function (a, b) {
null === this.startTime ? a.currentTime = this.currentTime - b / this.playbackRate : a.startTime !== this.startTime + b / this.playbackRate && (a.startTime = this.startTime + b / this.playbackRate);
},
get timeline() {
return this._timeline;
},
get playState() {
return this._animation ? this._animation.playState : 'idle';
},
get finished() {
return window.Promise ? (this._finishedPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._finishedPromise = new Promise(function (a, b) {
this._resolveFinishedPromise = function () {
a(this);
}, this._rejectFinishedPromise = function () {
b({
type: DOMException.ABORT_ERR,
name: 'AbortError'
});
};
}.bind(this)), 'finished' == this.playState && this._resolveFinishedPromise()), this._finishedPromise) : (console.warn('Animation Promises require JavaScript Promise constructor'), null);
},
get ready() {
return window.Promise ? (this._readyPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._readyPromise = new Promise(function (a, b) {
this._resolveReadyPromise = function () {
a(this);
}, this._rejectReadyPromise = function () {
b({
type: DOMException.ABORT_ERR,
name: 'AbortError'
});
};
}.bind(this)), 'pending' !== this.playState && this._resolveReadyPromise()), this._readyPromise) : (console.warn('Animation Promises require JavaScript Promise constructor'), null);
},
get onfinish() {
return this._animation.onfinish;
},
set onfinish(a) {
this._animation.onfinish = 'function' == typeof a ? function (b) {
b.target = this, a.call(this, b);
}.bind(this) : a;
},
get oncancel() {
return this._animation.oncancel;
},
set oncancel(a) {
this._animation.oncancel = 'function' == typeof a ? function (b) {
b.target = this, a.call(this, b);
}.bind(this) : a;
},
get currentTime() {
this._updatePromises();
var a = this._animation.currentTime;
return this._updatePromises(), a;
},
set currentTime(a) {
this._updatePromises(), this._animation.currentTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE, this._register(), this._forEachChild(function (b, c) {
b.currentTime = a - c;
}), this._updatePromises();
},
get startTime() {
return this._animation.startTime;
},
set startTime(a) {
this._updatePromises(), this._animation.startTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE, this._register(), this._forEachChild(function (b, c) {
b.startTime = a + c;
}), this._updatePromises();
},
get playbackRate() {
return this._animation.playbackRate;
},
set playbackRate(a) {
this._updatePromises();
var b = this.currentTime;
this._animation.playbackRate = a, this._forEachChild(function (b) {
b.playbackRate = a;
}), null !== b && (this.currentTime = b), this._updatePromises();
},
play: function () {
this._updatePromises(), this._paused = !1, this._animation.play(), -1 == this._timeline._animations.indexOf(this) && this._timeline._animations.push(this), this._register(), b.awaitStartTime(this), this._forEachChild(function (a) {
var b = a.currentTime;
a.play(), a.currentTime = b;
}), this._updatePromises();
},
pause: function () {
this._updatePromises(), this.currentTime && (this._holdTime = this.currentTime), this._animation.pause(), this._register(), this._forEachChild(function (a) {
a.pause();
}), this._paused = !0, this._updatePromises();
},
finish: function () {
this._updatePromises(), this._animation.finish(), this._register(), this._updatePromises();
},
cancel: function () {
this._updatePromises(), this._animation.cancel(), this._register(), this._removeChildAnimations(), this._updatePromises();
},
reverse: function () {
this._updatePromises();
var a = this.currentTime;
this._animation.reverse(), this._forEachChild(function (a) {
a.reverse();
}), null !== a && (this.currentTime = a), this._updatePromises();
},
addEventListener: function (a, b) {
var c = b;
'function' == typeof b && (c = function (a) {
a.target = this, b.call(this, a);
}.bind(this), b._wrapper = c), this._animation.addEventListener(a, c);
},
removeEventListener: function (a, b) {
this._animation.removeEventListener(a, b && b._wrapper || b);
},
_removeChildAnimations: function () {
for (; this._childAnimations.length;)
this._childAnimations.pop().cancel();
},
_forEachChild: function (b) {
var c = 0;
if (this.effect.children && this._childAnimations.length < this.effect.children.length && this._constructChildAnimations(), this._childAnimations.forEach(function (a) {
b.call(this, a, c), this.effect instanceof window.SequenceEffect && (c += a.effect.activeDuration);
}.bind(this)), 'pending' != this.playState) {
var d = this.effect._timing, e = this.currentTime;
null !== e && (e = a.calculateIterationProgress(a.calculateActiveDuration(d), e, d)), (null == e || isNaN(e)) && this._removeChildAnimations();
}
}
}, window.Animation = b.Animation;
}(c, e), function (a, b, c) {
function d(b) {
this._frames = a.normalizeKeyframes(b);
}
function e() {
for (var a = !1; i.length;)
i.shift()._updateChildren(), a = !0;
return a;
}
var f = function (a) {
if (a._animation = void 0, a instanceof window.SequenceEffect || a instanceof window.GroupEffect)
for (var b = 0; b < a.children.length; b++)
f(a.children[b]);
};
b.removeMulti = function (a) {
for (var b = [], c = 0; c < a.length; c++) {
var d = a[c];
d._parent ? (-1 == b.indexOf(d._parent) && b.push(d._parent), d._parent.children.splice(d._parent.children.indexOf(d), 1), d._parent = null, f(d)) : d._animation && d._animation.effect == d && (d._animation.cancel(), d._animation.effect = new KeyframeEffect(null, []), d._animation._callback && (d._animation._callback._animation = null), d._animation._rebuildUnderlyingAnimation(), f(d));
}
for (c = 0; c < b.length; c++)
b[c]._rebuild();
}, b.KeyframeEffect = function (b, c, e, f) {
return this.target = b, this._parent = null, e = a.numericTimingToObject(e), this._timingInput = a.cloneTimingInput(e), this._timing = a.normalizeTimingInput(e), this.timing = a.makeTiming(e, !1, this), this.timing._effect = this, 'function' == typeof c ? (a.deprecated('Custom KeyframeEffect', '2015-06-22', 'Use KeyframeEffect.onsample instead.'), this._normalizedKeyframes = c) : this._normalizedKeyframes = new d(c), this._keyframes = c, this.activeDuration = a.calculateActiveDuration(this._timing), this._id = f, this;
}, b.KeyframeEffect.prototype = {
getFrames: function () {
return 'function' == typeof this._normalizedKeyframes ? this._normalizedKeyframes : this._normalizedKeyframes._frames;
},
set onsample(a) {
if ('function' == typeof this.getFrames())
throw new Error('Setting onsample on custom effect KeyframeEffect is not supported.');
this._onsample = a, this._animation && this._animation._rebuildUnderlyingAnimation();
},
get parent() {
return this._parent;
},
clone: function () {
if ('function' == typeof this.getFrames())
throw new Error('Cloning custom effects is not supported.');
var b = new KeyframeEffect(this.target, [], a.cloneTimingInput(this._timingInput), this._id);
return b._normalizedKeyframes = this._normalizedKeyframes, b._keyframes = this._keyframes, b;
},
remove: function () {
b.removeMulti([this]);
}
};
var g = Element.prototype.animate;
Element.prototype.animate = function (a, c) {
var d = '';
return c && c.id && (d = c.id), b.timeline._play(new b.KeyframeEffect(this, a, c, d));
};
var h = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
b.newUnderlyingAnimationForKeyframeEffect = function (a) {
if (a) {
var b = a.target || h, c = a._keyframes;
'function' == typeof c && (c = []);
var d = a._timingInput;
d.id = a._id;
} else
var b = h, c = [], d = 0;
return g.apply(b, [
c,
d
]);
}, b.bindAnimationForKeyframeEffect = function (a) {
a.effect && 'function' == typeof a.effect._normalizedKeyframes && b.bindAnimationForCustomEffect(a);
};
var i = [];
b.awaitStartTime = function (a) {
null === a.startTime && a._isGroup && (0 == i.length && requestAnimationFrame(e), i.push(a));
};
var j = window.getComputedStyle;
Object.defineProperty(window, 'getComputedStyle', {
configurable: !0,
enumerable: !0,
value: function () {
b.timeline._updateAnimationsPromises();
var a = j.apply(this, arguments);
return e() && (a = j.apply(this, arguments)), b.timeline._updateAnimationsPromises(), a;
}
}), window.KeyframeEffect = b.KeyframeEffect, window.Element.prototype.getAnimations = function () {
return document.timeline.getAnimations().filter(function (a) {
return null !== a.effect && a.effect.target == this;
}.bind(this));
};
}(c, e), function (a, b, c) {
function d(a) {
a._registered || (a._registered = !0, g.push(a), h || (h = !0, requestAnimationFrame(e)));
}
function e(a) {
var b = g;
g = [], b.sort(function (a, b) {
return a._sequenceNumber - b._sequenceNumber;
}), b = b.filter(function (a) {
a();
var b = a._animation ? a._animation.playState : 'idle';
return 'running' != b && 'pending' != b && (a._registered = !1), a._registered;
}), g.push.apply(g, b), g.length ? (h = !0, requestAnimationFrame(e)) : h = !1;
}
var f = (document.createElementNS('http://www.w3.org/1999/xhtml', 'div'), 0);
b.bindAnimationForCustomEffect = function (b) {
var c, e = b.effect.target, g = 'function' == typeof b.effect.getFrames();
c = g ? b.effect.getFrames() : b.effect._onsample;
var h = b.effect.timing, i = null;
h = a.normalizeTimingInput(h);
var j = function () {
var d = j._animation ? j._animation.currentTime : null;
null !== d && (d = a.calculateIterationProgress(a.calculateActiveDuration(h), d, h), isNaN(d) && (d = null)), d !== i && (g ? c(d, e, b.effect) : c(d, b.effect, b.effect._animation)), i = d;
};
j._animation = b, j._registered = !1, j._sequenceNumber = f++, b._callback = j, d(j);
};
var g = [], h = !1;
b.Animation.prototype._register = function () {
this._callback && d(this._callback);
};
}(c, e), function (a, b, c) {
function d(a) {
return a._timing.delay + a.activeDuration + a._timing.endDelay;
}
function e(b, c, d) {
this._id = d, this._parent = null, this.children = b || [], this._reparent(this.children), c = a.numericTimingToObject(c), this._timingInput = a.cloneTimingInput(c), this._timing = a.normalizeTimingInput(c, !0), this.timing = a.makeTiming(c, !0, this), this.timing._effect = this, 'auto' === this._timing.duration && (this._timing.duration = this.activeDuration);
}
window.SequenceEffect = function () {
e.apply(this, arguments);
}, window.GroupEffect = function () {
e.apply(this, arguments);
}, e.prototype = {
_isAncestor: function (a) {
for (var b = this; null !== b;) {
if (b == a)
return !0;
b = b._parent;
}
return !1;
},
_rebuild: function () {
for (var a = this; a;)
'auto' === a.timing.duration && (a._timing.duration = a.activeDuration), a = a._parent;
this._animation && this._animation._rebuildUnderlyingAnimation();
},
_reparent: function (a) {
b.removeMulti(a);
for (var c = 0; c < a.length; c++)
a[c]._parent = this;
},
_putChild: function (a, b) {
for (var c = b ? 'Cannot append an ancestor or self' : 'Cannot prepend an ancestor or self', d = 0; d < a.length; d++)
if (this._isAncestor(a[d]))
throw {
type: DOMException.HIERARCHY_REQUEST_ERR,
name: 'HierarchyRequestError',
message: c
};
for (var d = 0; d < a.length; d++)
b ? this.children.push(a[d]) : this.children.unshift(a[d]);
this._reparent(a), this._rebuild();
},
append: function () {
this._putChild(arguments, !0);
},
prepend: function () {
this._putChild(arguments, !1);
},
get parent() {
return this._parent;
},
get firstChild() {
return this.children.length ? this.children[0] : null;
},
get lastChild() {
return this.children.length ? this.children[this.children.length - 1] : null;
},
clone: function () {
for (var b = a.cloneTimingInput(this._timingInput), c = [], d = 0; d < this.children.length; d++)
c.push(this.children[d].clone());
return this instanceof GroupEffect ? new GroupEffect(c, b) : new SequenceEffect(c, b);
},
remove: function () {
b.removeMulti([this]);
}
}, window.SequenceEffect.prototype = Object.create(e.prototype), Object.defineProperty(window.SequenceEffect.prototype, 'activeDuration', {
get: function () {
var a = 0;
return this.children.forEach(function (b) {
a += d(b);
}), Math.max(a, 0);
}
}), window.GroupEffect.prototype = Object.create(e.prototype), Object.defineProperty(window.GroupEffect.prototype, 'activeDuration', {
get: function () {
var a = 0;
return this.children.forEach(function (b) {
a = Math.max(a, d(b));
}), a;
}
}), b.newUnderlyingAnimationForGroup = function (c) {
var d, e = null, f = function (b) {
var c = d._wrapper;
if (c && 'pending' != c.playState && c.effect)
return null == b ? void c._removeChildAnimations() : 0 == b && c.playbackRate < 0 && (e || (e = a.normalizeTimingInput(c.effect.timing)), b = a.calculateIterationProgress(a.calculateActiveDuration(e), -1, e), isNaN(b) || null == b) ? (c._forEachChild(function (a) {
a.currentTime = -1;
}), void c._removeChildAnimations()) : void 0;
}, g = new KeyframeEffect(null, [], c._timing, c._id);
return g.onsample = f, d = b.timeline._play(g);
}, b.bindAnimationForGroup = function (a) {
a._animation._wrapper = a, a._isGroup = !0, b.awaitStartTime(a), a._constructChildAnimations(), a._setExternalAnimation(a);
}, b.groupChildDuration = d;
}(c, e), b.true = a;
}({}, function () {
return this;
}());
Polymer({
is: 'opaque-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
this._effect = new KeyframeEffect(node, [
{ 'opacity': '1' },
{ 'opacity': '1' }
], this.timingFromConfig(config));
node.style.opacity = '0';
return this._effect;
},
complete: function (config) {
config.node.style.opacity = '';
}
});
(function () {
'use strict';
var lastTouchPosition = {
pageX: 0,
pageY: 0
};
var lastRootTarget = null;
var lastScrollableNodes = [];
var scrollEvents = [
'wheel',
'mousewheel',
'DOMMouseScroll',
'touchstart',
'touchmove'
];
Polymer.IronDropdownScrollManager = {
get currentLockingElement() {
return this._lockingElements[this._lockingElements.length - 1];
},
elementIsScrollLocked: function (element) {
var currentLockingElement = this.currentLockingElement;
if (currentLockingElement === undefined)
return false;
var scrollLocked;
if (this._hasCachedLockedElement(element)) {
return true;
}
if (this._hasCachedUnlockedElement(element)) {
return false;
}
scrollLocked = !!currentLockingElement && currentLockingElement !== element && !this._composedTreeContains(currentLockingElement, element);
if (scrollLocked) {
this._lockedElementCache.push(element);
} else {
this._unlockedElementCache.push(element);
}
return scrollLocked;
},
pushScrollLock: function (element) {
if (this._lockingElements.indexOf(element) >= 0) {
return;
}
if (this._lockingElements.length === 0) {
this._lockScrollInteractions();
}
this._lockingElements.push(element);
this._lockedElementCache = [];
this._unlockedElementCache = [];
},
removeScrollLock: function (element) {
var index = this._lockingElements.indexOf(element);
if (index === -1) {
return;
}
this._lockingElements.splice(index, 1);
this._lockedElementCache = [];
this._unlockedElementCache = [];
if (this._lockingElements.length === 0) {
this._unlockScrollInteractions();
}
},
_lockingElements: [],
_lockedElementCache: null,
_unlockedElementCache: null,
_hasCachedLockedElement: function (element) {
return this._lockedElementCache.indexOf(element) > -1;
},
_hasCachedUnlockedElement: function (element) {
return this._unlockedElementCache.indexOf(element) > -1;
},
_composedTreeContains: function (element, child) {
var contentElements;
var distributedNodes;
var contentIndex;
var nodeIndex;
if (element.contains(child)) {
return true;
}
contentElements = Polymer.dom(element).querySelectorAll('content');
for (contentIndex = 0; contentIndex < contentElements.length; ++contentIndex) {
distributedNodes = Polymer.dom(contentElements[contentIndex]).getDistributedNodes();
for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {
if (this._composedTreeContains(distributedNodes[nodeIndex], child)) {
return true;
}
}
}
return false;
},
_scrollInteractionHandler: function (event) {
if (event.cancelable && this._shouldPreventScrolling(event)) {
event.preventDefault();
}
if (event.targetTouches) {
var touch = event.targetTouches[0];
lastTouchPosition.pageX = touch.pageX;
lastTouchPosition.pageY = touch.pageY;
}
},
_lockScrollInteractions: function () {
this._boundScrollHandler = this._boundScrollHandler || this._scrollInteractionHandler.bind(this);
for (var i = 0, l = scrollEvents.length; i < l; i++) {
document.addEventListener(scrollEvents[i], this._boundScrollHandler, {
capture: true,
passive: false
});
}
},
_unlockScrollInteractions: function () {
for (var i = 0, l = scrollEvents.length; i < l; i++) {
document.removeEventListener(scrollEvents[i], this._boundScrollHandler, {
capture: true,
passive: false
});
}
},
_shouldPreventScrolling: function (event) {
var target = Polymer.dom(event).rootTarget;
if (event.type !== 'touchmove' && lastRootTarget !== target) {
lastRootTarget = target;
lastScrollableNodes = this._getScrollableNodes(Polymer.dom(event).path);
}
if (!lastScrollableNodes.length) {
return true;
}
if (event.type === 'touchstart') {
return false;
}
var info = this._getScrollInfo(event);
return !this._getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);
},
_getScrollableNodes: function (nodes) {
var scrollables = [];
var lockingIndex = nodes.indexOf(this.currentLockingElement);
for (var i = 0; i <= lockingIndex; i++) {
if (nodes[i].nodeType !== Node.ELEMENT_NODE) {
continue;
}
var node = nodes[i];
var style = node.style;
if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
style = window.getComputedStyle(node);
}
if (style.overflow === 'scroll' || style.overflow === 'auto') {
scrollables.push(node);
}
}
return scrollables;
},
_getScrollingNode: function (nodes, deltaX, deltaY) {
if (!deltaX && !deltaY) {
return;
}
var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);
for (var i = 0; i < nodes.length; i++) {
var node = nodes[i];
var canScroll = false;
if (verticalScroll) {
canScroll = deltaY < 0 ? node.scrollTop > 0 : node.scrollTop < node.scrollHeight - node.clientHeight;
} else {
canScroll = deltaX < 0 ? node.scrollLeft > 0 : node.scrollLeft < node.scrollWidth - node.clientWidth;
}
if (canScroll) {
return node;
}
}
},
_getScrollInfo: function (event) {
var info = {
deltaX: event.deltaX,
deltaY: event.deltaY
};
if ('deltaX' in event) {
} else if ('wheelDeltaX' in event) {
info.deltaX = -event.wheelDeltaX;
info.deltaY = -event.wheelDeltaY;
} else if ('axis' in event) {
info.deltaX = event.axis === 1 ? event.detail : 0;
info.deltaY = event.axis === 2 ? event.detail : 0;
} else if (event.targetTouches) {
var touch = event.targetTouches[0];
info.deltaX = lastTouchPosition.pageX - touch.pageX;
info.deltaY = lastTouchPosition.pageY - touch.pageY;
}
return info;
}
};
}());
(function () {
'use strict';
Polymer({
is: 'iron-dropdown',
behaviors: [
Polymer.IronControlState,
Polymer.IronA11yKeysBehavior,
Polymer.IronOverlayBehavior,
Polymer.NeonAnimationRunnerBehavior
],
properties: {
horizontalAlign: {
type: String,
value: 'left',
reflectToAttribute: true
},
verticalAlign: {
type: String,
value: 'top',
reflectToAttribute: true
},
openAnimationConfig: { type: Object },
closeAnimationConfig: { type: Object },
focusTarget: { type: Object },
noAnimations: {
type: Boolean,
value: false
},
allowOutsideScroll: {
type: Boolean,
value: false
},
_boundOnCaptureScroll: {
type: Function,
value: function () {
return this._onCaptureScroll.bind(this);
}
}
},
listeners: { 'neon-animation-finish': '_onNeonAnimationFinish' },
observers: ['_updateOverlayPosition(positionTarget, verticalAlign, horizontalAlign, verticalOffset, horizontalOffset)'],
get containedElement() {
return Polymer.dom(this.$.content).getDistributedNodes()[0];
},
get _focusTarget() {
return this.focusTarget || this.containedElement;
},
ready: function () {
this._scrollTop = 0;
this._scrollLeft = 0;
this._refitOnScrollRAF = null;
},
attached: function () {
if (!this.sizingTarget || this.sizingTarget === this) {
this.sizingTarget = this.containedElement || this;
}
},
detached: function () {
this.cancelAnimation();
document.removeEventListener('scroll', this._boundOnCaptureScroll);
Polymer.IronDropdownScrollManager.removeScrollLock(this);
},
_openedChanged: function () {
if (this.opened && this.disabled) {
this.cancel();
} else {
this.cancelAnimation();
this._updateAnimationConfig();
this._saveScrollPosition();
if (this.opened) {
document.addEventListener('scroll', this._boundOnCaptureScroll);
!this.allowOutsideScroll && Polymer.IronDropdownScrollManager.pushScrollLock(this);
} else {
document.removeEventListener('scroll', this._boundOnCaptureScroll);
Polymer.IronDropdownScrollManager.removeScrollLock(this);
}
Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
}
},
_renderOpened: function () {
if (!this.noAnimations && this.animationConfig.open) {
this.$.contentWrapper.classList.add('animating');
this.playAnimation('open');
} else {
Polymer.IronOverlayBehaviorImpl._renderOpened.apply(this, arguments);
}
},
_renderClosed: function () {
if (!this.noAnimations && this.animationConfig.close) {
this.$.contentWrapper.classList.add('animating');
this.playAnimation('close');
} else {
Polymer.IronOverlayBehaviorImpl._renderClosed.apply(this, arguments);
}
},
_onNeonAnimationFinish: function () {
this.$.contentWrapper.classList.remove('animating');
if (this.opened) {
this._finishRenderOpened();
} else {
this._finishRenderClosed();
}
},
_onCaptureScroll: function () {
if (!this.allowOutsideScroll) {
this._restoreScrollPosition();
} else {
this._refitOnScrollRAF && window.cancelAnimationFrame(this._refitOnScrollRAF);
this._refitOnScrollRAF = window.requestAnimationFrame(this.refit.bind(this));
}
},
_saveScrollPosition: function () {
if (document.scrollingElement) {
this._scrollTop = document.scrollingElement.scrollTop;
this._scrollLeft = document.scrollingElement.scrollLeft;
} else {
this._scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
this._scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);
}
},
_restoreScrollPosition: function () {
if (document.scrollingElement) {
document.scrollingElement.scrollTop = this._scrollTop;
document.scrollingElement.scrollLeft = this._scrollLeft;
} else {
document.documentElement.scrollTop = this._scrollTop;
document.documentElement.scrollLeft = this._scrollLeft;
document.body.scrollTop = this._scrollTop;
document.body.scrollLeft = this._scrollLeft;
}
},
_updateAnimationConfig: function () {
var animationNode = this.containedElement;
var animations = [].concat(this.openAnimationConfig || []).concat(this.closeAnimationConfig || []);
for (var i = 0; i < animations.length; i++) {
animations[i].node = animationNode;
}
this.animationConfig = {
open: this.openAnimationConfig,
close: this.closeAnimationConfig
};
},
_updateOverlayPosition: function () {
if (this.isAttached) {
this.notifyResize();
}
},
_applyFocus: function () {
var focusTarget = this.focusTarget || this.containedElement;
if (focusTarget && this.opened && !this.noAutoFocus) {
focusTarget.focus();
} else {
Polymer.IronOverlayBehaviorImpl._applyFocus.apply(this, arguments);
}
}
});
}());
Polymer({
is: 'fade-in-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
this._effect = new KeyframeEffect(node, [
{ 'opacity': '0' },
{ 'opacity': '1' }
], this.timingFromConfig(config));
return this._effect;
}
});
Polymer({
is: 'fade-out-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
this._effect = new KeyframeEffect(node, [
{ 'opacity': '1' },
{ 'opacity': '0' }
], this.timingFromConfig(config));
return this._effect;
}
});
Polymer({
is: 'paper-menu-grow-height-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
var rect = node.getBoundingClientRect();
var height = rect.height;
this._effect = new KeyframeEffect(node, [
{ height: height / 2 + 'px' },
{ height: height + 'px' }
], this.timingFromConfig(config));
return this._effect;
}
});
Polymer({
is: 'paper-menu-grow-width-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
var rect = node.getBoundingClientRect();
var width = rect.width;
this._effect = new KeyframeEffect(node, [
{ width: width / 2 + 'px' },
{ width: width + 'px' }
], this.timingFromConfig(config));
return this._effect;
}
});
Polymer({
is: 'paper-menu-shrink-width-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
var rect = node.getBoundingClientRect();
var width = rect.width;
this._effect = new KeyframeEffect(node, [
{ width: width + 'px' },
{ width: width - width / 20 + 'px' }
], this.timingFromConfig(config));
return this._effect;
}
});
Polymer({
is: 'paper-menu-shrink-height-animation',
behaviors: [Polymer.NeonAnimationBehavior],
configure: function (config) {
var node = config.node;
var rect = node.getBoundingClientRect();
var height = rect.height;
var top = rect.top;
this.setPrefixedProperty(node, 'transformOrigin', '0 0');
this._effect = new KeyframeEffect(node, [
{
height: height + 'px',
transform: 'translateY(0)'
},
{
height: height / 2 + 'px',
transform: 'translateY(-20px)'
}
], this.timingFromConfig(config));
return this._effect;
}
});
(function () {
'use strict';
var config = {
ANIMATION_CUBIC_BEZIER: 'cubic-bezier(.3,.95,.5,1)',
MAX_ANIMATION_TIME_MS: 400
};
var PaperMenuButton = Polymer({
is: 'paper-menu-button',
behaviors: [
Polymer.IronA11yKeysBehavior,
Polymer.IronControlState
],
properties: {
opened: {
type: Boolean,
value: false,
notify: true,
observer: '_openedChanged'
},
horizontalAlign: {
type: String,
value: 'left',
reflectToAttribute: true
},
verticalAlign: {
type: String,
value: 'top',
reflectToAttribute: true
},
dynamicAlign: { type: Boolean },
horizontalOffset: {
type: Number,
value: 0,
notify: true
},
verticalOffset: {
type: Number,
value: 0,
notify: true
},
noOverlap: { type: Boolean },
noAnimations: {
type: Boolean,
value: false
},
ignoreSelect: {
type: Boolean,
value: false
},
closeOnActivate: {
type: Boolean,
value: false
},
openAnimationConfig: {
type: Object,
value: function () {
return [
{
name: 'fade-in-animation',
timing: {
delay: 100,
duration: 200
}
},
{
name: 'paper-menu-grow-width-animation',
timing: {
delay: 100,
duration: 150,
easing: config.ANIMATION_CUBIC_BEZIER
}
},
{
name: 'paper-menu-grow-height-animation',
timing: {
delay: 100,
duration: 275,
easing: config.ANIMATION_CUBIC_BEZIER
}
}
];
}
},
closeAnimationConfig: {
type: Object,
value: function () {
return [
{
name: 'fade-out-animation',
timing: { duration: 150 }
},
{
name: 'paper-menu-shrink-width-animation',
timing: {
delay: 100,
duration: 50,
easing: config.ANIMATION_CUBIC_BEZIER
}
},
{
name: 'paper-menu-shrink-height-animation',
timing: {
duration: 200,
easing: 'ease-in'
}
}
];
}
},
allowOutsideScroll: {
type: Boolean,
value: false
},
restoreFocusOnClose: {
type: Boolean,
value: true
},
_dropdownContent: { type: Object }
},
hostAttributes: {
role: 'group',
'aria-haspopup': 'true'
},
listeners: {
'iron-activate': '_onIronActivate',
'iron-select': '_onIronSelect'
},
get contentElement() {
return Polymer.dom(this.$.content).getDistributedNodes()[0];
},
toggle: function () {
if (this.opened) {
this.close();
} else {
this.open();
}
},
open: function () {
if (this.disabled) {
return;
}
this.$.dropdown.open();
},
close: function () {
this.$.dropdown.close();
},
_onIronSelect: function (event) {
if (!this.ignoreSelect) {
this.close();
}
},
_onIronActivate: function (event) {
if (this.closeOnActivate) {
this.close();
}
},
_openedChanged: function (opened, oldOpened) {
if (opened) {
this._dropdownContent = this.contentElement;
this.fire('paper-dropdown-open');
} else if (oldOpened != null) {
this.fire('paper-dropdown-close');
}
},
_disabledChanged: function (disabled) {
Polymer.IronControlState._disabledChanged.apply(this, arguments);
if (disabled && this.opened) {
this.close();
}
},
__onIronOverlayCanceled: function (event) {
var uiEvent = event.detail;
var target = Polymer.dom(uiEvent).rootTarget;
var trigger = this.$.trigger;
var path = Polymer.dom(uiEvent).path;
if (path.indexOf(trigger) > -1) {
event.preventDefault();
}
}
});
Object.keys(config).forEach(function (key) {
PaperMenuButton[key] = config[key];
});
Polymer.PaperMenuButton = PaperMenuButton;
}());
(function () {
'use strict';
Polymer({
is: 'paper-dropdown-menu',
behaviors: [
Polymer.IronButtonState,
Polymer.IronControlState,
Polymer.IronFormElementBehavior,
Polymer.IronValidatableBehavior
],
properties: {
selectedItemLabel: {
type: String,
notify: true,
readOnly: true
},
selectedItem: {
type: Object,
notify: true,
readOnly: true
},
value: {
type: String,
notify: true,
readOnly: true
},
label: { type: String },
placeholder: { type: String },
errorMessage: { type: String },
opened: {
type: Boolean,
notify: true,
value: false,
observer: '_openedChanged'
},
allowOutsideScroll: {
type: Boolean,
value: false
},
noLabelFloat: {
type: Boolean,
value: false,
reflectToAttribute: true
},
alwaysFloatLabel: {
type: Boolean,
value: false
},
noAnimations: {
type: Boolean,
value: false
},
horizontalAlign: {
type: String,
value: 'right'
},
verticalAlign: {
type: String,
value: 'top'
},
dynamicAlign: { type: Boolean },
restoreFocusOnClose: {
type: Boolean,
value: true
}
},
listeners: { 'tap': '_onTap' },
keyBindings: {
'up down': 'open',
'esc': 'close'
},
hostAttributes: {
role: 'combobox',
'aria-autocomplete': 'none',
'aria-haspopup': 'true'
},
observers: ['_selectedItemChanged(selectedItem)'],
attached: function () {
var contentElement = this.contentElement;
if (contentElement && contentElement.selectedItem) {
this._setSelectedItem(contentElement.selectedItem);
}
},
get contentElement() {
return Polymer.dom(this.$.content).getDistributedNodes()[0];
},
open: function () {
this.$.menuButton.open();
},
close: function () {
this.$.menuButton.close();
},
_onIronSelect: function (event) {
this._setSelectedItem(event.detail.item);
},
_onIronDeselect: function (event) {
this._setSelectedItem(null);
},
_onTap: function (event) {
if (Polymer.Gestures.findOriginalTarget(event) === this) {
this.open();
}
},
_selectedItemChanged: function (selectedItem) {
var value = '';
if (!selectedItem) {
value = '';
} else {
value = selectedItem.label || selectedItem.getAttribute('label') || selectedItem.textContent.trim();
}
this._setValue(value);
this._setSelectedItemLabel(value);
},
_computeMenuVerticalOffset: function (noLabelFloat) {
return noLabelFloat ? -4 : 8;
},
_getValidity: function (_value) {
return this.disabled || !this.required || this.required && !!this.value;
},
_openedChanged: function () {
var openState = this.opened ? 'true' : 'false';
var e = this.contentElement;
if (e) {
e.setAttribute('aria-expanded', openState);
}
}
});
}());
(function () {
Polymer({
is: 'paper-listbox',
behaviors: [Polymer.IronMenuBehavior],
hostAttributes: { role: 'listbox' }
});
}());
(function () {
var currentToast = null;
Polymer({
is: 'paper-toast',
behaviors: [Polymer.IronOverlayBehavior],
properties: {
fitInto: {
type: Object,
value: window,
observer: '_onFitIntoChanged'
},
horizontalAlign: {
type: String,
value: 'left'
},
verticalAlign: {
type: String,
value: 'bottom'
},
duration: {
type: Number,
value: 3000
},
text: {
type: String,
value: ''
},
noCancelOnOutsideClick: {
type: Boolean,
value: true
},
noAutoFocus: {
type: Boolean,
value: true
}
},
listeners: { 'transitionend': '__onTransitionEnd' },
get visible() {
Polymer.Base._warn('`visible` is deprecated, use `opened` instead');
return this.opened;
},
get _canAutoClose() {
return this.duration > 0 && this.duration !== Infinity;
},
created: function () {
this._autoClose = null;
Polymer.IronA11yAnnouncer.requestAvailability();
},
show: function (properties) {
if (typeof properties == 'string') {
properties = { text: properties };
}
for (var property in properties) {
if (property.indexOf('_') === 0) {
Polymer.Base._warn('The property "' + property + '" is private and was not set.');
} else if (property in this) {
this[property] = properties[property];
} else {
Polymer.Base._warn('The property "' + property + '" is not valid.');
}
}
this.open();
},
hide: function () {
this.close();
},
__onTransitionEnd: function (e) {
if (e && e.target === this && e.propertyName === 'opacity') {
if (this.opened) {
this._finishRenderOpened();
} else {
this._finishRenderClosed();
}
}
},
_openedChanged: function () {
if (this._autoClose !== null) {
this.cancelAsync(this._autoClose);
this._autoClose = null;
}
if (this.opened) {
if (currentToast && currentToast !== this) {
currentToast.close();
}
currentToast = this;
this.fire('iron-announce', { text: this.text });
if (this._canAutoClose) {
this._autoClose = this.async(this.close, this.duration);
}
} else if (currentToast === this) {
currentToast = null;
}
Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
},
_renderOpened: function () {
this.classList.add('paper-toast-open');
},
_renderClosed: function () {
this.classList.remove('paper-toast-open');
},
_onFitIntoChanged: function (fitInto) {
this.positionTarget = fitInto;
}
});
}());
Polymer.IronRangeBehavior = {
properties: {
value: {
type: Number,
value: 0,
notify: true,
reflectToAttribute: true
},
min: {
type: Number,
value: 0,
notify: true
},
max: {
type: Number,
value: 100,
notify: true
},
step: {
type: Number,
value: 1,
notify: true
},
ratio: {
type: Number,
value: 0,
readOnly: true,
notify: true
}
},
observers: ['_update(value, min, max, step)'],
_calcRatio: function (value) {
return (this._clampValue(value) - this.min) / (this.max - this.min);
},
_clampValue: function (value) {
return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
},
_calcStep: function (value) {
value = parseFloat(value);
if (!this.step) {
return value;
}
var numSteps = Math.round((value - this.min) / this.step);
if (this.step < 1) {
return numSteps / (1 / this.step) + this.min;
} else {
return numSteps * this.step + this.min;
}
},
_validateValue: function () {
var v = this._clampValue(this.value);
this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
return this.value !== v;
},
_update: function () {
this._validateValue();
this._setRatio(this._calcRatio(this.value) * 100);
}
};
Polymer({
is: 'paper-progress',
behaviors: [Polymer.IronRangeBehavior],
properties: {
secondaryProgress: {
type: Number,
value: 0
},
secondaryRatio: {
type: Number,
value: 0,
readOnly: true
},
indeterminate: {
type: Boolean,
value: false,
observer: '_toggleIndeterminate'
},
disabled: {
type: Boolean,
value: false,
reflectToAttribute: true,
observer: '_disabledChanged'
}
},
observers: ['_progressChanged(secondaryProgress, value, min, max)'],
hostAttributes: { role: 'progressbar' },
_toggleIndeterminate: function (indeterminate) {
this.toggleClass('indeterminate', indeterminate, this.$.primaryProgress);
},
_transformProgress: function (progress, ratio) {
var transform = 'scaleX(' + ratio / 100 + ')';
progress.style.transform = progress.style.webkitTransform = transform;
},
_mainRatioChanged: function (ratio) {
this._transformProgress(this.$.primaryProgress, ratio);
},
_progressChanged: function (secondaryProgress, value, min, max) {
secondaryProgress = this._clampValue(secondaryProgress);
value = this._clampValue(value);
var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
var mainRatio = this._calcRatio(value) * 100;
this._setSecondaryRatio(secondaryRatio);
this._transformProgress(this.$.secondaryProgress, secondaryRatio);
this._transformProgress(this.$.primaryProgress, mainRatio);
this.secondaryProgress = secondaryProgress;
this.setAttribute('aria-valuenow', value);
this.setAttribute('aria-valuemin', min);
this.setAttribute('aria-valuemax', max);
},
_disabledChanged: function (disabled) {
this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
},
_hideSecondaryProgress: function (secondaryRatio) {
return secondaryRatio === 0;
}
});
var clippy = {};
clippy.Agent = function (a, b, c) {
this.path = a, this._queue = new clippy.Queue($.proxy(this._onQueueEmpty, this)), this._el = $('<div class="clippy"></div>').hide(), $(document.body).append(this._el), this._animator = new clippy.Animator(this._el, a, b, c), this._balloon = new clippy.Balloon(this._el), this._setupEvents();
}, clippy.Agent.prototype = {
gestureAt: function (a, b) {
var c = this._getDirection(a, b), d = 'Gesture' + c, e = 'Look' + c, f = this.hasAnimation(d) ? d : e;
return this.play(f);
},
hide: function (a, b) {
this._hidden = !0;
var c = this._el;
this.stop();
if (a) {
this._el.hide(), this.stop(), this.pause(), b && b();
return;
}
return this._playInternal('Hide', function () {
c.hide(), this.pause(), b && b();
});
},
moveTo: function (a, b, c) {
var d = this._getDirection(a, b), e = 'Move' + d;
c === undefined && (c = 1000), this._addToQueue(function (d) {
if (c === 0) {
this._el.css({
top: b,
left: a
}), this.reposition(), d();
return;
}
if (!this.hasAnimation(e)) {
this._el.animate({
top: b,
left: a
}, c, d);
return;
}
var f = $.proxy(function (e, f) {
f === clippy.Animator.States.EXITED && d(), f === clippy.Animator.States.WAITING && this._el.animate({
top: b,
left: a
}, c, $.proxy(function () {
this._animator.exitAnimation();
}, this));
}, this);
this._playInternal(e, f);
}, this);
},
_playInternal: function (a, b) {
this._isIdleAnimation() && this._idleDfd && this._idleDfd.state() === 'pending' && this._idleDfd.done($.proxy(function () {
this._playInternal(a, b);
}, this)), this._animator.showAnimation(a, b);
},
play: function (a, b, c) {
return this.hasAnimation(a) ? (b === undefined && (b = 5000), this._addToQueue(function (d) {
var e = !1, f = function (a, b) {
b === clippy.Animator.States.EXITED && (e = !0, c && c(), d());
};
b && window.setTimeout($.proxy(function () {
if (e)
return;
this._animator.exitAnimation();
}, this), b), this._playInternal(a, f);
}, this), !0) : !1;
},
show: function (a) {
this._hidden = !1;
if (a) {
this._el.show(), this.resume(), this._onQueueEmpty();
return;
}
if (this._el.css('top') === 'auto' || !this._el.css('left') === 'auto') {
var b = $(window).width() * 0.8, c = ($(window).height() + $(document).scrollTop()) * 0.8;
this._el.css({
top: c,
left: b
});
}
return this.resume(), this.play('Show');
},
speak: function (a, b) {
this._addToQueue(function (c) {
this._balloon.speak(c, a, b);
}, this);
},
closeBalloon: function () {
this._balloon.hide();
},
delay: function (a) {
a = a || 250, this._addToQueue(function (b) {
this._onQueueEmpty(), window.setTimeout(b, a);
});
},
stopCurrent: function () {
this._animator.exitAnimation(), this._balloon.close();
},
stop: function () {
this._queue.clear(), this._animator.exitAnimation(), this._balloon.hide();
},
hasAnimation: function (a) {
return this._animator.hasAnimation(a);
},
animations: function () {
return this._animator.animations();
},
animate: function () {
var a = this.animations(), b = a[Math.floor(Math.random() * a.length)];
return b.indexOf('Idle') === 0 ? this.animate() : this.play(b);
},
_getDirection: function (a, b) {
var c = this._el.offset(), d = this._el.height(), e = this._el.width(), f = c.left + e / 2, g = c.top + d / 2, h = g - b, i = f - a, j = Math.round(180 * Math.atan2(h, i) / Math.PI);
return -45 <= j && j < 45 ? 'Right' : 45 <= j && j < 135 ? 'Up' : 135 <= j && j <= 180 || -180 <= j && j < -135 ? 'Left' : -135 <= j && j < -45 ? 'Down' : 'Top';
},
_onQueueEmpty: function () {
if (this._hidden || this._isIdleAnimation())
return;
var a = this._getIdleAnimation();
this._idleDfd = $.Deferred(), this._animator.showAnimation(a, $.proxy(this._onIdleComplete, this));
},
_onIdleComplete: function (a, b) {
b === clippy.Animator.States.EXITED && this._idleDfd.resolve();
},
_isIdleAnimation: function () {
var a = this._animator.currentAnimationName;
return a && a.indexOf('Idle') === 0;
},
_getIdleAnimation: function () {
var a = this.animations(), b = [];
for (var c = 0; c < a.length; c++) {
var d = a[c];
d.indexOf('Idle') === 0 && b.push(d);
}
var e = Math.floor(Math.random() * b.length);
return b[e];
},
_setupEvents: function () {
$(window).on('resize', $.proxy(this.reposition, this)), this._el.on('mousedown', $.proxy(this._onMouseDown, this)), this._el.on('dblclick', $.proxy(this._onDoubleClick, this));
},
_onDoubleClick: function () {
this.play('ClickedOn') || this.animate();
},
reposition: function () {
if (!this._el.is(':visible'))
return;
var a = this._el.offset(), b = this._el.outerHeight(), c = this._el.outerWidth(), d = $(window).width(), e = $(window).height(), f = $(window).scrollTop(), g = $(window).scrollLeft(), h = a.top - f, i = a.left - g, j = 5;
h - j < 0 ? h = j : h + b + j > e && (h = e - b - j), i - j < 0 ? i = j : i + c + j > d && (i = d - c - j), this._el.css({
left: i,
top: h
}), this._balloon.reposition();
},
_onMouseDown: function (a) {
a.preventDefault(), this._startDrag(a);
},
_startDrag: function (a) {
this.pause(), this._balloon.hide(!0), this._offset = this._calculateClickOffset(a), this._moveHandle = $.proxy(this._dragMove, this), this._upHandle = $.proxy(this._finishDrag, this), $(window).on('mousemove', this._moveHandle), $(window).on('mouseup', this._upHandle), this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);
},
_calculateClickOffset: function (a) {
var b = a.pageX, c = a.pageY, d = this._el.offset();
return {
top: c - d.top,
left: b - d.left
};
},
_updateLocation: function () {
this._el.css({
top: this._targetY,
left: this._taregtX
}), this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);
},
_dragMove: function (a) {
a.preventDefault();
var b = a.clientX - this._offset.left, c = a.clientY - this._offset.top;
this._taregtX = b, this._targetY = c;
},
_finishDrag: function () {
window.clearTimeout(this._dragUpdateLoop), $(window).off('mousemove', this._moveHandle), $(window).off('mouseup', this._upHandle), this._balloon.show(), this.reposition(), this.resume();
},
_addToQueue: function (a, b) {
b && (a = $.proxy(a, b)), this._queue.queue(a);
},
pause: function () {
this._animator.pause(), this._balloon.pause();
},
resume: function () {
this._animator.resume(), this._balloon.resume();
}
}, clippy.Animator = function (a, b, c, d) {
this._el = a, this._data = c, this._path = b, this._currentFrameIndex = 0, this._currentFrame = undefined, this._exiting = !1, this._currentAnimation = undefined, this._endCallback = undefined, this._started = !1, this._sounds = {}, this.currentAnimationName = undefined, this.preloadSounds(d), this._overlays = [this._el];
var e = this._el;
this._setupElement(this._el);
for (var f = 1; f < this._data.overlayCount; f++) {
var g = this._setupElement($('<div></div>'));
e.append(g), this._overlays.push(g), e = g;
}
}, clippy.Animator.prototype = {
_setupElement: function (a) {
var b = this._data.framesize;
return a.css('display', 'none'), a.css({
width: b[0],
height: b[1]
}), a.css('background', 'url(\'' + this._path + '/map.png\') no-repeat'), a;
},
animations: function () {
var a = [], b = this._data.animations;
for (var c in b)
a.push(c);
return a;
},
preloadSounds: function (a) {
for (var b = 0; b < this._data.sounds.length; b++) {
var c = this._data.sounds[b], d = a[c];
if (!d)
continue;
this._sounds[c] = new Audio(d);
}
},
hasAnimation: function (a) {
return !!this._data.animations[a];
},
exitAnimation: function () {
this._exiting = !0;
},
showAnimation: function (a, b) {
return this._exiting = !1, this.hasAnimation(a) ? (this._currentAnimation = this._data.animations[a], this.currentAnimationName = a, this._started || (this._step(), this._started = !0), this._currentFrameIndex = 0, this._currentFrame = undefined, this._endCallback = b, !0) : !1;
},
_draw: function () {
var a = [];
this._currentFrame && (a = this._currentFrame.images || []);
for (var b = 0; b < this._overlays.length; b++)
if (b < a.length) {
var c = a[b], d = -c[0] + 'px ' + -c[1] + 'px';
this._overlays[b].css({
'background-position': d,
display: 'block'
});
} else
this._overlays[b].css('display', 'none');
},
_getNextAnimationFrame: function () {
if (!this._currentAnimation)
return undefined;
if (!this._currentFrame)
return 0;
var a = this._currentFrame, b = this._currentFrame.branching;
if (this._exiting && a.exitBranch !== undefined)
return a.exitBranch;
if (b) {
var c = Math.random() * 100;
for (var d = 0; d < b.branches.length; d++) {
var e = b.branches[d];
if (c <= e.weight)
return e.frameIndex;
c -= e.weight;
}
}
return this._currentFrameIndex + 1;
},
_playSound: function () {
var a = this._currentFrame.sound;
if (!a)
return;
var b = this._sounds[a];
b && b.play();
},
_atLastFrame: function () {
return this._currentFrameIndex >= this._currentAnimation.frames.length - 1;
},
_step: function () {
if (!this._currentAnimation)
return;
var a = Math.min(this._getNextAnimationFrame(), this._currentAnimation.frames.length - 1), b = !this._currentFrame || this._currentFrameIndex !== a;
this._currentFrameIndex = a;
if (!this._atLastFrame() || !this._currentAnimation.useExitBranching)
this._currentFrame = this._currentAnimation.frames[this._currentFrameIndex];
this._draw(), this._playSound(), this._loop = window.setTimeout($.proxy(this._step, this), this._currentFrame.duration), this._endCallback && b && this._atLastFrame() && (this._currentAnimation.useExitBranching && !this._exiting ? this._endCallback(this.currentAnimationName, clippy.Animator.States.WAITING) : this._endCallback(this.currentAnimationName, clippy.Animator.States.EXITED));
},
pause: function () {
window.clearTimeout(this._loop);
},
resume: function () {
this._step();
}
}, clippy.Animator.States = {
WAITING: 1,
EXITED: 0
}, clippy.Balloon = function (a) {
this._targetEl = a, this._hidden = !0, this._setup();
}, clippy.Balloon.prototype = {
WORD_SPEAK_TIME: 200,
CLOSE_BALLOON_DELAY: 2000,
_setup: function () {
this._balloon = $('<div class="clippy-balloon"><div class="clippy-tip"></div><div class="clippy-content"></div></div> ').hide(), this._content = this._balloon.find('.clippy-content'), $(document.body).append(this._balloon);
},
reposition: function () {
var a = [
'top-left',
'top-right',
'bottom-left',
'bottom-right'
];
for (var b = 0; b < a.length; b++) {
var c = a[b];
this._position(c);
if (!this._isOut())
break;
}
},
_BALLOON_MARGIN: 15,
_position: function (a) {
var b = this._targetEl.offset(), c = this._targetEl.height(), d = this._targetEl.width(), e = this._balloon.outerHeight(), f = this._balloon.outerWidth();
this._balloon.removeClass('clippy-top-left'), this._balloon.removeClass('clippy-top-right'), this._balloon.removeClass('clippy-bottom-right'), this._balloon.removeClass('clippy-bottom-left');
var g, h;
switch (a) {
case 'top-left':
g = b.left + d - f, h = b.top - e - this._BALLOON_MARGIN;
break;
case 'top-right':
g = b.left, h = b.top - e - this._BALLOON_MARGIN;
break;
case 'bottom-right':
g = b.left, h = b.top + c + this._BALLOON_MARGIN;
break;
case 'bottom-left':
g = b.left + d - f, h = b.top + c + this._BALLOON_MARGIN;
}
this._balloon.css({
top: h,
left: g
}), this._balloon.addClass('clippy-' + a);
},
_isOut: function () {
var a = this._balloon.offset(), b = this._balloon.outerHeight(), c = this._balloon.outerWidth(), d = $(window).width(), e = $(window).height(), f = $(document).scrollTop(), g = $(document).scrollLeft(), h = a.top - f, i = a.left - g, j = 5;
return h - j < 0 || i - j < 0 ? !0 : h + b + j > e || i + c + j > d ? !0 : !1;
},
speak: function (a, b, c) {
this._hidden = !1, this.show();
var d = this._content;
d.height('auto'), d.width('auto'), d.text(b), d.height(d.height()), d.width(d.width()), d.text(''), this.reposition(), this._complete = a, this._sayWords(b, c, a);
},
show: function () {
if (this._hidden)
return;
this._balloon.show();
},
hide: function (a) {
if (a) {
this._balloon.hide();
return;
}
this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);
},
_finishHideBalloon: function () {
if (this._active)
return;
this._balloon.hide(), this._hidden = !0, this._hiding = null;
},
_sayWords: function (a, b, c) {
this._active = !0, this._hold = b;
var d = a.split(/[^\S-]/), e = this.WORD_SPEAK_TIME, f = this._content, g = 1;
this._addWord = $.proxy(function () {
if (!this._active)
return;
g > d.length ? (this._active = !1, this._hold || (c(), this.hide())) : (f.text(d.slice(0, g).join(' ')), g++, this._loop = window.setTimeout($.proxy(this._addWord, this), e));
}, this), this._addWord();
},
close: function () {
this._active ? this._hold = !1 : this._hold && this._complete();
},
pause: function () {
window.clearTimeout(this._loop), this._hiding && (window.clearTimeout(this._hiding), this._hiding = null);
},
resume: function () {
this._addWord && this._addWord(), this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);
}
}, clippy.BASE_PATH = '//s3.amazonaws.com/clippy.js/Agents/', clippy.load = function (a, b, c) {
var d = clippy.BASE_PATH + a, e = clippy.load._loadMap(d), f = clippy.load._loadAgent(a, d), g = clippy.load._loadSounds(a, d), h;
f.done(function (a) {
h = a;
});
var i;
g.done(function (a) {
i = a;
});
var j = function () {
var a = new clippy.Agent(d, h, i);
b(a);
};
$.when(e, f, g).done(j).fail(c);
}, clippy.load._maps = {}, clippy.load._loadMap = function (a) {
var b = clippy.load._maps[a];
if (b)
return b;
b = clippy.load._maps[a] = $.Deferred();
var c = a + '/map.png', d = new Image();
return d.onload = b.resolve, d.onerror = b.reject, d.setAttribute('src', c), b.promise();
}, clippy.load._sounds = {}, clippy.load._loadSounds = function (a, b) {
var c = clippy.load._sounds[a];
if (c)
return c;
c = clippy.load._sounds[a] = $.Deferred();
var d = document.createElement('audio'), e = !!d.canPlayType && '' != d.canPlayType('audio/mpeg'), f = !!d.canPlayType && '' != d.canPlayType('audio/ogg; codecs="vorbis"');
if (!e && !f)
c.resolve({});
else {
var g = b + (e ? '/sounds-mp3.js' : '/sounds-ogg.js');
clippy.load._loadScript(g);
}
return c.promise();
}, clippy.load._data = {}, clippy.load._loadAgent = function (a, b) {
var c = clippy.load._data[a];
if (c)
return c;
c = clippy.load._getAgentDfd(a);
var d = b + '/agent.js';
return clippy.load._loadScript(d), c.promise();
}, clippy.load._loadScript = function (a) {
var b = document.createElement('script');
b.setAttribute('src', a), b.setAttribute('async', 'async'), b.setAttribute('type', 'text/javascript'), document.head.appendChild(b);
}, clippy.load._getAgentDfd = function (a) {
var b = clippy.load._data[a];
return b || (b = clippy.load._data[a] = $.Deferred()), b;
}, clippy.ready = function (a, b) {
var c = clippy.load._getAgentDfd(a);
c.resolve(b);
}, clippy.soundsReady = function (a, b) {
var c = clippy.load._sounds[a];
c || (c = clippy.load._sounds[a] = $.Deferred()), c.resolve(b);
}, clippy.Queue = function (a) {
this._queue = [], this._onEmptyCallback = a;
}, clippy.Queue.prototype = {
queue: function (a) {
this._queue.push(a), this._queue.length === 1 && !this._active && this._progressQueue();
},
_progressQueue: function () {
if (!this._queue.length) {
this._onEmptyCallback();
return;
}
var a = this._queue.shift();
this._active = !0;
var b = $.proxy(this.next, this);
a(b);
},
clear: function () {
this._queue = [];
},
next: function () {
this._active = !1, this._progressQueue();
}
};
!function (exports, global) {
function renderDocument(t, e, n, r) {
return createWindowClone(t, t, n, r, e).then(function (i) {
log('Document cloned');
var o = '[' + html2canvasNodeAttribute + '=\'true\']';
t.querySelector(o).removeAttribute(html2canvasNodeAttribute);
var s = i.contentWindow, a = s.document.querySelector(o), c = 'function' == typeof e.onclone ? Promise.resolve(e.onclone(s.document)) : Promise.resolve(!0);
return c.then(function () {
return renderWindow(a, i, e, n, r);
});
});
}
function renderWindow(t, e, n, r, i) {
var o = e.contentWindow, s = new Support(o.document), a = new ImageLoader(n, s), c = getBounds(t), u = 'view' === n.type ? r : documentWidth(o.document), l = 'view' === n.type ? i : documentHeight(o.document), h = new CanvasRenderer(u, l, a, n, document), d = new NodeParser(t, h, s, a, n);
return d.ready.then(function () {
log('Finished rendering');
var r;
return r = 'view' === n.type ? crop(h.canvas, {
width: h.canvas.width,
height: h.canvas.height,
top: 0,
left: 0,
x: 0,
y: 0
}) : t === o.document.body || t === o.document.documentElement || null != n.canvas ? h.canvas : crop(h.canvas, {
width: null != n.width ? n.width : c.width,
height: null != n.height ? n.height : c.height,
top: c.top,
left: c.left,
x: o.pageXOffset,
y: o.pageYOffset
}), cleanupContainer(e, n), r;
});
}
function cleanupContainer(t, e) {
e.removeContainer && (t.parentNode.removeChild(t), log('Cleaned up container'));
}
function crop(t, e) {
var n = document.createElement('canvas'), r = Math.min(t.width - 1, Math.max(0, e.left)), i = Math.min(t.width, Math.max(1, e.left + e.width)), o = Math.min(t.height - 1, Math.max(0, e.top)), s = Math.min(t.height, Math.max(1, e.top + e.height));
return n.width = e.width, n.height = e.height, log('Cropping canvas at:', 'left:', e.left, 'top:', e.top, 'width:', i - r, 'height:', s - o), log('Resulting crop with width', e.width, 'and height', e.height, ' with x', r, 'and y', o), n.getContext('2d').drawImage(t, r, o, i - r, s - o, e.x, e.y, i - r, s - o), n;
}
function documentWidth(t) {
return Math.max(Math.max(t.body.scrollWidth, t.documentElement.scrollWidth), Math.max(t.body.offsetWidth, t.documentElement.offsetWidth), Math.max(t.body.clientWidth, t.documentElement.clientWidth));
}
function documentHeight(t) {
return Math.max(Math.max(t.body.scrollHeight, t.documentElement.scrollHeight), Math.max(t.body.offsetHeight, t.documentElement.offsetHeight), Math.max(t.body.clientHeight, t.documentElement.clientHeight));
}
function smallImage() {
return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
}
function createWindowClone(t, e, n, r, i) {
labelCanvasElements(t);
var o = t.documentElement.cloneNode(!0), s = e.createElement('iframe');
return s.className = 'html2canvas-container', s.style.visibility = 'hidden', s.style.position = 'fixed', s.style.left = '-10000px', s.style.top = '0px', s.style.border = '0', s.width = n, s.height = r, s.scrolling = 'no', e.body.appendChild(s), new Promise(function (e) {
var n = s.contentWindow.document;
s.contentWindow.onload = s.onload = function () {
var o = setInterval(function () {
n.body.childNodes.length > 0 && (cloneCanvasContents(t, n), clearInterval(o), 'view' === i.type && s.contentWindow.scrollTo(r, a), e(s));
}, 50);
};
var r = t.defaultView.pageXOffset, a = t.defaultView.pageYOffset;
n.open(), n.write('<!DOCTYPE html><html></html>'), restoreOwnerScroll(t, r, a), n.replaceChild(i.javascriptEnabled === !0 ? n.adoptNode(o) : removeScriptNodes(n.adoptNode(o)), n.documentElement), n.close();
});
}
function restoreOwnerScroll(t, e, n) {
e === t.defaultView.pageXOffset && n === t.defaultView.pageYOffset || t.defaultView.scrollTo(e, n);
}
function loadUrlDocument(t, e, n, r, i, o) {
return new Proxy(t, e, window.document).then(documentFromHTML(t)).then(function (t) {
return createWindowClone(t, n, r, i, o);
});
}
function documentFromHTML(t) {
return function (e) {
var n, r = new DOMParser();
try {
n = r.parseFromString(e, 'text/html');
} catch (i) {
log('DOMParser not supported, falling back to createHTMLDocument'), n = document.implementation.createHTMLDocument('');
try {
n.open(), n.write(e), n.close();
} catch (o) {
log('createHTMLDocument write not supported, falling back to document.body.innerHTML'), n.body.innerHTML = e;
}
}
var s = n.querySelector('base');
if (!s || !s.href.host) {
var a = n.createElement('base');
a.href = t, n.head.insertBefore(a, n.head.firstChild);
}
return n;
};
}
function labelCanvasElements(t) {
[].slice.call(t.querySelectorAll('canvas'), 0).forEach(function (t) {
t.setAttribute(html2canvasCanvasCloneAttribute, 'canvas-' + html2canvasCanvasCloneIndex++);
});
}
function cloneCanvasContents(t, e) {
[].slice.call(t.querySelectorAll('[' + html2canvasCanvasCloneAttribute + ']'), 0).forEach(function (t) {
try {
var n = e.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + t.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
n && (n.width = t.width, n.height = t.height, n.getContext('2d').putImageData(t.getContext('2d').getImageData(0, 0, t.width, t.height), 0, 0));
} catch (r) {
log('Unable to copy canvas content from', t, r);
}
t.removeAttribute(html2canvasCanvasCloneAttribute);
});
}
function removeScriptNodes(t) {
return [].slice.call(t.childNodes, 0).filter(isElementNode).forEach(function (e) {
'SCRIPT' === e.tagName ? t.removeChild(e) : removeScriptNodes(e);
}), t;
}
function isElementNode(t) {
return t.nodeType === Node.ELEMENT_NODE;
}
function absoluteUrl(t) {
var e = document.createElement('a');
return e.href = t, e.href = e.href, e;
}
function DummyImageContainer(t) {
if (this.src = t, log('DummyImageContainer for', t), !this.promise || !this.image) {
log('Initiating DummyImageContainer'), DummyImageContainer.prototype.image = new Image();
var e = this.image;
DummyImageContainer.prototype.promise = new Promise(function (t, n) {
e.onload = t, e.onerror = n, e.src = smallImage(), e.complete === !0 && t(e);
});
}
}
function Font(t, e) {
var n, r, i = document.createElement('div'), o = document.createElement('img'), s = document.createElement('span'), a = 'Hidden Text';
i.style.visibility = 'hidden', i.style.fontFamily = t, i.style.fontSize = e, i.style.margin = 0, i.style.padding = 0, document.body.appendChild(i), o.src = smallImage(), o.width = 1, o.height = 1, o.style.margin = 0, o.style.padding = 0, o.style.verticalAlign = 'baseline', s.style.fontFamily = t, s.style.fontSize = e, s.style.margin = 0, s.style.padding = 0, s.appendChild(document.createTextNode(a)), i.appendChild(s), i.appendChild(o), n = o.offsetTop - s.offsetTop + 1, i.removeChild(s), i.appendChild(document.createTextNode(a)), i.style.lineHeight = 'normal', o.style.verticalAlign = 'super', r = o.offsetTop - i.offsetTop + 1, document.body.removeChild(i), this.baseline = n, this.lineWidth = 1, this.middle = r;
}
function FontMetrics() {
this.data = {};
}
function FrameContainer(t, e, n) {
this.image = null, this.src = t;
var r = this, i = getBounds(t);
this.promise = (e ? new Promise(function (e) {
'about:blank' === t.contentWindow.document.URL || null == t.contentWindow.document.documentElement ? t.contentWindow.onload = t.onload = function () {
e(t);
} : e(t);
}) : this.proxyLoad(n.proxy, i, n)).then(function (t) {
return html2canvas(t.contentWindow.document.documentElement, {
type: 'view',
width: t.width,
height: t.height,
proxy: n.proxy,
javascriptEnabled: n.javascriptEnabled,
removeContainer: n.removeContainer,
allowTaint: n.allowTaint,
imageTimeout: n.imageTimeout / 2
});
}).then(function (t) {
return r.image = t;
});
}
function GradientContainer(t) {
this.src = t.value, this.colorStops = [], this.type = null, this.x0 = 0.5, this.y0 = 0.5, this.x1 = 0.5, this.y1 = 0.5, this.promise = Promise.resolve(!0);
}
function ImageContainer(t, e) {
this.src = t, this.image = new Image();
var n = this;
this.tainted = null, this.promise = new Promise(function (r, i) {
n.image.onload = r, n.image.onerror = i, e && (n.image.crossOrigin = 'anonymous'), n.image.src = t, n.image.complete === !0 && r(n.image);
});
}
function ImageLoader(t, e) {
this.link = null, this.options = t, this.support = e, this.origin = this.getOrigin(window.location.href);
}
function LinearGradientContainer(t) {
GradientContainer.apply(this, arguments), this.type = this.TYPES.LINEAR;
var e = null === t.args[0].match(this.stepRegExp);
e ? t.args[0].split(' ').reverse().forEach(function (t) {
switch (t) {
case 'left':
this.x0 = 0, this.x1 = 1;
break;
case 'top':
this.y0 = 0, this.y1 = 1;
break;
case 'right':
this.x0 = 1, this.x1 = 0;
break;
case 'bottom':
this.y0 = 1, this.y1 = 0;
break;
case 'to':
var e = this.y0, n = this.x0;
this.y0 = this.y1, this.x0 = this.x1, this.x1 = n, this.y1 = e;
}
}, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = t.args.slice(e ? 1 : 0).map(function (t) {
var e = t.match(this.stepRegExp);
return {
color: e[1],
stop: '%' === e[3] ? e[2] / 100 : null
};
}, this), null === this.colorStops[0].stop && (this.colorStops[0].stop = 0), null === this.colorStops[this.colorStops.length - 1].stop && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function (t, e) {
null === t.stop && this.colorStops.slice(e).some(function (n, r) {
return null !== n.stop ? (t.stop = (n.stop - this.colorStops[e - 1].stop) / (r + 1) + this.colorStops[e - 1].stop, !0) : !1;
}, this);
}, this);
}
function log() {
window.html2canvas.logging && window.console && window.console.log && Function.prototype.bind.call(window.console.log, window.console).apply(window.console, [
Date.now() - window.html2canvas.start + 'ms',
'html2canvas:'
].concat([].slice.call(arguments, 0)));
}
function NodeContainer(t, e) {
this.node = t, this.parent = e, this.stack = null, this.bounds = null, this.borders = null, this.clip = [], this.backgroundClip = [], this.offsetBounds = null, this.visible = null, this.computedStyles = null, this.styles = {}, this.backgroundImages = null, this.transformData = null, this.transformMatrix = null, this.isPseudoElement = !1, this.opacity = null;
}
function selectionValue(t) {
var e = t.options[t.selectedIndex || 0];
return e ? e.text || '' : '';
}
function parseMatrix(t) {
return t && 'matrix' === t[1] ? t[2].split(',').map(function (t) {
return parseFloat(t.trim());
}) : void 0;
}
function isPercentage(t) {
return -1 !== t.toString().indexOf('%');
}
function parseBackgrounds(t) {
var e, n, r, i, o, s, a, c = ' \r\n\t', u = [], l = 0, h = 0, d = function () {
e && ('"' === n.substr(0, 1) && (n = n.substr(1, n.length - 2)), n && a.push(n), '-' === e.substr(0, 1) && (i = e.indexOf('-', 1) + 1) > 0 && (r = e.substr(0, i), e = e.substr(i)), u.push({
prefix: r,
method: e.toLowerCase(),
value: o,
args: a,
image: null
})), a = [], e = r = n = o = '';
};
return a = [], e = r = n = o = '', t.split('').forEach(function (t) {
if (!(0 === l && c.indexOf(t) > -1)) {
switch (t) {
case '"':
s ? s === t && (s = null) : s = t;
break;
case '(':
if (s)
break;
if (0 === l)
return l = 1, void (o += t);
h++;
break;
case ')':
if (s)
break;
if (1 === l) {
if (0 === h)
return l = 0, o += t, void d();
h--;
}
break;
case ',':
if (s)
break;
if (0 === l)
return void d();
if (1 === l && 0 === h && !e.match(/^url$/i))
return a.push(n), n = '', void (o += t);
}
o += t, 0 === l ? e += t : n += t;
}
}), d(), u;
}
function removePx(t) {
return t.replace('px', '');
}
function asFloat(t) {
return parseFloat(t);
}
function getBounds(t) {
if (t.getBoundingClientRect) {
var e = t.getBoundingClientRect(), n = null == t.offsetWidth ? e.width : t.offsetWidth;
return {
top: e.top,
bottom: e.bottom || e.top + e.height,
right: e.left + n,
left: e.left,
width: n,
height: null == t.offsetHeight ? e.height : t.offsetHeight
};
}
return {};
}
function offsetBounds(t) {
var e = t.offsetParent ? offsetBounds(t.offsetParent) : {
top: 0,
left: 0
};
return {
top: t.offsetTop + e.top,
bottom: t.offsetTop + t.offsetHeight + e.top,
right: t.offsetLeft + e.left + t.offsetWidth,
left: t.offsetLeft + e.left,
width: t.offsetWidth,
height: t.offsetHeight
};
}
function NodeParser(t, e, n, r, i) {
log('Starting NodeParser'), this.renderer = e, this.options = i, this.range = null, this.support = n, this.renderQueue = [], this.stack = new StackingContext(!0, 1, t.ownerDocument, null);
var o = new NodeContainer(t, null);
if (t === t.ownerDocument.documentElement) {
var s = new NodeContainer(this.renderer.isTransparent(o.css('backgroundColor')) ? t.ownerDocument.body : t.ownerDocument.documentElement, null);
e.rectangle(0, 0, e.width, e.height, s.css('backgroundColor'));
}
o.visibile = o.isElementVisible(), this.createPseudoHideStyles(t.ownerDocument), this.disableAnimations(t.ownerDocument), this.nodes = flatten([o].concat(this.getChildren(o)).filter(function (t) {
return t.visible = t.isElementVisible();
}).map(this.getPseudoElements, this)), this.fontMetrics = new FontMetrics(), log('Fetched nodes, total:', this.nodes.length), log('Calculate overflow clips'), this.calculateOverflowClips(), log('Start fetching images'), this.images = r.fetch(this.nodes.filter(isElement)), this.ready = this.images.ready.then(bind(function () {
return log('Images loaded, starting parsing'), log('Creating stacking contexts'), this.createStackingContexts(), log('Sorting stacking contexts'), this.sortStackingContexts(this.stack), this.parse(this.stack), log('Render queue created with ' + this.renderQueue.length + ' items'), new Promise(bind(function (t) {
i.async ? 'function' == typeof i.async ? i.async.call(this, this.renderQueue, t) : this.renderQueue.length > 0 ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, t)) : t() : (this.renderQueue.forEach(this.paint, this), t());
}, this));
}, this));
}
function hasParentClip(t) {
return t.parent && t.parent.clip.length;
}
function toCamelCase(t) {
return t.replace(/(\-[a-z])/g, function (t) {
return t.toUpperCase().replace('-', '');
});
}
function ClearTransform() {
}
function calculateBorders(t, e, n, r) {
return t.map(function (i, o) {
if (i.width > 0) {
var s = e.left, a = e.top, c = e.width, u = e.height - t[2].width;
switch (o) {
case 0:
u = t[0].width, i.args = drawSide({
c1: [
s,
a
],
c2: [
s + c,
a
],
c3: [
s + c - t[1].width,
a + u
],
c4: [
s + t[3].width,
a + u
]
}, r[0], r[1], n.topLeftOuter, n.topLeftInner, n.topRightOuter, n.topRightInner);
break;
case 1:
s = e.left + e.width - t[1].width, c = t[1].width, i.args = drawSide({
c1: [
s + c,
a
],
c2: [
s + c,
a + u + t[2].width
],
c3: [
s,
a + u
],
c4: [
s,
a + t[0].width
]
}, r[1], r[2], n.topRightOuter, n.topRightInner, n.bottomRightOuter, n.bottomRightInner);
break;
case 2:
a = a + e.height - t[2].width, u = t[2].width, i.args = drawSide({
c1: [
s + c,
a + u
],
c2: [
s,
a + u
],
c3: [
s + t[3].width,
a
],
c4: [
s + c - t[3].width,
a
]
}, r[2], r[3], n.bottomRightOuter, n.bottomRightInner, n.bottomLeftOuter, n.bottomLeftInner);
break;
case 3:
c = t[3].width, i.args = drawSide({
c1: [
s,
a + u + t[2].width
],
c2: [
s,
a
],
c3: [
s + c,
a + t[0].width
],
c4: [
s + c,
a + u
]
}, r[3], r[0], n.bottomLeftOuter, n.bottomLeftInner, n.topLeftOuter, n.topLeftInner);
}
}
return i;
});
}
function getCurvePoints(t, e, n, r) {
var i = 4 * ((Math.sqrt(2) - 1) / 3), o = n * i, s = r * i, a = t + n, c = e + r;
return {
topLeft: bezierCurve({
x: t,
y: c
}, {
x: t,
y: c - s
}, {
x: a - o,
y: e
}, {
x: a,
y: e
}),
topRight: bezierCurve({
x: t,
y: e
}, {
x: t + o,
y: e
}, {
x: a,
y: c - s
}, {
x: a,
y: c
}),
bottomRight: bezierCurve({
x: a,
y: e
}, {
x: a,
y: e + s
}, {
x: t + o,
y: c
}, {
x: t,
y: c
}),
bottomLeft: bezierCurve({
x: a,
y: c
}, {
x: a - o,
y: c
}, {
x: t,
y: e + s
}, {
x: t,
y: e
})
};
}
function calculateCurvePoints(t, e, n) {
var r = t.left, i = t.top, o = t.width, s = t.height, a = e[0][0], c = e[0][1], u = e[1][0], l = e[1][1], h = e[2][0], d = e[2][1], f = e[3][0], p = e[3][1], m = o - u, g = s - d, w = o - h, y = s - p;
return {
topLeftOuter: getCurvePoints(r, i, a, c).topLeft.subdivide(0.5),
topLeftInner: getCurvePoints(r + n[3].width, i + n[0].width, Math.max(0, a - n[3].width), Math.max(0, c - n[0].width)).topLeft.subdivide(0.5),
topRightOuter: getCurvePoints(r + m, i, u, l).topRight.subdivide(0.5),
topRightInner: getCurvePoints(r + Math.min(m, o + n[3].width), i + n[0].width, m > o + n[3].width ? 0 : u - n[3].width, l - n[0].width).topRight.subdivide(0.5),
bottomRightOuter: getCurvePoints(r + w, i + g, h, d).bottomRight.subdivide(0.5),
bottomRightInner: getCurvePoints(r + Math.min(w, o - n[3].width), i + Math.min(g, s + n[0].width), Math.max(0, h - n[1].width), d - n[2].width).bottomRight.subdivide(0.5),
bottomLeftOuter: getCurvePoints(r, i + y, f, p).bottomLeft.subdivide(0.5),
bottomLeftInner: getCurvePoints(r + n[3].width, i + y, Math.max(0, f - n[3].width), p - n[2].width).bottomLeft.subdivide(0.5)
};
}
function bezierCurve(t, e, n, r) {
var i = function (t, e, n) {
return {
x: t.x + (e.x - t.x) * n,
y: t.y + (e.y - t.y) * n
};
};
return {
start: t,
startControl: e,
endControl: n,
end: r,
subdivide: function (o) {
var s = i(t, e, o), a = i(e, n, o), c = i(n, r, o), u = i(s, a, o), l = i(a, c, o), h = i(u, l, o);
return [
bezierCurve(t, s, u, h),
bezierCurve(h, l, c, r)
];
},
curveTo: function (t) {
t.push([
'bezierCurve',
e.x,
e.y,
n.x,
n.y,
r.x,
r.y
]);
},
curveToReversed: function (r) {
r.push([
'bezierCurve',
n.x,
n.y,
e.x,
e.y,
t.x,
t.y
]);
}
};
}
function drawSide(t, e, n, r, i, o, s) {
var a = [];
return e[0] > 0 || e[1] > 0 ? (a.push([
'line',
r[1].start.x,
r[1].start.y
]), r[1].curveTo(a)) : a.push([
'line',
t.c1[0],
t.c1[1]
]), n[0] > 0 || n[1] > 0 ? (a.push([
'line',
o[0].start.x,
o[0].start.y
]), o[0].curveTo(a), a.push([
'line',
s[0].end.x,
s[0].end.y
]), s[0].curveToReversed(a)) : (a.push([
'line',
t.c2[0],
t.c2[1]
]), a.push([
'line',
t.c3[0],
t.c3[1]
])), e[0] > 0 || e[1] > 0 ? (a.push([
'line',
i[1].end.x,
i[1].end.y
]), i[1].curveToReversed(a)) : a.push([
'line',
t.c4[0],
t.c4[1]
]), a;
}
function parseCorner(t, e, n, r, i, o, s) {
e[0] > 0 || e[1] > 0 ? (t.push([
'line',
r[0].start.x,
r[0].start.y
]), r[0].curveTo(t), r[1].curveTo(t)) : t.push([
'line',
o,
s
]), (n[0] > 0 || n[1] > 0) && t.push([
'line',
i[0].start.x,
i[0].start.y
]);
}
function negativeZIndex(t) {
return t.cssInt('zIndex') < 0;
}
function positiveZIndex(t) {
return t.cssInt('zIndex') > 0;
}
function zIndex0(t) {
return 0 === t.cssInt('zIndex');
}
function inlineLevel(t) {
return -1 !== [
'inline',
'inline-block',
'inline-table'
].indexOf(t.css('display'));
}
function isStackingContext(t) {
return t instanceof StackingContext;
}
function hasText(t) {
return t.node.data.trim().length > 0;
}
function noLetterSpacing(t) {
return /^(normal|none|0px)$/.test(t.parent.css('letterSpacing'));
}
function getBorderRadiusData(t) {
return [
'TopLeft',
'TopRight',
'BottomRight',
'BottomLeft'
].map(function (e) {
var n = t.css('border' + e + 'Radius'), r = n.split(' ');
return r.length <= 1 && (r[1] = r[0]), r.map(asInt);
});
}
function renderableNode(t) {
return t.nodeType === Node.TEXT_NODE || t.nodeType === Node.ELEMENT_NODE;
}
function isPositionedForStacking(t) {
var e = t.css('position'), n = -1 !== [
'absolute',
'relative',
'fixed'
].indexOf(e) ? t.css('zIndex') : 'auto';
return 'auto' !== n;
}
function isPositioned(t) {
return 'static' !== t.css('position');
}
function isFloating(t) {
return 'none' !== t.css('float');
}
function isInlineBlock(t) {
return -1 !== [
'inline-block',
'inline-table'
].indexOf(t.css('display'));
}
function not(t) {
var e = this;
return function () {
return !t.apply(e, arguments);
};
}
function isElement(t) {
return t.node.nodeType === Node.ELEMENT_NODE;
}
function isPseudoElement(t) {
return t.isPseudoElement === !0;
}
function isTextNode(t) {
return t.node.nodeType === Node.TEXT_NODE;
}
function zIndexSort(t) {
return function (e, n) {
return e.cssInt('zIndex') + t.indexOf(e) / t.length - (n.cssInt('zIndex') + t.indexOf(n) / t.length);
};
}
function hasOpacity(t) {
return t.getOpacity() < 1;
}
function bind(t, e) {
return function () {
return t.apply(e, arguments);
};
}
function asInt(t) {
return parseInt(t, 10);
}
function getWidth(t) {
return t.width;
}
function nonIgnoredElement(t) {
return t.node.nodeType !== Node.ELEMENT_NODE || -1 === [
'SCRIPT',
'HEAD',
'TITLE',
'OBJECT',
'BR',
'OPTION'
].indexOf(t.node.nodeName);
}
function flatten(t) {
return [].concat.apply([], t);
}
function stripQuotes(t) {
var e = t.substr(0, 1);
return e === t.substr(t.length - 1) && e.match(/'|"/) ? t.substr(1, t.length - 2) : t;
}
function getWords(t) {
for (var e, n = [], r = 0, i = !1; t.length;)
isWordBoundary(t[r]) === i ? (e = t.splice(0, r), e.length && n.push(window.html2canvas.punycode.ucs2.encode(e)), i = !i, r = 0) : r++, r >= t.length && (e = t.splice(0, r), e.length && n.push(window.html2canvas.punycode.ucs2.encode(e)));
return n;
}
function isWordBoundary(t) {
return -1 !== [
32,
13,
10,
9,
45
].indexOf(t);
}
function hasUnicode(t) {
return /[^\u0000-\u00ff]/.test(t);
}
function Proxy(t, e, n) {
var r = createCallback(supportsCORS), i = createProxyUrl(e, t, r);
return supportsCORS ? XHR(i) : jsonp(n, i, r).then(function (t) {
return decode64(t.content);
});
}
function ProxyURL(t, e, n) {
var r = createCallback(supportsCORSImage), i = createProxyUrl(e, t, r);
return supportsCORSImage ? Promise.resolve(i) : jsonp(n, i, r).then(function (t) {
return 'data:' + t.type + ';base64,' + t.content;
});
}
function jsonp(t, e, n) {
return new Promise(function (r, i) {
var o = t.createElement('script'), s = function () {
delete window.html2canvas.proxy[n], t.body.removeChild(o);
};
window.html2canvas.proxy[n] = function (t) {
s(), r(t);
}, o.src = e, o.onerror = function (t) {
s(), i(t);
}, t.body.appendChild(o);
});
}
function createCallback(t) {
return t ? '' : 'html2canvas_' + Date.now() + '_' + ++proxyCount + '_' + Math.round(100000 * Math.random());
}
function createProxyUrl(t, e, n) {
return t + '?url=' + encodeURIComponent(e) + (n.length ? '&callback=html2canvas.proxy.' + n : '');
}
function ProxyImageContainer(t, e) {
var n = (document.createElement('script'), document.createElement('a'));
n.href = t, t = n.href, this.src = t, this.image = new Image();
var r = this;
this.promise = new Promise(function (n, i) {
r.image.crossOrigin = 'Anonymous', r.image.onload = n, r.image.onerror = i, new ProxyURL(t, e, document).then(function (t) {
r.image.src = t;
})['catch'](i);
});
}
function PseudoElementContainer(t, e, n) {
NodeContainer.call(this, t, e), this.isPseudoElement = !0, this.before = ':before' === n;
}
function Renderer(t, e, n, r, i) {
this.width = t, this.height = e, this.images = n, this.options = r, this.document = i;
}
function StackingContext(t, e, n, r) {
NodeContainer.call(this, n, r), this.ownStacking = t, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * e;
}
function Support(t) {
this.rangeBounds = this.testRangeBounds(t), this.cors = this.testCORS(), this.svg = this.testSVG();
}
function SVGContainer(t) {
this.src = t, this.image = null;
var e = this;
this.promise = this.hasFabric().then(function () {
return e.isInline(t) ? Promise.resolve(e.inlineFormatting(t)) : XHR(t);
}).then(function (t) {
return new Promise(function (n) {
html2canvas.fabric.loadSVGFromString(t, e.createCanvas.call(e, n));
});
});
}
function decode64(t) {
var e, n, r, i, o, s, a, c, u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', l = t.length, h = '';
for (e = 0; l > e; e += 4)
n = u.indexOf(t[e]), r = u.indexOf(t[e + 1]), i = u.indexOf(t[e + 2]), o = u.indexOf(t[e + 3]), s = n << 2 | r >> 4, a = (15 & r) << 4 | i >> 2, c = (3 & i) << 6 | o, h += 64 === i ? String.fromCharCode(s) : 64 === o || -1 === o ? String.fromCharCode(s, a) : String.fromCharCode(s, a, c);
return h;
}
function SVGNodeContainer(t, e) {
this.src = t, this.image = null;
var n = this;
this.promise = e ? new Promise(function (e, r) {
n.image = new Image(), n.image.onload = e, n.image.onerror = r, n.image.src = 'data:image/svg+xml,' + new XMLSerializer().serializeToString(t), n.image.complete === !0 && e(n.image);
}) : this.hasFabric().then(function () {
return new Promise(function (e) {
html2canvas.fabric.parseSVGDocument(t, n.createCanvas.call(n, e));
});
});
}
function TextContainer(t, e) {
NodeContainer.call(this, t, e);
}
function capitalize(t, e, n) {
return t.length > 0 ? e + n.toUpperCase() : void 0;
}
function WebkitGradientContainer(t) {
GradientContainer.apply(this, arguments), this.type = 'linear' === t.args[0] ? this.TYPES.LINEAR : this.TYPES.RADIAL;
}
function XHR(t) {
return new Promise(function (e, n) {
var r = new XMLHttpRequest();
r.open('GET', t), r.onload = function () {
200 === r.status ? e(r.responseText) : n(new Error(r.statusText));
}, r.onerror = function () {
n(new Error('Network Error'));
}, r.send();
});
}
function html2pdf(t, e, n) {
var r = e.canvas;
if (!r)
return void alert('jsPDF canvas plugin not installed');
if (r.pdf = e, e.annotations = {
_nameMap: [],
createAnnotation: function (t, n) {
var r, i = e.context2d._wrapX(n.left), o = e.context2d._wrapY(n.top), s = (e.context2d._page(n.top), t.indexOf('#'));
r = s >= 0 ? { name: t.substring(s + 1) } : { url: t }, e.link(i, o, n.right - n.left, n.bottom - n.top, r);
},
setName: function (t, n) {
var r = e.context2d._wrapX(n.left), i = e.context2d._wrapY(n.top), o = e.context2d._page(n.top);
this._nameMap[t] = {
page: o,
x: r,
y: i
};
}
}, r.annotations = e.annotations, e.context2d._pageBreakAt = function (t) {
this.pageBreaks.push(t);
}, e.context2d._gotoPage = function (t) {
for (; e.internal.getNumberOfPages() < t;)
e.addPage();
e.setPage(t);
}, 'string' == typeof t) {
t = t.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
var i = document.createElement('iframe');
document.body.appendChild(i);
var o;
o = i.contentDocument, void 0 != o && null != o || (o = i.contentWindow.document), o.open(), o.write(t), o.close();
html2canvas(o.body, {
canvas: r,
onrendered: function (t) {
n && (i && i.parentElement.removeChild(i), n(e));
}
});
} else {
var s = t;
html2canvas(s, {
canvas: r,
onrendered: function (t) {
n && (i && i.parentElement.removeChild(i), n(e));
}
});
}
}
var jsPDF = function (t) {
'use strict';
function e(e) {
var n = {};
this.subscribe = function (t, e, r) {
if ('function' != typeof e)
return !1;
n.hasOwnProperty(t) || (n[t] = {});
var i = Math.random().toString(35);
return n[t][i] = [
e,
!!r
], i;
}, this.unsubscribe = function (t) {
for (var e in n)
if (n[e][t])
return delete n[e][t], !0;
return !1;
}, this.publish = function (r) {
if (n.hasOwnProperty(r)) {
var i = Array.prototype.slice.call(arguments, 1), o = [];
for (var s in n[r]) {
var a = n[r][s];
try {
a[0].apply(e, i);
} catch (c) {
t.console && console.error('jsPDF PubSub Error', c.message, c);
}
a[1] && o.push(s);
}
o.length && o.forEach(this.unsubscribe);
}
};
}
function n(s, a, c, u) {
var l = {};
'object' == typeof s && (l = s, s = l.orientation, a = l.unit || a, c = l.format || c, u = l.compress || l.compressPdf || u), a = a || 'mm', c = c || 'a4', s = ('' + (s || 'P')).toLowerCase();
var h, d, f, p, m, g, w, y, v, b = (('' + c).toLowerCase(), !!u && 'function' == typeof Uint8Array), x = l.textColor || '0 g', k = l.drawColor || '0 G', A = l.fontSize || 16, C = l.lineHeight || 1.15, E = l.lineWidth || 0.200025, S = 2, F = !1, T = [], P = {}, _ = {}, I = 0, q = [], O = [], R = [], B = [], D = [], N = 0, j = 0, L = 0, M = {
title: '',
subject: '',
author: '',
keywords: '',
creator: ''
}, z = {}, U = new e(z), H = function (t) {
return t.toFixed(2);
}, W = function (t) {
return t.toFixed(3);
}, V = function (t) {
return ('0' + parseInt(t)).slice(-2);
}, X = function (t) {
F ? q[p].push(t) : (L += t.length + 1, B.push(t));
}, Y = function () {
return S++, T[S] = L, X(S + ' 0 obj'), S;
}, G = function () {
var t = 2 * q.length + 1;
t += D.length;
var e = {
objId: t,
content: ''
};
return D.push(e), e;
}, Q = function () {
return S++, T[S] = function () {
return L;
}, S;
}, J = function (t) {
T[t] = L;
}, K = function (t) {
X('stream'), X(t), X('endstream');
}, $ = function () {
var e, r, i, o, s, a, c, u, l;
for (c = t.adler32cs || n.adler32cs, b && 'undefined' == typeof c && (b = !1), e = 1; I >= e; e++) {
if (Y(), u = (m = R[e].width) * d, l = (g = R[e].height) * d, X('<</Type /Page'), X('/Parent 1 0 R'), X('/Resources 2 0 R'), X('/MediaBox [0 0 ' + H(u) + ' ' + H(l) + ']'), U.publish('putPage', {
pageNumber: e,
page: q[e]
}), X('/Contents ' + (S + 1) + ' 0 R'), X('>>'), X('endobj'), r = q[e].join('\n'), Y(), b) {
for (i = [], o = r.length; o--;)
i[o] = r.charCodeAt(o);
a = c.from(r), s = new Deflater(6), s.append(new Uint8Array(i)), r = s.flush(), i = new Uint8Array(r.length + 6), i.set(new Uint8Array([
120,
156
])), i.set(r, 2), i.set(new Uint8Array([
255 & a,
a >> 8 & 255,
a >> 16 & 255,
a >> 24 & 255
]), r.length + 2), r = String.fromCharCode.apply(null, i), X('<</Length ' + r.length + ' /Filter [/FlateDecode]>>');
} else
X('<</Length ' + r.length + '>>');
K(r), X('endobj');
}
T[1] = L, X('1 0 obj'), X('<</Type /Pages');
var h = '/Kids [';
for (o = 0; I > o; o++)
h += 3 + 2 * o + ' 0 R ';
X(h + ']'), X('/Count ' + I), X('>>'), X('endobj'), U.publish('postPutPages');
}, Z = function (t) {
t.objectNumber = Y(), X('<</BaseFont/' + t.PostScriptName + '/Type/Font'), 'string' == typeof t.encoding && X('/Encoding/' + t.encoding), X('/Subtype/Type1>>'), X('endobj');
}, tt = function () {
for (var t in P)
P.hasOwnProperty(t) && Z(P[t]);
}, et = function () {
U.publish('putXobjectDict');
}, nt = function () {
X('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]'), X('/Font <<');
for (var t in P)
P.hasOwnProperty(t) && X('/' + t + ' ' + P[t].objectNumber + ' 0 R');
X('>>'), X('/XObject <<'), et(), X('>>');
}, rt = function () {
tt(), U.publish('putResources'), T[2] = L, X('2 0 obj'), X('<<'), nt(), X('>>'), X('endobj'), U.publish('postPutResources');
}, it = function () {
U.publish('putAdditionalObjects');
for (var t = 0; t < D.length; t++) {
var e = D[t];
T[e.objId] = L, X(e.objId + ' 0 obj'), X(e.content), X('endobj');
}
S += D.length, U.publish('postPutAdditionalObjects');
}, ot = function (t, e, n) {
_.hasOwnProperty(e) || (_[e] = {}), _[e][n] = t;
}, st = function (t, e, n, r) {
var i = 'F' + (Object.keys(P).length + 1).toString(10), o = P[i] = {
id: i,
PostScriptName: t,
fontName: e,
fontStyle: n,
encoding: r,
metadata: {}
};
return ot(i, e, n), U.publish('addFont', o), i;
}, at = function () {
for (var t = 'helvetica', e = 'times', n = 'courier', r = 'normal', i = 'bold', o = 'italic', s = 'bolditalic', a = 'StandardEncoding', c = 'zapfdingbats', u = [
[
'Helvetica',
t,
r
],
[
'Helvetica-Bold',
t,
i
],
[
'Helvetica-Oblique',
t,
o
],
[
'Helvetica-BoldOblique',
t,
s
],
[
'Courier',
n,
r
],
[
'Courier-Bold',
n,
i
],
[
'Courier-Oblique',
n,
o
],
[
'Courier-BoldOblique',
n,
s
],
[
'Times-Roman',
e,
r
],
[
'Times-Bold',
e,
i
],
[
'Times-Italic',
e,
o
],
[
'Times-BoldItalic',
e,
s
],
[
'ZapfDingbats',
c
]
], l = 0, h = u.length; h > l; l++) {
var d = st(u[l][0], u[l][1], u[l][2], a), f = u[l][0].split('-');
ot(d, f[0], f[1] || '');
}
U.publish('addFonts', {
fonts: P,
dictionary: _
});
}, ct = function (e) {
return e.foo = function () {
try {
return e.apply(this, arguments);
} catch (n) {
var r = n.stack || '';
~r.indexOf(' at ') && (r = r.split(' at ')[1]);
var i = 'Error in function ' + r.split('\n')[0].split('<')[0] + ': ' + n.message;
if (!t.console)
throw new Error(i);
t.console.error(i, n), t.alert && alert(i);
}
}, e.foo.bar = e, e.foo;
}, ut = function (t, e) {
var n, r, i, o, s, a, c, u, l;
if (e = e || {}, i = e.sourceEncoding || 'Unicode', s = e.outputEncoding, (e.autoencode || s) && P[h].metadata && P[h].metadata[i] && P[h].metadata[i].encoding && (o = P[h].metadata[i].encoding, !s && P[h].encoding && (s = P[h].encoding), !s && o.codePages && (s = o.codePages[0]), 'string' == typeof s && (s = o[s]), s)) {
for (c = !1, a = [], n = 0, r = t.length; r > n; n++)
u = s[t.charCodeAt(n)], u ? a.push(String.fromCharCode(u)) : a.push(t[n]), a[n].charCodeAt(0) >> 8 && (c = !0);
t = a.join('');
}
for (n = t.length; void 0 === c && 0 !== n;)
t.charCodeAt(n - 1) >> 8 && (c = !0), n--;
if (!c)
return t;
for (a = e.noBOM ? [] : [
254,
255
], n = 0, r = t.length; r > n; n++) {
if (u = t.charCodeAt(n), l = u >> 8, l >> 8)
throw new Error('Character at position ' + n + ' of string \'' + t + '\' exceeds 16bits. Cannot be encoded into UCS-2 BE');
a.push(l), a.push(u - (l << 8));
}
return String.fromCharCode.apply(void 0, a);
}, lt = function (t, e) {
return ut(t, e).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
}, ht = function () {
X('/Producer (jsPDF ' + n.version + ')');
for (var t in M)
M.hasOwnProperty(t) && M[t] && X('/' + t.substr(0, 1).toUpperCase() + t.substr(1) + ' (' + lt(M[t]) + ')');
var e = new Date(), r = e.getTimezoneOffset(), i = 0 > r ? '+' : '-', o = Math.floor(Math.abs(r / 60)), s = Math.abs(r % 60), a = [
i,
V(o),
'\'',
V(s),
'\''
].join('');
X([
'/CreationDate (D:',
e.getFullYear(),
V(e.getMonth() + 1),
V(e.getDate()),
V(e.getHours()),
V(e.getMinutes()),
V(e.getSeconds()),
a,
')'
].join(''));
}, dt = function () {
switch (X('/Type /Catalog'), X('/Pages 1 0 R'), y || (y = 'fullwidth'), y) {
case 'fullwidth':
X('/OpenAction [3 0 R /FitH null]');
break;
case 'fullheight':
X('/OpenAction [3 0 R /FitV null]');
break;
case 'fullpage':
X('/OpenAction [3 0 R /Fit]');
break;
case 'original':
X('/OpenAction [3 0 R /XYZ null null 1]');
break;
default:
var t = '' + y;
'%' === t.substr(t.length - 1) && (y = parseInt(y) / 100), 'number' == typeof y && X('/OpenAction [3 0 R /XYZ null null ' + H(y) + ']');
}
switch (v || (v = 'continuous'), v) {
case 'continuous':
X('/PageLayout /OneColumn');
break;
case 'single':
X('/PageLayout /SinglePage');
break;
case 'two':
case 'twoleft':
X('/PageLayout /TwoColumnLeft');
break;
case 'tworight':
X('/PageLayout /TwoColumnRight');
}
w && X('/PageMode /' + w), U.publish('putCatalog');
}, ft = function () {
X('/Size ' + (S + 1)), X('/Root ' + S + ' 0 R'), X('/Info ' + (S - 1) + ' 0 R');
}, pt = function (t, e) {
var n = 'string' == typeof e && e.toLowerCase();
if ('string' == typeof t) {
var r = t.toLowerCase();
o.hasOwnProperty(r) && (t = o[r][0] / d, e = o[r][1] / d);
}
if (Array.isArray(t) && (e = t[1], t = t[0]), n) {
switch (n.substr(0, 1)) {
case 'l':
e > t && (n = 's');
break;
case 'p':
t > e && (n = 's');
}
's' === n && (f = t, t = e, e = f);
}
F = !0, q[++I] = [], R[I] = {
width: Number(t) || m,
height: Number(e) || g
}, O[I] = {}, wt(I);
}, mt = function () {
pt.apply(this, arguments), X(H(E * d) + ' w'), X(k), 0 !== N && X(N + ' J'), 0 !== j && X(j + ' j'), U.publish('addPage', { pageNumber: I });
}, gt = function (t) {
t > 0 && I >= t && (q.splice(t, 1), R.splice(t, 1), I--, p > I && (p = I), this.setPage(p));
}, wt = function (t) {
t > 0 && I >= t && (p = t, m = R[t].width, g = R[t].height);
}, yt = function (t, e) {
var n;
switch (t = void 0 !== t ? t : P[h].fontName, e = void 0 !== e ? e : P[h].fontStyle, void 0 !== t && (t = t.toLowerCase()), t) {
case 'sans-serif':
case 'verdana':
case 'arial':
case 'helvetica':
t = 'helvetica';
break;
case 'fixed':
case 'monospace':
case 'terminal':
case 'courier':
t = 'courier';
break;
case 'serif':
case 'cursive':
case 'fantasy':
default:
t = 'times';
}
try {
n = _[t][e];
} catch (r) {
}
return n || (n = _.times[e], null == n && (n = _.times.normal)), n;
}, vt = function () {
F = !1, S = 2, B = [], T = [], D = [], U.publish('buildDocument'), X('%PDF-' + r), $(), it(), rt(), Y(), X('<<'), ht(), X('>>'), X('endobj'), Y(), X('<<'), dt(), X('>>'), X('endobj');
var t, e = L, n = '0000000000';
for (X('xref'), X('0 ' + (S + 1)), X(n + ' 65535 f '), t = 1; S >= t; t++) {
var i = T[t];
X('function' == typeof i ? (n + T[t]()).slice(-10) + ' 00000 n ' : (n + T[t]).slice(-10) + ' 00000 n ');
}
return X('trailer'), X('<<'), ft(), X('>>'), X('startxref'), X(e), X('%%EOF'), F = !0, B.join('\n');
}, bt = function (t) {
var e = 'S';
return 'F' === t ? e = 'f' : 'FD' === t || 'DF' === t ? e = 'B' : 'f' !== t && 'f*' !== t && 'B' !== t && 'B*' !== t || (e = t), e;
}, xt = function () {
for (var t = vt(), e = t.length, n = new ArrayBuffer(e), r = new Uint8Array(n); e--;)
r[e] = t.charCodeAt(e);
return n;
}, kt = function () {
return new Blob([xt()], { type: 'application/pdf' });
}, At = ct(function (e, n) {
var r = 'dataur' === ('' + e).substr(0, 6) ? 'data:application/pdf;base64,' + btoa(vt()) : 0;
switch (e) {
case void 0:
return vt();
case 'save':
if (navigator.getUserMedia && (void 0 === t.URL || void 0 === t.URL.createObjectURL))
return z.output('dataurlnewwindow');
saveAs(kt(), n), 'function' == typeof saveAs.unload && t.setTimeout && setTimeout(saveAs.unload, 911);
break;
case 'arraybuffer':
return xt();
case 'blob':
return kt();
case 'bloburi':
case 'bloburl':
return t.URL && t.URL.createObjectURL(kt()) || void 0;
case 'datauristring':
case 'dataurlstring':
return r;
case 'dataurlnewwindow':
var i = t.open(r);
if (i || 'undefined' == typeof safari)
return i;
case 'datauri':
case 'dataurl':
return t.document.location.href = r;
default:
throw new Error('Output type "' + e + '" is not supported.');
}
});
switch (a) {
case 'pt':
d = 1;
break;
case 'mm':
d = 72 / 25.4000508;
break;
case 'cm':
d = 72 / 2.54000508;
break;
case 'in':
d = 72;
break;
case 'px':
d = 96 / 72;
break;
case 'pc':
d = 12;
break;
case 'em':
d = 12;
break;
case 'ex':
d = 6;
break;
default:
throw 'Invalid unit: ' + a;
}
z.internal = {
pdfEscape: lt,
getStyle: bt,
getFont: function () {
return P[yt.apply(z, arguments)];
},
getFontSize: function () {
return A;
},
getLineHeight: function () {
return A * C;
},
write: function (t) {
X(1 === arguments.length ? t : Array.prototype.join.call(arguments, ' '));
},
getCoordinateString: function (t) {
return H(t * d);
},
getVerticalCoordinateString: function (t) {
return H((g - t) * d);
},
collections: {},
newObject: Y,
newAdditionalObject: G,
newObjectDeferred: Q,
newObjectDeferredBegin: J,
putStream: K,
events: U,
scaleFactor: d,
pageSize: {
get width() {
return m;
},
get height() {
return g;
}
},
output: function (t, e) {
return At(t, e);
},
getNumberOfPages: function () {
return q.length - 1;
},
pages: q,
out: X,
f2: H,
getPageInfo: function (t) {
var e = 2 * (t - 1) + 3;
return {
objId: e,
pageNumber: t,
pageContext: O[t]
};
},
getCurrentPageInfo: function () {
var t = 2 * (p - 1) + 3;
return {
objId: t,
pageNumber: p,
pageContext: O[p]
};
},
getPDFVersion: function () {
return r;
}
}, z.addPage = function () {
return mt.apply(this, arguments), this;
}, z.setPage = function () {
return wt.apply(this, arguments), this;
}, z.insertPage = function (t) {
return this.addPage(), this.movePage(p, t), this;
}, z.movePage = function (t, e) {
if (t > e) {
for (var n = q[t], r = R[t], i = O[t], o = t; o > e; o--)
q[o] = q[o - 1], R[o] = R[o - 1], O[o] = O[o - 1];
q[e] = n, R[e] = r, O[e] = i, this.setPage(e);
} else if (e > t) {
for (var n = q[t], r = R[t], i = O[t], o = t; e > o; o++)
q[o] = q[o + 1], R[o] = R[o + 1], O[o] = O[o + 1];
q[e] = n, R[e] = r, O[e] = i, this.setPage(e);
}
return this;
}, z.deletePage = function () {
return gt.apply(this, arguments), this;
}, z.setDisplayMode = function (t, e, n) {
return y = t, v = e, w = n, this;
}, z.text = function (t, e, n, r, o, s) {
function a(t) {
return t = t.split('\t').join(Array(l.TabLen || 9).join(' ')), lt(t, r);
}
'number' == typeof t && (f = n, n = e, e = t, t = f), 'string' == typeof t && (t = t.match(/[\n\r]/) ? t.split(/\r\n|\r|\n/g) : [t]), 'string' == typeof o && (s = o, o = null), 'string' == typeof r && (s = r, r = null), 'number' == typeof r && (o = r, r = null);
var c, u = '', p = 'Td';
if (o) {
o *= Math.PI / 180;
var m = Math.cos(o), w = Math.sin(o);
u = [
H(m),
H(w),
H(-1 * w),
H(m),
''
].join(' '), p = 'Tm';
}
r = r || {}, 'noBOM' in r || (r.noBOM = !0), 'autoencode' in r || (r.autoencode = !0);
var y = '', v = this.internal.getCurrentPageInfo().pageContext;
if (!0 === r.stroke ? v.lastTextWasStroke !== !0 && (y = '1 Tr\n', v.lastTextWasStroke = !0) : (v.lastTextWasStroke && (y = '0 Tr\n'), v.lastTextWasStroke = !1), 'undefined' == typeof this._runningPageHeight && (this._runningPageHeight = 0), 'string' == typeof t)
t = a(t);
else {
if ('[object Array]' !== Object.prototype.toString.call(t))
throw new Error('Type of text must be string or Array. "' + t + '" is not recognized.');
for (var b = t.concat(), k = [], E = b.length; E--;)
k.push(a(b.shift()));
var S = Math.ceil((g - n - this._runningPageHeight) * d / (A * C));
if (S >= 0 && S < k.length + 1, s) {
var F, T, P, _ = A * C, I = t.map(function (t) {
return this.getStringUnitWidth(t) * A / d;
}, this);
if (P = Math.max.apply(Math, I), 'center' === s)
F = e - P / 2, e -= I[0] / 2;
else {
if ('right' !== s)
throw new Error('Unrecognized alignment option, use "center" or "right".');
F = e - P, e -= I[0];
}
for (T = e, t = k[0] + ') Tj\n', i = 1, E = k.length; i < E; i++) {
var q = P - I[i];
'center' === s && (q /= 2), t += F - T + q + ' -' + _ + ' Td (' + k[i], T = F + q, i < E - 1 && (t += ') Tj\n');
}
} else
t = k.join(') Tj\nT* (');
}
var O;
return c || (O = H((g - n) * d)), X('BT\n/' + h + ' ' + A + ' Tf\n' + A * C + ' TL\n' + y + x + '\n' + u + H(e * d) + ' ' + O + ' ' + p + '\n(' + t + ') Tj\nET'), c && this.text(c, e, n), this;
}, z.lstext = function (t, e, n, r) {
for (var i = 0, o = t.length; o > i; i++, e += r)
this.text(t[i], e, n);
}, z.line = function (t, e, n, r) {
return this.lines([[
n - t,
r - e
]], t, e);
}, z.clip = function () {
X('W'), X('S');
}, z.lines = function (t, e, n, r, i, o) {
var s, a, c, u, l, h, p, m, w, y, v;
for ('number' == typeof t && (f = n, n = e, e = t, t = f), r = r || [
1,
1
], X(W(e * d) + ' ' + W((g - n) * d) + ' m '), s = r[0], a = r[1], u = t.length, y = e, v = n, c = 0; u > c; c++)
l = t[c], 2 === l.length ? (y = l[0] * s + y, v = l[1] * a + v, X(W(y * d) + ' ' + W((g - v) * d) + ' l')) : (h = l[0] * s + y, p = l[1] * a + v, m = l[2] * s + y, w = l[3] * a + v, y = l[4] * s + y, v = l[5] * a + v, X(W(h * d) + ' ' + W((g - p) * d) + ' ' + W(m * d) + ' ' + W((g - w) * d) + ' ' + W(y * d) + ' ' + W((g - v) * d) + ' c'));
return o && X(' h'), null !== i && X(bt(i)), this;
}, z.rect = function (t, e, n, r, i) {
bt(i);
return X([
H(t * d),
H((g - e) * d),
H(n * d),
H(-r * d),
're'
].join(' ')), null !== i && X(bt(i)), this;
}, z.triangle = function (t, e, n, r, i, o, s) {
return this.lines([
[
n - t,
r - e
],
[
i - n,
o - r
],
[
t - i,
e - o
]
], t, e, [
1,
1
], s, !0), this;
}, z.roundedRect = function (t, e, n, r, i, o, s) {
var a = 4 / 3 * (Math.SQRT2 - 1);
return this.lines([
[
n - 2 * i,
0
],
[
i * a,
0,
i,
o - o * a,
i,
o
],
[
0,
r - 2 * o
],
[
0,
o * a,
-(i * a),
o,
-i,
o
],
[
-n + 2 * i,
0
],
[
-(i * a),
0,
-i,
-(o * a),
-i,
-o
],
[
0,
-r + 2 * o
],
[
0,
-(o * a),
i * a,
-o,
i,
-o
]
], t + i, e, [
1,
1
], s), this;
}, z.ellipse = function (t, e, n, r, i) {
var o = 4 / 3 * (Math.SQRT2 - 1) * n, s = 4 / 3 * (Math.SQRT2 - 1) * r;
return X([
H((t + n) * d),
H((g - e) * d),
'm',
H((t + n) * d),
H((g - (e - s)) * d),
H((t + o) * d),
H((g - (e - r)) * d),
H(t * d),
H((g - (e - r)) * d),
'c'
].join(' ')), X([
H((t - o) * d),
H((g - (e - r)) * d),
H((t - n) * d),
H((g - (e - s)) * d),
H((t - n) * d),
H((g - e) * d),
'c'
].join(' ')), X([
H((t - n) * d),
H((g - (e + s)) * d),
H((t - o) * d),
H((g - (e + r)) * d),
H(t * d),
H((g - (e + r)) * d),
'c'
].join(' ')), X([
H((t + o) * d),
H((g - (e + r)) * d),
H((t + n) * d),
H((g - (e + s)) * d),
H((t + n) * d),
H((g - e) * d),
'c'
].join(' ')), null !== i && X(bt(i)), this;
}, z.circle = function (t, e, n, r) {
return this.ellipse(t, e, n, n, r);
}, z.setProperties = function (t) {
for (var e in M)
M.hasOwnProperty(e) && t[e] && (M[e] = t[e]);
return this;
}, z.setFontSize = function (t) {
return A = t, this;
}, z.setFont = function (t, e) {
return h = yt(t, e), this;
}, z.setFontStyle = z.setFontType = function (t) {
return h = yt(void 0, t), this;
}, z.getFontList = function () {
var t, e, n, r = {};
for (t in _)
if (_.hasOwnProperty(t)) {
r[t] = n = [];
for (e in _[t])
_[t].hasOwnProperty(e) && n.push(e);
}
return r;
}, z.addFont = function (t, e, n) {
st(t, e, n, 'StandardEncoding');
}, z.setLineWidth = function (t) {
return X((t * d).toFixed(2) + ' w'), this;
}, z.setDrawColor = function (t, e, n, r) {
var i;
return i = void 0 === e || void 0 === r && t === e === n ? 'string' == typeof t ? t + ' G' : H(t / 255) + ' G' : void 0 === r ? 'string' == typeof t ? [
t,
e,
n,
'RG'
].join(' ') : [
H(t / 255),
H(e / 255),
H(n / 255),
'RG'
].join(' ') : 'string' == typeof t ? [
t,
e,
n,
r,
'K'
].join(' ') : [
H(t),
H(e),
H(n),
H(r),
'K'
].join(' '), X(i), this;
}, z.setFillColor = function (t, e, n, r) {
var i;
return void 0 === e || void 0 === r && t === e === n ? i = 'string' == typeof t ? t + ' g' : H(t / 255) + ' g' : void 0 === r || 'object' == typeof r ? (i = 'string' == typeof t ? [
t,
e,
n,
'rg'
].join(' ') : [
H(t / 255),
H(e / 255),
H(n / 255),
'rg'
].join(' '), r && 0 === r.a && (i = [
'255',
'255',
'255',
'rg'
].join(' '))) : i = 'string' == typeof t ? [
t,
e,
n,
r,
'k'
].join(' ') : [
H(t),
H(e),
H(n),
H(r),
'k'
].join(' '), X(i), this;
}, z.setTextColor = function (t, e, n) {
if ('string' == typeof t && /^#[0-9A-Fa-f]{6}$/.test(t)) {
var r = parseInt(t.substr(1), 16);
t = r >> 16 & 255, e = r >> 8 & 255, n = 255 & r;
}
return x = 0 === t && 0 === e && 0 === n || 'undefined' == typeof e ? W(t / 255) + ' g' : [
W(t / 255),
W(e / 255),
W(n / 255),
'rg'
].join(' '), this;
}, z.CapJoinStyles = {
0: 0,
butt: 0,
but: 0,
miter: 0,
1: 1,
round: 1,
rounded: 1,
circle: 1,
2: 2,
projecting: 2,
project: 2,
square: 2,
bevel: 2
}, z.setLineCap = function (t) {
var e = this.CapJoinStyles[t];
if (void 0 === e)
throw new Error('Line cap style of \'' + t + '\' is not recognized. See or extend .CapJoinStyles property for valid styles');
return N = e, X(e + ' J'), this;
}, z.setLineJoin = function (t) {
var e = this.CapJoinStyles[t];
if (void 0 === e)
throw new Error('Line join style of \'' + t + '\' is not recognized. See or extend .CapJoinStyles property for valid styles');
return j = e, X(e + ' j'), this;
}, z.output = At, z.save = function (t) {
z.output('save', t);
};
for (var Ct in n.API)
n.API.hasOwnProperty(Ct) && ('events' === Ct && n.API.events.length ? !function (t, e) {
var n, r, i;
for (i = e.length - 1; -1 !== i; i--)
n = e[i][0], r = e[i][1], t.subscribe.apply(t, [n].concat('function' == typeof r ? [r] : r));
}(U, n.API.events) : z[Ct] = n.API[Ct]);
return at(), h = 'F1', mt(c, s), U.publish('initialized'), z;
}
var r = '1.3', o = {
a0: [
2383.94,
3370.39
],
a1: [
1683.78,
2383.94
],
a2: [
1190.55,
1683.78
],
a3: [
841.89,
1190.55
],
a4: [
595.28,
841.89
],
a5: [
419.53,
595.28
],
a6: [
297.64,
419.53
],
a7: [
209.76,
297.64
],
a8: [
147.4,
209.76
],
a9: [
104.88,
147.4
],
a10: [
73.7,
104.88
],
b0: [
2834.65,
4008.19
],
b1: [
2004.09,
2834.65
],
b2: [
1417.32,
2004.09
],
b3: [
1000.63,
1417.32
],
b4: [
708.66,
1000.63
],
b5: [
498.9,
708.66
],
b6: [
354.33,
498.9
],
b7: [
249.45,
354.33
],
b8: [
175.75,
249.45
],
b9: [
124.72,
175.75
],
b10: [
87.87,
124.72
],
c0: [
2599.37,
3676.54
],
c1: [
1836.85,
2599.37
],
c2: [
1298.27,
1836.85
],
c3: [
918.43,
1298.27
],
c4: [
649.13,
918.43
],
c5: [
459.21,
649.13
],
c6: [
323.15,
459.21
],
c7: [
229.61,
323.15
],
c8: [
161.57,
229.61
],
c9: [
113.39,
161.57
],
c10: [
79.37,
113.39
],
dl: [
311.81,
623.62
],
letter: [
612,
792
],
'government-letter': [
576,
756
],
legal: [
612,
1008
],
'junior-legal': [
576,
360
],
ledger: [
1224,
792
],
tabloid: [
792,
1224
],
'credit-card': [
153,
243
]
};
return n.API = { events: [] }, n.version = '1.2.61-git 2016-03-01T16:15:jameshall', 'function' == typeof define && define.amd ? define('jsPDF', function () {
return n;
}) : 'undefined' != typeof module && module.exports ? module.exports = n : t.jsPDF = n, n;
}('undefined' != typeof self && self || 'undefined' != typeof window && window || this);
(AcroForm = function (t) {
'use strict';
AcroForm.scale = function (t) {
return t * (e.internal.scaleFactor / 1);
}, AcroForm.antiScale = function (t) {
return 1 / e.internal.scaleFactor * t;
};
var e = {
fields: [],
xForms: [],
acroFormDictionaryRoot: null,
printedOut: !1,
internal: null
};
jsPDF.API.acroformPlugin = e;
var n = function () {
for (var t in this.acroformPlugin.acroFormDictionaryRoot.Fields) {
var e = this.acroformPlugin.acroFormDictionaryRoot.Fields[t];
e.hasAnnotation && i.call(this, e);
}
}, r = function () {
if (this.acroformPlugin.acroFormDictionaryRoot)
throw new Error('Exception while creating AcroformDictionary');
this.acroformPlugin.acroFormDictionaryRoot = new AcroForm.AcroFormDictionary(), this.acroformPlugin.internal = this.internal, this.acroformPlugin.acroFormDictionaryRoot._eventID = this.internal.events.subscribe('postPutResources', a), this.internal.events.subscribe('buildDocument', n), this.internal.events.subscribe('putCatalog', s), this.internal.events.subscribe('postPutPages', c);
}, i = function (t) {
var e = {
type: 'reference',
object: t
};
jsPDF.API.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push(e);
}, o = function (t) {
this.acroformPlugin.printedOut && (this.acroformPlugin.printedOut = !1, this.acroformPlugin.acroFormDictionaryRoot = null), this.acroformPlugin.acroFormDictionaryRoot || r.call(this), this.acroformPlugin.acroFormDictionaryRoot.Fields.push(t);
}, s = function () {
'undefined' != typeof this.acroformPlugin.acroFormDictionaryRoot ? this.internal.write('/AcroForm ' + this.acroformPlugin.acroFormDictionaryRoot.objId + ' 0 R') : console.log('Root missing...');
}, a = function () {
this.internal.events.unsubscribe(this.acroformPlugin.acroFormDictionaryRoot._eventID), delete this.acroformPlugin.acroFormDictionaryRoot._eventID, this.acroformPlugin.printedOut = !0;
}, c = function (t) {
var e = !t;
t || (this.internal.newObjectDeferredBegin(this.acroformPlugin.acroFormDictionaryRoot.objId), this.internal.out(this.acroformPlugin.acroFormDictionaryRoot.getString()));
var t = t || this.acroformPlugin.acroFormDictionaryRoot.Kids;
for (var n in t) {
var r = t[n], i = r.Rect;
r.Rect && (r.Rect = AcroForm.internal.calculateCoordinates.call(this, r.Rect)), this.internal.newObjectDeferredBegin(r.objId);
var o = '';
if (o += r.objId + ' 0 obj\n', o += '<<\n' + r.getContent(), r.Rect = i, r.hasAppearanceStream && !r.appearanceStreamContent) {
var s = AcroForm.internal.calculateAppearanceStream.call(this, r);
o += '/AP << /N ' + s + ' >>\n', this.acroformPlugin.xForms.push(s);
}
if (r.appearanceStreamContent) {
o += '/AP << ';
for (var a in r.appearanceStreamContent) {
var c = r.appearanceStreamContent[a];
if (o += '/' + a + ' ', o += '<< ', Object.keys(c).length >= 1 || Array.isArray(c))
for (var n in c) {
var l = c[n];
'function' == typeof l && (l = l.call(this, r)), o += '/' + n + ' ' + l + ' ', this.acroformPlugin.xForms.indexOf(l) >= 0 || this.acroformPlugin.xForms.push(l);
}
else {
var l = c;
'function' == typeof l && (l = l.call(this, r)), o += '/' + n + ' ' + l + ' \n', this.acroformPlugin.xForms.indexOf(l) >= 0 || this.acroformPlugin.xForms.push(l);
}
o += ' >>\n';
}
o += '>>\n';
}
o += '>>\nendobj\n', this.internal.out(o);
}
e && u.call(this, this.acroformPlugin.xForms);
}, u = function (t) {
for (var e in t) {
var n = e, r = t[e];
this.internal.newObjectDeferredBegin(r.objId);
var i = '';
i += r.getString(), this.internal.out(i), delete t[n];
}
};
t.addField = function (t) {
return t instanceof AcroForm.TextField ? h.call(this, t) : t instanceof AcroForm.ChoiceField ? d.call(this, t) : t instanceof AcroForm.Button ? l.call(this, t) : t instanceof AcroForm.ChildClass ? o.call(this, t) : t && o.call(this, t), this;
};
var l = function (t) {
var t = t || new AcroForm.Field();
t.FT = '/Btn';
var e = t.Ff || 0;
t.pushbutton && (e = AcroForm.internal.setBitPosition(e, 17), delete t.pushbutton), t.radio && (e = AcroForm.internal.setBitPosition(e, 16), delete t.radio), t.noToggleToOff && (e = AcroForm.internal.setBitPosition(e, 15)), t.Ff = e, o.call(this, t);
}, h = function (t) {
var t = t || new AcroForm.Field();
t.FT = '/Tx';
var e = t.Ff || 0;
t.multiline && (e = 4096 | e), t.password && (e = 8192 | e), t.fileSelect && (e |= 1 << 20), t.doNotSpellCheck && (e |= 1 << 22), t.doNotScroll && (e |= 1 << 23), t.Ff = t.Ff || e, o.call(this, t);
}, d = function (t) {
var e = t || new AcroForm.Field();
e.FT = '/Ch';
var n = e.Ff || 0;
e.combo && (n = AcroForm.internal.setBitPosition(n, 18), delete e.combo), e.edit && (n = AcroForm.internal.setBitPosition(n, 19), delete e.edit), e.sort && (n = AcroForm.internal.setBitPosition(n, 20), delete e.sort), e.multiSelect && this.internal.getPDFVersion() >= 1.4 && (n = AcroForm.internal.setBitPosition(n, 22), delete e.multiSelect), e.doNotSpellCheck && this.internal.getPDFVersion() >= 1.4 && (n = AcroForm.internal.setBitPosition(n, 23), delete e.doNotSpellCheck), e.Ff = n, o.call(this, e);
};
})(jsPDF.API), AcroForm.internal = {}, AcroForm.createFormXObject = function (t) {
var e = new AcroForm.FormXObject(), n = AcroForm.Appearance.internal.getHeight(t) || 0, r = AcroForm.Appearance.internal.getWidth(t) || 0;
return e.BBox = [
0,
0,
r,
n
], e;
}, AcroForm.Appearance = {
CheckBox: {
createAppearanceStream: function () {
var t = {
N: { On: AcroForm.Appearance.CheckBox.YesNormal },
D: {
On: AcroForm.Appearance.CheckBox.YesPushDown,
Off: AcroForm.Appearance.CheckBox.OffPushDown
}
};
return t;
},
createMK: function () {
return '<< /CA (3)>>';
},
YesPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = '';
t.Q = 1;
var r = AcroForm.internal.calculateX(t, '3', 'ZapfDingbats', 50);
return n += '0.749023 g\n             0 0 ' + AcroForm.Appearance.internal.getWidth(t) + ' ' + AcroForm.Appearance.internal.getHeight(t) + ' re\n             f\n             BMC\n             q\n             0 0 1 rg\n             /F13 ' + r.fontSize + ' Tf 0 g\n             BT\n', n += r.text, n += 'ET\n             Q\n             EMC\n', e.stream = n, e;
},
YesNormal: function (t) {
var e = AcroForm.createFormXObject(t), n = '';
t.Q = 1;
var r = AcroForm.internal.calculateX(t, '3', 'ZapfDingbats', 0.9 * AcroForm.Appearance.internal.getHeight(t));
return n += '1 g\n0 0 ' + AcroForm.Appearance.internal.getWidth(t) + ' ' + AcroForm.Appearance.internal.getHeight(t) + ' re\nf\nq\n0 0 1 rg\n0 0 ' + (AcroForm.Appearance.internal.getWidth(t) - 1) + ' ' + (AcroForm.Appearance.internal.getHeight(t) - 1) + ' re\nW\nn\n0 g\nBT\n/F13 ' + r.fontSize + ' Tf 0 g\n', n += r.text, n += 'ET\n             Q\n', e.stream = n, e;
},
OffPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = '';
return n += '0.749023 g\n            0 0 ' + AcroForm.Appearance.internal.getWidth(t) + ' ' + AcroForm.Appearance.internal.getHeight(t) + ' re\n            f\n', e.stream = n, e;
}
},
RadioButton: {
Circle: {
createAppearanceStream: function (t) {
var e = {
D: { Off: AcroForm.Appearance.RadioButton.Circle.OffPushDown },
N: {}
};
return e.N[t] = AcroForm.Appearance.RadioButton.Circle.YesNormal, e.D[t] = AcroForm.Appearance.RadioButton.Circle.YesPushDown, e;
},
createMK: function () {
return '<< /CA (l)>>';
},
YesNormal: function (t) {
var e = AcroForm.createFormXObject(t), n = '', r = AcroForm.Appearance.internal.getWidth(t) <= AcroForm.Appearance.internal.getHeight(t) ? AcroForm.Appearance.internal.getWidth(t) / 4 : AcroForm.Appearance.internal.getHeight(t) / 4;
r *= 0.9;
var i = AcroForm.Appearance.internal.Bezier_C;
return n += 'q\n1 0 0 1 ' + AcroForm.Appearance.internal.getWidth(t) / 2 + ' ' + AcroForm.Appearance.internal.getHeight(t) / 2 + ' cm\n' + r + ' 0 m\n' + r + ' ' + r * i + ' ' + r * i + ' ' + r + ' 0 ' + r + ' c\n-' + r * i + ' ' + r + ' -' + r + ' ' + r * i + ' -' + r + ' 0 c\n-' + r + ' -' + r * i + ' -' + r * i + ' -' + r + ' 0 -' + r + ' c\n' + r * i + ' -' + r + ' ' + r + ' -' + r * i + ' ' + r + ' 0 c\nf\nQ\n', e.stream = n, e;
},
YesPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = '', r = AcroForm.Appearance.internal.getWidth(t) <= AcroForm.Appearance.internal.getHeight(t) ? AcroForm.Appearance.internal.getWidth(t) / 4 : AcroForm.Appearance.internal.getHeight(t) / 4;
r *= 0.9;
var i = AcroForm.Appearance.internal.Bezier_C;
return n += '0.749023 g\n            q\n           1 0 0 1 ' + AcroForm.Appearance.internal.getWidth(t) / 2 + ' ' + AcroForm.Appearance.internal.getHeight(t) / 2 + ' cm\n' + 2 * r + ' 0 m\n' + 2 * r + ' ' + 2 * r * i + ' ' + 2 * r * i + ' ' + 2 * r + ' 0 ' + 2 * r + ' c\n-' + 2 * r * i + ' ' + 2 * r + ' -' + 2 * r + ' ' + 2 * r * i + ' -' + 2 * r + ' 0 c\n-' + 2 * r + ' -' + 2 * r * i + ' -' + 2 * r * i + ' -' + 2 * r + ' 0 -' + 2 * r + ' c\n' + 2 * r * i + ' -' + 2 * r + ' ' + 2 * r + ' -' + 2 * r * i + ' ' + 2 * r + ' 0 c\n            f\n            Q\n            0 g\n            q\n            1 0 0 1 ' + AcroForm.Appearance.internal.getWidth(t) / 2 + ' ' + AcroForm.Appearance.internal.getHeight(t) / 2 + ' cm\n' + r + ' 0 m\n' + r + ' ' + r * i + ' ' + r * i + ' ' + r + ' 0 ' + r + ' c\n-' + r * i + ' ' + r + ' -' + r + ' ' + r * i + ' -' + r + ' 0 c\n-' + r + ' -' + r * i + ' -' + r * i + ' -' + r + ' 0 -' + r + ' c\n' + r * i + ' -' + r + ' ' + r + ' -' + r * i + ' ' + r + ' 0 c\n            f\n            Q\n', e.stream = n, e;
},
OffPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = '', r = AcroForm.Appearance.internal.getWidth(t) <= AcroForm.Appearance.internal.getHeight(t) ? AcroForm.Appearance.internal.getWidth(t) / 4 : AcroForm.Appearance.internal.getHeight(t) / 4;
r *= 0.9;
var i = AcroForm.Appearance.internal.Bezier_C;
return n += '0.749023 g\n            q\n 1 0 0 1 ' + AcroForm.Appearance.internal.getWidth(t) / 2 + ' ' + AcroForm.Appearance.internal.getHeight(t) / 2 + ' cm\n' + 2 * r + ' 0 m\n' + 2 * r + ' ' + 2 * r * i + ' ' + 2 * r * i + ' ' + 2 * r + ' 0 ' + 2 * r + ' c\n-' + 2 * r * i + ' ' + 2 * r + ' -' + 2 * r + ' ' + 2 * r * i + ' -' + 2 * r + ' 0 c\n-' + 2 * r + ' -' + 2 * r * i + ' -' + 2 * r * i + ' -' + 2 * r + ' 0 -' + 2 * r + ' c\n' + 2 * r * i + ' -' + 2 * r + ' ' + 2 * r + ' -' + 2 * r * i + ' ' + 2 * r + ' 0 c\n            f\n            Q\n', e.stream = n, e;
}
},
Cross: {
createAppearanceStream: function (t) {
var e = {
D: { Off: AcroForm.Appearance.RadioButton.Cross.OffPushDown },
N: {}
};
return e.N[t] = AcroForm.Appearance.RadioButton.Cross.YesNormal, e.D[t] = AcroForm.Appearance.RadioButton.Cross.YesPushDown, e;
},
createMK: function () {
return '<< /CA (8)>>';
},
YesNormal: function (t) {
var e = AcroForm.createFormXObject(t), n = '', r = AcroForm.Appearance.internal.calculateCross(t);
return n += 'q\n            1 1 ' + (AcroForm.Appearance.internal.getWidth(t) - 2) + ' ' + (AcroForm.Appearance.internal.getHeight(t) - 2) + ' re\n            W\n            n\n            ' + r.x1.x + ' ' + r.x1.y + ' m\n            ' + r.x2.x + ' ' + r.x2.y + ' l\n            ' + r.x4.x + ' ' + r.x4.y + ' m\n            ' + r.x3.x + ' ' + r.x3.y + ' l\n            s\n            Q\n', e.stream = n, e;
},
YesPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = AcroForm.Appearance.internal.calculateCross(t), r = '';
return r += '0.749023 g\n            0 0 ' + AcroForm.Appearance.internal.getWidth(t) + ' ' + AcroForm.Appearance.internal.getHeight(t) + ' re\n            f\n            q\n            1 1 ' + (AcroForm.Appearance.internal.getWidth(t) - 2) + ' ' + (AcroForm.Appearance.internal.getHeight(t) - 2) + ' re\n            W\n            n\n            ' + n.x1.x + ' ' + n.x1.y + ' m\n            ' + n.x2.x + ' ' + n.x2.y + ' l\n            ' + n.x4.x + ' ' + n.x4.y + ' m\n            ' + n.x3.x + ' ' + n.x3.y + ' l\n            s\n            Q\n', e.stream = r, e;
},
OffPushDown: function (t) {
var e = AcroForm.createFormXObject(t), n = '';
return n += '0.749023 g\n            0 0 ' + AcroForm.Appearance.internal.getWidth(t) + ' ' + AcroForm.Appearance.internal.getHeight(t) + ' re\n            f\n', e.stream = n, e;
}
}
},
createDefaultAppearanceStream: function (t) {
var e = '';
return e += '/Helv 12 Tf 0 g';
}
}, AcroForm.Appearance.internal = {
Bezier_C: 0.551915024494,
calculateCross: function (t) {
var e = function (t, e) {
return t > e ? e : t;
}, n = AcroForm.Appearance.internal.getWidth(t), r = AcroForm.Appearance.internal.getHeight(t), i = e(n, r), o = {
x1: {
x: (n - i) / 2,
y: (r - i) / 2 + i
},
x2: {
x: (n - i) / 2 + i,
y: (r - i) / 2
},
x3: {
x: (n - i) / 2,
y: (r - i) / 2
},
x4: {
x: (n - i) / 2 + i,
y: (r - i) / 2 + i
}
};
return o;
}
}, AcroForm.Appearance.internal.getWidth = function (t) {
return t.Rect[2];
}, AcroForm.Appearance.internal.getHeight = function (t) {
return t.Rect[3];
}, AcroForm.internal.inherit = function (t, e) {
Object.create || function (t) {
var e = function () {
};
return e.prototype = t, new e();
};
t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
}, AcroForm.internal.arrayToPdfArray = function (t) {
if (Array.isArray(t)) {
var e = ' [';
for (var n in t) {
var r = t[n].toString();
e += r, e += n < t.length - 1 ? ' ' : '';
}
return e += ']';
}
}, AcroForm.internal.toPdfString = function (t) {
return t = t || '', 0 !== String.indexOf('(', 0) && (t = '(' + t), ')' != t.substring(t.length - 1) && (t += '('), t;
}, AcroForm.PDFObject = function () {
var t;
Object.defineProperty(this, 'objId', {
get: function () {
return t || (this.internal ? t = this.internal.newObjectDeferred() : jsPDF.API.acroformPlugin.internal && (t = jsPDF.API.acroformPlugin.internal.newObjectDeferred())), t || console.log('Couldn\'t create Object ID'), t;
},
configurable: !1
});
}, AcroForm.PDFObject.prototype.toString = function () {
return this.objId + ' 0 R';
}, AcroForm.PDFObject.prototype.getString = function () {
var t = this.objId + ' 0 obj\n<<', e = this.getContent();
return t += e + '>>\n', this.stream && (t += 'stream\n', t += this.stream, t += 'endstream\n'), t += 'endobj\n';
}, AcroForm.PDFObject.prototype.getContent = function () {
var t = function (t) {
var e = '', n = Object.keys(t).filter(function (t) {
return 'content' != t && 'appearanceStreamContent' != t && '_' != t.substring(0, 1);
});
for (var r in n) {
var i = n[r], o = t[i];
o && (e += Array.isArray(o) ? '/' + i + ' ' + AcroForm.internal.arrayToPdfArray(o) + '\n' : o instanceof AcroForm.PDFObject ? '/' + i + ' ' + o.objId + ' 0 R\n' : '/' + i + ' ' + o + '\n');
}
return e;
}, e = '';
return e += t(this);
}, AcroForm.FormXObject = function () {
AcroForm.PDFObject.call(this), this.Type = '/XObject', this.Subtype = '/Form', this.FormType = 1, this.BBox, this.Matrix, this.Resources = '2 0 R', this.PieceInfo;
var t;
Object.defineProperty(this, 'Length', {
enumerable: !0,
get: function () {
return void 0 !== t ? t.length : 0;
}
}), Object.defineProperty(this, 'stream', {
enumerable: !1,
set: function (e) {
t = e;
},
get: function () {
return t ? t : null;
}
});
}, AcroForm.internal.inherit(AcroForm.FormXObject, AcroForm.PDFObject), AcroForm.AcroFormDictionary = function () {
AcroForm.PDFObject.call(this);
var t = [];
Object.defineProperty(this, 'Kids', {
enumerable: !1,
configurable: !0,
get: function () {
return t.length > 0 ? t : void 0;
}
}), Object.defineProperty(this, 'Fields', {
enumerable: !0,
configurable: !0,
get: function () {
return t;
}
}), this.DA;
}, AcroForm.internal.inherit(AcroForm.AcroFormDictionary, AcroForm.PDFObject), AcroForm.Field = function () {
'use strict';
AcroForm.PDFObject.call(this);
var t;
Object.defineProperty(this, 'Rect', {
enumerable: !0,
configurable: !1,
get: function () {
if (t) {
var e = t;
return e;
}
},
set: function (e) {
t = e;
}
});
var e = '';
Object.defineProperty(this, 'FT', {
enumerable: !0,
set: function (t) {
e = t;
},
get: function () {
return e;
}
});
var n;
Object.defineProperty(this, 'T', {
enumerable: !0,
configurable: !1,
set: function (t) {
n = t;
},
get: function () {
if (!n || n.length < 1) {
if (this instanceof AcroForm.ChildClass)
return;
return '(FieldObject' + AcroForm.Field.FieldNum++ + ')';
}
return '(' == n.substring(0, 1) && n.substring(n.length - 1) ? n : '(' + n + ')';
}
});
var r;
Object.defineProperty(this, 'DA', {
enumerable: !0,
get: function () {
return r ? '(' + r + ')' : void 0;
},
set: function (t) {
r = t;
}
});
var i;
Object.defineProperty(this, 'DV', {
enumerable: !0,
configurable: !0,
get: function () {
return i ? i : void 0;
},
set: function (t) {
i = t;
}
}), Object.defineProperty(this, 'Type', {
enumerable: !0,
get: function () {
return this.hasAnnotation ? '/Annot' : null;
}
}), Object.defineProperty(this, 'Subtype', {
enumerable: !0,
get: function () {
return this.hasAnnotation ? '/Widget' : null;
}
}), this.BG, Object.defineProperty(this, 'hasAnnotation', {
enumerable: !1,
get: function () {
return !!(this.Rect || this.BC || this.BG);
}
}), Object.defineProperty(this, 'hasAppearanceStream', {
enumerable: !1,
configurable: !0
});
}, AcroForm.Field.FieldNum = 0, AcroForm.internal.inherit(AcroForm.Field, AcroForm.PDFObject), AcroForm.ChoiceField = function () {
AcroForm.Field.call(this), this.FT = '/Ch', this.Opt = [], this.V = '()', this.TI = 0, this.combo = !1, Object.defineProperty(this, 'edit', {
enumerable: !0,
set: function (t) {
1 == t ? (this._edit = !0, this.combo = !0) : this._edit = !1;
},
get: function () {
return this._edit ? this._edit : !1;
},
configurable: !1
}), this.hasAppearanceStream = !0, this.V.get = function () {
AcroForm.internal.toPdfString();
};
}, AcroForm.internal.inherit(AcroForm.ChoiceField, AcroForm.Field), window.ChoiceField = AcroForm.ChoiceField, AcroForm.ListBox = function () {
AcroForm.ChoiceField.call(this);
}, AcroForm.internal.inherit(AcroForm.ListBox, AcroForm.ChoiceField), window.ListBox = AcroForm.ListBox, AcroForm.ComboBox = function () {
AcroForm.ListBox.call(this), this.combo = !0;
}, AcroForm.internal.inherit(AcroForm.ComboBox, AcroForm.ListBox), window.ComboBox = AcroForm.ComboBox, AcroForm.EditBox = function () {
AcroForm.ComboBox.call(this), this.edit = !0;
}, AcroForm.internal.inherit(AcroForm.EditBox, AcroForm.ComboBox), window.EditBox = AcroForm.EditBox, AcroForm.Button = function () {
AcroForm.Field.call(this), this.FT = '/Btn';
}, AcroForm.internal.inherit(AcroForm.Button, AcroForm.Field), window.Button = AcroForm.Button, AcroForm.PushButton = function () {
AcroForm.Button.call(this), this.pushbutton = !0;
}, AcroForm.internal.inherit(AcroForm.PushButton, AcroForm.Button), window.PushButton = AcroForm.PushButton, AcroForm.RadioButton = function () {
AcroForm.Button.call(this), this.radio = !0;
var t = [];
Object.defineProperty(this, 'Kids', {
enumerable: !0,
get: function () {
return t.length > 0 ? t : void 0;
}
}), Object.defineProperty(this, '__Kids', {
get: function () {
return t;
}
});
var e;
Object.defineProperty(this, 'noToggleToOff', {
enumerable: !1,
get: function () {
return e;
},
set: function (t) {
e = t;
}
});
}, AcroForm.internal.inherit(AcroForm.RadioButton, AcroForm.Button), window.RadioButton = AcroForm.RadioButton, AcroForm.ChildClass = function (t, e) {
AcroForm.Field.call(this), this.Parent = t, this._AppearanceType = AcroForm.Appearance.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(e), this.F = AcroForm.internal.setBitPosition(this.F, 3, 1), this.MK = this._AppearanceType.createMK(), this.AS = '/Off', this._Name = e;
}, AcroForm.internal.inherit(AcroForm.ChildClass, AcroForm.Field), AcroForm.RadioButton.prototype.setAppearance = function (t) {
if (!('createAppearanceStream' in t && 'createMK' in t))
return void console.log('Couldn\'t assign Appearance to RadioButton. Appearance was Invalid!');
for (var e in this.__Kids) {
var n = this.__Kids[e];
n.appearanceStreamContent = t.createAppearanceStream(n._Name), n.MK = t.createMK();
}
}, AcroForm.RadioButton.prototype.createOption = function (t) {
var e = this, n = (this.__Kids.length, new AcroForm.ChildClass(e, t));
return this.__Kids.push(n), jsPDF.API.addField(n), n;
}, AcroForm.CheckBox = function () {
Button.call(this), this.appearanceStreamContent = AcroForm.Appearance.CheckBox.createAppearanceStream(), this.MK = AcroForm.Appearance.CheckBox.createMK(), this.AS = '/On', this.V = '/On';
}, AcroForm.internal.inherit(AcroForm.CheckBox, AcroForm.Button), window.CheckBox = AcroForm.CheckBox, AcroForm.TextField = function () {
AcroForm.Field.call(this);
var t;
Object.defineProperty(this, 'V', {
get: function () {
return t ? '(' + t + ')' : t;
},
enumerable: !0,
set: function (e) {
t = e;
}
});
var e;
Object.defineProperty(this, 'DV', {
get: function () {
return e ? '(' + e + ')' : e;
},
enumerable: !0,
set: function (t) {
e = t;
}
});
var n = !1;
Object.defineProperty(this, 'multiline', {
enumerable: !1,
get: function () {
return n;
},
set: function (t) {
n = t;
}
}), Object.defineProperty(this, 'hasAppearanceStream', {
enumerable: !1,
get: function () {
return this.V || this.DV;
}
});
}, AcroForm.internal.inherit(AcroForm.TextField, AcroForm.Field), window.TextField = AcroForm.TextField, AcroForm.PasswordField = function () {
TextField.call(this), Object.defineProperty(this, 'password', {
value: !0,
enumerable: !1,
configurable: !1,
writable: !1
});
}, AcroForm.internal.inherit(AcroForm.PasswordField, AcroForm.TextField), window.PasswordField = AcroForm.PasswordField, AcroForm.internal.calculateFontSpace = function (t, e, n) {
var n = n || 'helvetica', r = AcroForm.internal.calculateFontSpace.canvas || (AcroForm.internal.calculateFontSpace.canvas = document.createElement('canvas')), i = r.getContext('2d');
i.save();
var o = e + ' ' + n;
i.font = o;
var s = i.measureText(t);
i.fontcolor = 'black';
var i = r.getContext('2d');
s.height = 1.5 * i.measureText('3').width, i.restore();
s.width;
return s;
}, AcroForm.internal.calculateX = function (t, e, n, r) {
var r = r || 12, n = n || 'helvetica', i = {
text: '',
fontSize: ''
};
e = '(' == e.substr(0, 1) ? e.substr(1) : e, e = ')' == e.substr(e.length - 1) ? e.substr(0, e.length - 1) : e;
var o = e.split(' '), s = r, a = 2, c = 2, u = AcroForm.Appearance.internal.getHeight(t) || 0;
u = 0 > u ? -u : u;
var l = AcroForm.Appearance.internal.getWidth(t) || 0;
l = 0 > l ? -l : l;
var h = function (t, e, r) {
if (t + 1 < o.length) {
var i = e + ' ' + o[t + 1], s = AcroForm.internal.calculateFontSpace(i, r + 'px', n).width, a = l - 2 * c;
return a >= s;
}
return !1;
};
s++;
t:
for (;;) {
var e = '';
s--;
var d = AcroForm.internal.calculateFontSpace('3', s + 'px', n).height, f = t.multiline ? u - s : (u - d) / 2;
f += a;
var p = -c, m = p, g = f, w = 0, y = 0, v = 0;
if (0 == s) {
s = 12, e = '(...) Tj\n', e += '% Width of Text: ' + AcroForm.internal.calculateFontSpace(e, '1px').width + ', FieldWidth:' + l + '\n';
break;
}
v = AcroForm.internal.calculateFontSpace(o[0] + ' ', s + 'px', n).width;
var b = '', x = 0;
for (var k in o) {
b += o[k] + ' ', b = ' ' == b.substr(b.length - 1) ? b.substr(0, b.length - 1) : b;
var A = parseInt(k);
v = AcroForm.internal.calculateFontSpace(b + ' ', s + 'px', n).width;
var C = h(A, b, s), E = k >= o.length - 1;
if (!C || E) {
if (C || E) {
if (E)
y = A;
else if (t.multiline && (d + a) * (x + 2) + a > u)
continue t;
} else {
if (!t.multiline)
continue t;
if ((d + a) * (x + 2) + a > u)
continue t;
y = A;
}
for (var S = '', F = w; y >= F; F++)
S += o[F] + ' ';
switch (S = ' ' == S.substr(S.length - 1) ? S.substr(0, S.length - 1) : S, v = AcroForm.internal.calculateFontSpace(S, s + 'px', n).width, t.Q) {
case 2:
p = l - v - c;
break;
case 1:
p = (l - v) / 2;
break;
case 0:
default:
p = c;
}
e += p + ' ' + g + ' Td\n', e += '(' + S + ') Tj\n', e += -p + ' 0 Td\n', g = -(s + a), m = p, v = 0, w = y + 1, x++, b = '';
} else
b += ' ';
}
break;
}
return i.text = e, i.fontSize = s, i;
}, AcroForm.internal.calculateAppearanceStream = function (t) {
if (t.appearanceStreamContent)
return t.appearanceStreamContent;
if (t.V || t.DV) {
var e = '', n = t.V || t.DV, r = AcroForm.internal.calculateX(t, n);
e += '/Tx BMC\nq\n/F1 ' + r.fontSize + ' Tf\n1 0 0 1 0 0 Tm\n', e += 'BT\n', e += r.text, e += 'ET\n', e += 'Q\nEMC\n';
var i = new AcroForm.createFormXObject(t);
i.stream = e;
return i;
}
}, AcroForm.internal.calculateCoordinates = function (t, e, n, r) {
function i(t) {
return t * this.internal.scaleFactor;
}
var o = {};
return this.internal ? Array.isArray(t) ? (t[0] = AcroForm.scale(t[0]), t[1] = AcroForm.scale(t[1]), t[2] = AcroForm.scale(t[2]), t[3] = AcroForm.scale(t[3]), o.lowerLeft_X = 0 | t[0], o.lowerLeft_Y = i.call(this, this.internal.pageSize.height) - t[3] - t[1] | 0, o.upperRight_X = t[0] + t[2] | 0, o.upperRight_Y = i.call(this, this.internal.pageSize.height) - t[1] | 0) : (t = AcroForm.scale(t), e = AcroForm.scale(e), n = AcroForm.scale(n), r = AcroForm.scale(r), o.lowerLeft_X = 0 | t, o.lowerLeft_Y = this.internal.pageSize.height - e | 0, o.upperRight_X = t + n | 0, o.upperRight_Y = this.internal.pageSize.height - e + r | 0) : Array.isArray(t) ? (o.lowerLeft_X = 0 | t[0], o.lowerLeft_Y = 0 | t[1], o.upperRight_X = t[0] + t[2] | 0, o.upperRight_Y = t[1] + t[3] | 0) : (o.lowerLeft_X = 0 | t, o.lowerLeft_Y = 0 | e, o.upperRight_X = t + n | 0, o.upperRight_Y = e + r | 0), [
o.lowerLeft_X,
o.lowerLeft_Y,
o.upperRight_X,
o.upperRight_Y
];
}, AcroForm.internal.calculateColor = function (t, e, n) {
var r = new Array(3);
return r.r = 0 | t, r.g = 0 | e, r.b = 0 | n, r;
}, AcroForm.internal.getBitPosition = function (t, e) {
t = t || 0;
var n = 1;
return n <<= e - 1, t | n;
}, AcroForm.internal.setBitPosition = function (t, e, n) {
t = t || 0, n = n || 1;
var r = 1;
if (r <<= e - 1, 1 == n)
var t = t | r;
else
var t = t & ~r;
return t;
}, function (t) {
'use strict';
t.addHTML = function (t, e, n, r, i) {
if ('undefined' == typeof html2canvas && 'undefined' == typeof rasterizeHTML)
throw new Error('You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js');
'number' != typeof e && (r = e, i = n), 'function' == typeof r && (i = r, r = null);
var o = this.internal, s = o.scaleFactor, a = o.pageSize.width, c = o.pageSize.height;
if (r = r || {}, r.onrendered = function (t) {
e = parseInt(e) || 0, n = parseInt(n) || 0;
var o = r.dim || {}, u = o.h || 0, l = o.w || Math.min(a, t.width / s) - e, h = 'JPEG';
if (r.format && (h = r.format), t.height > c && r.pagesplit) {
var d = function () {
for (var r = 0;;) {
var o = document.createElement('canvas');
o.width = Math.min(a * s, t.width), o.height = Math.min(c * s, t.height - r);
var u = o.getContext('2d');
u.drawImage(t, 0, r, t.width, o.height, 0, 0, o.width, o.height);
var d = [
o,
e,
r ? 0 : n,
o.width / s,
o.height / s,
h,
null,
'SLOW'
];
if (this.addImage.apply(this, d), r += o.height, r >= t.height)
break;
this.addPage();
}
i(l, r, null, d);
}.bind(this);
if ('CANVAS' === t.nodeName) {
var f = new Image();
f.onload = d, f.src = t.toDataURL('image/png'), t = f;
} else
d();
} else {
var p = Math.random().toString(35), m = [
t,
e,
n,
l,
u,
h,
p,
'SLOW'
];
this.addImage.apply(this, m), i(l, u, p, m);
}
}.bind(this), 'undefined' != typeof html2canvas && !r.rstz)
return html2canvas(t, r);
if ('undefined' != typeof rasterizeHTML) {
var u = 'drawDocument';
return 'string' == typeof t && (u = /^http/.test(t) ? 'drawURL' : 'drawHTML'), r.width = r.width || a * s, rasterizeHTML[u](t, void 0, r).then(function (t) {
r.onrendered(t.image);
}, function (t) {
i(null, t);
});
}
return null;
};
}(jsPDF.API), function (t) {
'use strict';
var e = 'addImage_', n = [
'jpeg',
'jpg',
'png'
], r = function (t) {
var e = this.internal.newObject(), n = this.internal.write, i = this.internal.putStream;
if (t.n = e, n('<</Type /XObject'), n('/Subtype /Image'), n('/Width ' + t.w), n('/Height ' + t.h), t.cs === this.color_spaces.INDEXED ? n('/ColorSpace [/Indexed /DeviceRGB ' + (t.pal.length / 3 - 1) + ' ' + ('smask' in t ? e + 2 : e + 1) + ' 0 R]') : (n('/ColorSpace /' + t.cs), t.cs === this.color_spaces.DEVICE_CMYK && n('/Decode [1 0 1 0 1 0 1 0]')), n('/BitsPerComponent ' + t.bpc), 'f' in t && n('/Filter /' + t.f), 'dp' in t && n('/DecodeParms <<' + t.dp + '>>'), 'trns' in t && t.trns.constructor == Array) {
for (var o = '', s = 0, a = t.trns.length; a > s; s++)
o += t.trns[s] + ' ' + t.trns[s] + ' ';
n('/Mask [' + o + ']');
}
if ('smask' in t && n('/SMask ' + (e + 1) + ' 0 R'), n('/Length ' + t.data.length + '>>'), i(t.data), n('endobj'), 'smask' in t) {
var c = '/Predictor 15 /Colors 1 /BitsPerComponent ' + t.bpc + ' /Columns ' + t.w, u = {
w: t.w,
h: t.h,
cs: 'DeviceGray',
bpc: t.bpc,
dp: c,
data: t.smask
};
'f' in t && (u.f = t.f), r.call(this, u);
}
t.cs === this.color_spaces.INDEXED && (this.internal.newObject(), n('<< /Length ' + t.pal.length + '>>'), i(this.arrayBufferToBinaryString(new Uint8Array(t.pal))), n('endobj'));
}, i = function () {
var t = this.internal.collections[e + 'images'];
for (var n in t)
r.call(this, t[n]);
}, o = function () {
var t, n = this.internal.collections[e + 'images'], r = this.internal.write;
for (var i in n)
t = n[i], r('/I' + t.i, t.n, '0', 'R');
}, s = function (e) {
return e && 'string' == typeof e && (e = e.toUpperCase()), e in t.image_compression ? e : t.image_compression.NONE;
}, a = function () {
var t = this.internal.collections[e + 'images'];
return t || (this.internal.collections[e + 'images'] = t = {}, this.internal.events.subscribe('putResources', i), this.internal.events.subscribe('putXobjectDict', o)), t;
}, c = function (t) {
var e = 0;
return t && (e = Object.keys ? Object.keys(t).length : function (t) {
var e = 0;
for (var n in t)
t.hasOwnProperty(n) && e++;
return e;
}(t)), e;
}, u = function (t) {
return 'undefined' == typeof t || null === t;
}, l = function (e) {
return 'string' == typeof e && t.sHashCode(e);
}, h = function (t) {
return -1 === n.indexOf(t);
}, d = function (e) {
return 'function' != typeof t['process' + e.toUpperCase()];
}, f = function (t) {
return 'object' == typeof t && 1 === t.nodeType;
}, p = function (t, e, n) {
if ('IMG' === t.nodeName && t.hasAttribute('src')) {
var r = '' + t.getAttribute('src');
if (!n && 0 === r.indexOf('data:image/'))
return r;
!e && /\.png(?:[?#].*)?$/i.test(r) && (e = 'png');
}
if ('CANVAS' === t.nodeName)
var i = t;
else {
var i = document.createElement('canvas');
i.width = t.clientWidth || t.width, i.height = t.clientHeight || t.height;
var o = i.getContext('2d');
if (!o)
throw 'addImage requires canvas to be supported by browser.';
if (n) {
var s, a, c, u, l, h, d, f, p = Math.PI / 180;
'object' == typeof n && (s = n.x, a = n.y, c = n.bg, n = n.angle), f = n * p, u = Math.abs(Math.cos(f)), l = Math.abs(Math.sin(f)), h = i.width, d = i.height, i.width = d * l + h * u, i.height = d * u + h * l, isNaN(s) && (s = i.width / 2), isNaN(a) && (a = i.height / 2), o.clearRect(0, 0, i.width, i.height), o.fillStyle = c || 'white', o.fillRect(0, 0, i.width, i.height), o.save(), o.translate(s, a), o.rotate(f), o.drawImage(t, -(h / 2), -(d / 2)), o.rotate(-f), o.translate(-s, -a), o.restore();
} else
o.drawImage(t, 0, 0, i.width, i.height);
}
return i.toDataURL('png' == ('' + e).toLowerCase() ? 'image/png' : 'image/jpeg');
}, m = function (t, e) {
var n;
if (e)
for (var r in e)
if (t === e[r].alias) {
n = e[r];
break;
}
return n;
}, g = function (t, e, n) {
return t || e || (t = -96, e = -96), 0 > t && (t = -1 * n.w * 72 / t / this.internal.scaleFactor), 0 > e && (e = -1 * n.h * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * n.w / n.h), 0 === e && (e = t * n.h / n.w), [
t,
e
];
}, w = function (t, e, n, r, i, o, s) {
var a = g.call(this, n, r, i), c = this.internal.getCoordinateString, u = this.internal.getVerticalCoordinateString;
n = a[0], r = a[1], s[o] = i, this.internal.write('q', c(n), '0 0', c(r), c(t), u(e + r), 'cm /I' + i.i, 'Do Q');
};
t.color_spaces = {
DEVICE_RGB: 'DeviceRGB',
DEVICE_GRAY: 'DeviceGray',
DEVICE_CMYK: 'DeviceCMYK',
CAL_GREY: 'CalGray',
CAL_RGB: 'CalRGB',
LAB: 'Lab',
ICC_BASED: 'ICCBased',
INDEXED: 'Indexed',
PATTERN: 'Pattern',
SEPERATION: 'Seperation',
DEVICE_N: 'DeviceN'
}, t.decode = {
DCT_DECODE: 'DCTDecode',
FLATE_DECODE: 'FlateDecode',
LZW_DECODE: 'LZWDecode',
JPX_DECODE: 'JPXDecode',
JBIG2_DECODE: 'JBIG2Decode',
ASCII85_DECODE: 'ASCII85Decode',
ASCII_HEX_DECODE: 'ASCIIHexDecode',
RUN_LENGTH_DECODE: 'RunLengthDecode',
CCITT_FAX_DECODE: 'CCITTFaxDecode'
}, t.image_compression = {
NONE: 'NONE',
FAST: 'FAST',
MEDIUM: 'MEDIUM',
SLOW: 'SLOW'
}, t.sHashCode = function (t) {
return Array.prototype.reduce && t.split('').reduce(function (t, e) {
return t = (t << 5) - t + e.charCodeAt(0), t & t;
}, 0);
}, t.isString = function (t) {
return 'string' == typeof t;
}, t.extractInfoFromBase64DataURI = function (t) {
return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(t);
}, t.supportsArrayBuffer = function () {
return 'undefined' != typeof ArrayBuffer && 'undefined' != typeof Uint8Array;
}, t.isArrayBuffer = function (t) {
return this.supportsArrayBuffer() ? t instanceof ArrayBuffer : !1;
}, t.isArrayBufferView = function (t) {
return this.supportsArrayBuffer() ? 'undefined' == typeof Uint32Array ? !1 : t instanceof Int8Array || t instanceof Uint8Array || 'undefined' != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array : !1;
}, t.binaryStringToUint8Array = function (t) {
for (var e = t.length, n = new Uint8Array(e), r = 0; e > r; r++)
n[r] = t.charCodeAt(r);
return n;
}, t.arrayBufferToBinaryString = function (t) {
if ('TextDecoder' in window) {
var e = new TextDecoder('ascii');
return e.decode(t);
}
this.isArrayBuffer(t) && (t = new Uint8Array(t));
for (var n = '', r = t.byteLength, i = 0; r > i; i++)
n += String.fromCharCode(t[i]);
return n;
}, t.arrayBufferToBase64 = function (t) {
for (var e, n, r, i, o, s = '', a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', c = new Uint8Array(t), u = c.byteLength, l = u % 3, h = u - l, d = 0; h > d; d += 3)
o = c[d] << 16 | c[d + 1] << 8 | c[d + 2], e = (16515072 & o) >> 18, n = (258048 & o) >> 12, r = (4032 & o) >> 6, i = 63 & o, s += a[e] + a[n] + a[r] + a[i];
return 1 == l ? (o = c[h], e = (252 & o) >> 2, n = (3 & o) << 4, s += a[e] + a[n] + '==') : 2 == l && (o = c[h] << 8 | c[h + 1], e = (64512 & o) >> 10, n = (1008 & o) >> 4, r = (15 & o) << 2, s += a[e] + a[n] + a[r] + '='), s;
}, t.createImageInfo = function (t, e, n, r, i, o, s, a, c, u, l, h) {
var d = {
alias: a,
w: e,
h: n,
cs: r,
bpc: i,
i: s,
data: t
};
return o && (d.f = o), c && (d.dp = c), u && (d.trns = u), l && (d.pal = l), h && (d.smask = h), d;
}, t.addImage = function (t, e, r, i, o, g, y, v, b) {
if ('string' != typeof e) {
var x = g;
g = o, o = i, i = r, r = e, e = x;
}
if ('object' == typeof t && !f(t) && 'imageData' in t) {
var k = t;
t = k.imageData, e = k.format || e, r = k.x || r || 0, i = k.y || i || 0, o = k.w || o, g = k.h || g, y = k.alias || y, v = k.compression || v, b = k.rotation || k.angle || b;
}
if (isNaN(r) || isNaN(i))
throw console.error('jsPDF.addImage: Invalid coordinates', arguments), new Error('Invalid coordinates passed to jsPDF.addImage');
var A, C = a.call(this);
if (!(A = m(t, C))) {
var E;
if (f(t) && (t = p(t, e, b)), u(y) && (y = l(t)), !(A = m(y, C))) {
if (this.isString(t)) {
var S = this.extractInfoFromBase64DataURI(t);
S ? (e = S[2], t = atob(S[3])) : 137 === t.charCodeAt(0) && 80 === t.charCodeAt(1) && 78 === t.charCodeAt(2) && 71 === t.charCodeAt(3) && (e = 'png');
}
if (e = (e || 'JPEG').toLowerCase(), h(e))
throw new Error('addImage currently only supports formats ' + n + ', not \'' + e + '\'');
if (d(e))
throw new Error('please ensure that the plugin for \'' + e + '\' support is added');
if (this.supportsArrayBuffer() && (t instanceof Uint8Array || (E = t, t = this.binaryStringToUint8Array(t))), A = this['process' + e.toUpperCase()](t, c(C), y, s(v), E), !A)
throw new Error('An unkwown error occurred whilst processing the image');
}
}
return w.call(this, r, i, o, g, A, A.i, C), this;
};
var y = function (t) {
var e, n, r;
if (255 === !t.charCodeAt(0) || 216 === !t.charCodeAt(1) || 255 === !t.charCodeAt(2) || 224 === !t.charCodeAt(3) || !t.charCodeAt(6) === 'J'.charCodeAt(0) || !t.charCodeAt(7) === 'F'.charCodeAt(0) || !t.charCodeAt(8) === 'I'.charCodeAt(0) || !t.charCodeAt(9) === 'F'.charCodeAt(0) || 0 === !t.charCodeAt(10))
throw new Error('getJpegSize requires a binary string jpeg file');
for (var i = 256 * t.charCodeAt(4) + t.charCodeAt(5), o = 4, s = t.length; s > o;) {
if (o += i, 255 !== t.charCodeAt(o))
throw new Error('getJpegSize could not find the size of the image');
if (192 === t.charCodeAt(o + 1) || 193 === t.charCodeAt(o + 1) || 194 === t.charCodeAt(o + 1) || 195 === t.charCodeAt(o + 1) || 196 === t.charCodeAt(o + 1) || 197 === t.charCodeAt(o + 1) || 198 === t.charCodeAt(o + 1) || 199 === t.charCodeAt(o + 1))
return n = 256 * t.charCodeAt(o + 5) + t.charCodeAt(o + 6), e = 256 * t.charCodeAt(o + 7) + t.charCodeAt(o + 8), r = t.charCodeAt(o + 9), [
e,
n,
r
];
o += 2, i = 256 * t.charCodeAt(o) + t.charCodeAt(o + 1);
}
}, v = function (t) {
var e = t[0] << 8 | t[1];
if (65496 !== e)
throw new Error('Supplied data is not a JPEG');
for (var n, r, i, o, s = t.length, a = (t[4] << 8) + t[5], c = 4; s > c;) {
if (c += a, n = b(t, c), a = (n[2] << 8) + n[3], (192 === n[1] || 194 === n[1]) && 255 === n[0] && a > 7)
return n = b(t, c + 5), r = (n[2] << 8) + n[3], i = (n[0] << 8) + n[1], o = n[4], {
width: r,
height: i,
numcomponents: o
};
c += 2;
}
throw new Error('getJpegSizeFromBytes could not find the size of the image');
}, b = function (t, e) {
return t.subarray(e, e + 5);
};
t.processJPEG = function (t, e, n, r, i) {
var o, s = this.color_spaces.DEVICE_RGB, a = this.decode.DCT_DECODE, c = 8;
return this.isString(t) ? (o = y(t), this.createImageInfo(t, o[0], o[1], 1 == o[3] ? this.color_spaces.DEVICE_GRAY : s, c, a, e, n)) : (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t) ? (o = v(t), t = i || this.arrayBufferToBinaryString(t), this.createImageInfo(t, o.width, o.height, 1 == o.numcomponents ? this.color_spaces.DEVICE_GRAY : s, c, a, e, n)) : null);
}, t.processJPG = function () {
return this.processJPEG.apply(this, arguments);
};
}(jsPDF.API), function (t) {
'use strict';
var e = {
annotations: [],
f2: function (t) {
return t.toFixed(2);
},
notEmpty: function (t) {
return 'undefined' != typeof t && '' != t ? !0 : void 0;
}
};
return jsPDF.API.annotationPlugin = e, jsPDF.API.events.push([
'addPage',
function (t) {
this.annotationPlugin.annotations[t.pageNumber] = [];
}
]), t.events.push([
'putPage',
function (t) {
for (var n = this.annotationPlugin.annotations[t.pageNumber], r = !1, i = 0; i < n.length && !r; i++) {
var o = n[i];
switch (o.type) {
case 'link':
if (e.notEmpty(o.options.url) || e.notEmpty(o.options.pageNumber)) {
r = !0;
break;
}
case 'reference':
case 'text':
case 'freetext':
r = !0;
}
}
if (0 != r) {
this.internal.write('/Annots [');
for (var s = this.annotationPlugin.f2, a = this.internal.scaleFactor, c = this.internal.pageSize.height, u = this.internal.getPageInfo(t.pageNumber), i = 0; i < n.length; i++) {
var o = n[i];
switch (o.type) {
case 'reference':
this.internal.write(' ' + o.object.objId + ' 0 R ');
break;
case 'text':
var l = this.internal.newAdditionalObject(), h = this.internal.newAdditionalObject(), d = o.title || 'Note', f = '/Rect [' + s(o.bounds.x * a) + ' ' + s(c - (o.bounds.y + o.bounds.h) * a) + ' ' + s((o.bounds.x + o.bounds.w) * a) + ' ' + s((c - o.bounds.y) * a) + '] ';
y = '<</Type /Annot /Subtype /Text ' + f + '/Contents (' + o.contents + ')', y += ' /Popup ' + h.objId + ' 0 R', y += ' /P ' + u.objId + ' 0 R', y += ' /T (' + d + ') >>', l.content = y;
var p = l.objId + ' 0 R', m = 30, f = '/Rect [' + s((o.bounds.x + m) * a) + ' ' + s(c - (o.bounds.y + o.bounds.h) * a) + ' ' + s((o.bounds.x + o.bounds.w + m) * a) + ' ' + s((c - o.bounds.y) * a) + '] ';
y = '<</Type /Annot /Subtype /Popup ' + f + ' /Parent ' + p, o.open && (y += ' /Open true'), y += ' >>', h.content = y, this.internal.write(l.objId, '0 R', h.objId, '0 R');
break;
case 'freetext':
var f = '/Rect [' + s(o.bounds.x * a) + ' ' + s((c - o.bounds.y) * a) + ' ' + s(o.bounds.x + o.bounds.w * a) + ' ' + s(c - (o.bounds.y + o.bounds.h) * a) + '] ', g = o.color || '#000000';
y = '<</Type /Annot /Subtype /FreeText ' + f + '/Contents (' + o.contents + ')', y += ' /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#' + g + ')', y += ' /Border [0 0 0]', y += ' >>', this.internal.write(y);
break;
case 'link':
if (o.options.name) {
var w = this.annotations._nameMap[o.options.name];
o.options.pageNumber = w.page, o.options.top = w.y;
} else
o.options.top || (o.options.top = 0);
var f = '/Rect [' + s(o.x * a) + ' ' + s((c - o.y) * a) + ' ' + s(o.x + o.w * a) + ' ' + s(c - (o.y + o.h) * a) + '] ', y = '';
if (o.options.url)
y = '<</Type /Annot /Subtype /Link ' + f + '/Border [0 0 0] /A <</S /URI /URI (' + o.options.url + ') >>';
else if (o.options.pageNumber) {
var t = this.internal.getPageInfo(o.options.pageNumber);
switch (y = '<</Type /Annot /Subtype /Link ' + f + '/Border [0 0 0] /Dest [' + t.objId + ' 0 R', o.options.magFactor = o.options.magFactor || 'XYZ', o.options.magFactor) {
case 'Fit':
y += ' /Fit]';
break;
case 'FitH':
y += ' /FitH ' + o.options.top + ']';
break;
case 'FitV':
o.options.left = o.options.left || 0, y += ' /FitV ' + o.options.left + ']';
break;
case 'XYZ':
default:
var v = s((c - o.options.top) * a);
o.options.left = o.options.left || 0, 'undefined' == typeof o.options.zoom && (o.options.zoom = 0), y += ' /XYZ ' + o.options.left + ' ' + v + ' ' + o.options.zoom + ']';
}
}
'' != y && (y += ' >>', this.internal.write(y));
}
}
this.internal.write(']');
}
}
]), t.createAnnotation = function (t) {
switch (t.type) {
case 'link':
this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
break;
case 'text':
case 'freetext':
this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push(t);
}
}, t.link = function (t, e, n, r, i) {
this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({
x: t,
y: e,
w: n,
h: r,
options: i,
type: 'link'
});
}, t.link = function (t, e, n, r, i) {
this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({
x: t,
y: e,
w: n,
h: r,
options: i,
type: 'link'
});
}, t.textWithLink = function (t, e, n, r) {
var i = this.getTextWidth(t), o = this.internal.getLineHeight();
return this.text(t, e, n), n += 0.2 * o, this.link(e, n - o, i, o, r), i;
}, t.getTextWidth = function (t) {
var e = this.internal.getFontSize(), n = this.getStringUnitWidth(t) * e / this.internal.scaleFactor;
return n;
}, t.getLineHeight = function () {
return this.internal.getLineHeight();
}, this;
}(jsPDF.API), function (t) {
'use strict';
t.autoPrint = function () {
var t;
return this.internal.events.subscribe('postPutResources', function () {
t = this.internal.newObject(), this.internal.write('<< /S/Named /Type/Action /N/Print >>', 'endobj');
}), this.internal.events.subscribe('putCatalog', function () {
this.internal.write('/OpenAction ' + t + ' 0 R');
}), this;
};
}(jsPDF.API), function (t) {
'use strict';
return t.events.push([
'initialized',
function () {
this.canvas.pdf = this;
}
]), t.canvas = {
getContext: function (t) {
return this.pdf.context2d;
},
style: {}
}, Object.defineProperty(t.canvas, 'width', {
get: function () {
return this._width;
},
set: function (t) {
this._width = t, this.getContext('2d').pageWrapX = t + 1;
}
}), Object.defineProperty(t.canvas, 'height', {
get: function () {
return this._height;
},
set: function (t) {
this._height = t, this.getContext('2d').pageWrapY = t + 1;
}
}), this;
}(jsPDF.API), function (t) {
'use strict';
var e, n, r, i, o = 3, s = 13, a = {
x: void 0,
y: void 0,
w: void 0,
h: void 0,
ln: void 0
}, c = 1, u = function (t, e, n, r, i) {
a = {
x: t,
y: e,
w: n,
h: r,
ln: i
};
}, l = function () {
return a;
}, h = {
left: 0,
top: 0,
bottom: 0
};
t.setHeaderFunction = function (t) {
i = t;
}, t.getTextDimensions = function (t) {
e = this.internal.getFont().fontName, n = this.table_font_size || this.internal.getFontSize(), r = this.internal.getFont().fontStyle;
var i, o, s = 19.049976 / 25.4;
o = document.createElement('font'), o.id = 'jsPDFCell';
try {
o.style.fontStyle = r;
} catch (a) {
o.style.fontWeight = r;
}
o.style.fontName = e, o.style.fontSize = n + 'pt';
try {
o.textContent = t;
} catch (a) {
o.innerText = t;
}
return document.body.appendChild(o), i = {
w: (o.offsetWidth + 1) * s,
h: (o.offsetHeight + 1) * s
}, document.body.removeChild(o), i;
}, t.cellAddPage = function () {
var t = this.margins || h;
this.addPage(), u(t.left, t.top, void 0, void 0), c += 1;
}, t.cellInitialize = function () {
a = {
x: void 0,
y: void 0,
w: void 0,
h: void 0,
ln: void 0
}, c = 1;
}, t.cell = function (t, e, n, r, i, a, c) {
var d = l(), f = !1;
if (void 0 !== d.ln)
if (d.ln === a)
t = d.x + d.w, e = d.y;
else {
var p = this.margins || h;
d.y + d.h + r + s >= this.internal.pageSize.height - p.bottom && (this.cellAddPage(), f = !0, this.printHeaders && this.tableHeaderRow && this.printHeaderRow(a, !0)), e = l().y + l().h, f && (e = s + 10);
}
if (void 0 !== i[0])
if (this.printingHeaderRow ? this.rect(t, e, n, r, 'FD') : this.rect(t, e, n, r), 'right' === c) {
i instanceof Array || (i = [i]);
for (var m = 0; m < i.length; m++) {
var g = i[m], w = this.getStringUnitWidth(g) * this.internal.getFontSize();
this.text(g, t + n - w - o, e + this.internal.getLineHeight() * (m + 1));
}
} else
this.text(i, t + o, e + this.internal.getLineHeight());
return u(t, e, n, r, a), this;
}, t.arrayMax = function (t, e) {
var n, r, i, o = t[0];
for (n = 0, r = t.length; r > n; n += 1)
i = t[n], e ? -1 === e(o, i) && (o = i) : i > o && (o = i);
return o;
}, t.table = function (e, n, r, i, o) {
if (!r)
throw 'No data for PDF table';
var s, u, l, d, f, p, m, g, w, y, v = [], b = [], x = {}, k = {}, A = [], C = [], E = !1, S = !0, F = 12, T = h;
if (T.width = this.internal.pageSize.width, o && (o.autoSize === !0 && (E = !0), o.printHeaders === !1 && (S = !1), o.fontSize && (F = o.fontSize), o.css['font-size'] && (F = 16 * o.css['font-size']), o.margins && (T = o.margins)), this.lnMod = 0, a = {
x: void 0,
y: void 0,
w: void 0,
h: void 0,
ln: void 0
}, c = 1, this.printHeaders = S, this.margins = T, this.setFontSize(F), this.table_font_size = F, void 0 === i || null === i)
v = Object.keys(r[0]);
else if (i[0] && 'string' != typeof i[0]) {
var P = 19.049976 / 25.4;
for (u = 0, l = i.length; l > u; u += 1)
s = i[u], v.push(s.name), b.push(s.prompt), k[s.name] = s.width * P;
} else
v = i;
if (E)
for (y = function (t) {
return t[s];
}, u = 0, l = v.length; l > u; u += 1) {
for (s = v[u], x[s] = r.map(y), A.push(this.getTextDimensions(b[u] || s).w), p = x[s], m = 0, d = p.length; d > m; m += 1)
f = p[m], A.push(this.getTextDimensions(f).w);
k[s] = t.arrayMax(A), A = [];
}
if (S) {
var _ = this.calculateLineHeight(v, k, b.length ? b : v);
for (u = 0, l = v.length; l > u; u += 1)
s = v[u], C.push([
e,
n,
k[s],
_,
String(b.length ? b[u] : s)
]);
this.setTableHeaderRow(C), this.printHeaderRow(1, !1);
}
for (u = 0, l = r.length; l > u; u += 1) {
var _;
for (g = r[u], _ = this.calculateLineHeight(v, k, g), m = 0, w = v.length; w > m; m += 1)
s = v[m], this.cell(e, n, k[s], _, g[s], u + 2, s.align);
}
return this.lastCellPos = a, this.table_x = e, this.table_y = n, this;
}, t.calculateLineHeight = function (t, e, n) {
for (var r, i = 0, s = 0; s < t.length; s++) {
r = t[s], n[r] = this.splitTextToSize(String(n[r]), e[r] - o);
var a = this.internal.getLineHeight() * n[r].length + o;
a > i && (i = a);
}
return i;
}, t.setTableHeaderRow = function (t) {
this.tableHeaderRow = t;
}, t.printHeaderRow = function (t, e) {
if (!this.tableHeaderRow)
throw 'Property tableHeaderRow does not exist.';
var n, r, o, a;
if (this.printingHeaderRow = !0, void 0 !== i) {
var l = i(this, c);
u(l[0], l[1], l[2], l[3], -1);
}
this.setFontStyle('bold');
var h = [];
for (o = 0, a = this.tableHeaderRow.length; a > o; o += 1)
this.setFillColor(200, 200, 200), n = this.tableHeaderRow[o], e && (this.margins.top = s, n[1] = this.margins && this.margins.top || 0, h.push(n)), r = [].concat(n), this.cell.apply(this, r.concat(t));
h.length > 0 && this.setTableHeaderRow(h), this.setFontStyle('normal'), this.printingHeaderRow = !1;
};
}(jsPDF.API), function (t) {
'use strict';
function e() {
this.fillStyle = '#000000', this.strokeStyle = '#000000', this.font = '12pt times', this.textBaseline = 'alphabetic', this.lineWidth = 1, this.lineJoin = 'miter', this.lineCap = 'butt', this._translate = {
x: 0,
y: 0
}, this.copy = function (t) {
this.fillStyle = t.fillStyle, this.strokeStyle = t.strokeStyle, this.font = t.font, this.lineWidth = t.lineWidth, this.lineJoin = t.lineJoin, this.lineCap = t.lineCap, this.textBaseline = t.textBaseline, this._fontSize = t._fontSize, this._translate = {
x: t._translate.x,
y: t._translate.y
};
};
}
t.events.push([
'initialized',
function () {
this.context2d.pdf = this, this.context2d.internal.pdf = this, this.context2d.ctx = new e(), this.context2d.ctxStack = [], this.context2d.path = [];
}
]), t.context2d = {
pageWrapXEnabled: !1,
pageWrapYEnabled: !0,
pageWrapX: 9999999,
pageWrapY: 9999999,
f2: function (t) {
return t.toFixed(2);
},
fillRect: function (t, e, n, r) {
t = this._wrapX(t), e = this._wrapY(e), this.pdf.rect(t, e, n, r, 'f');
},
strokeRect: function (t, e, n, r) {
t = this._wrapX(t), e = this._wrapY(e), this.pdf.rect(t, e, n, r, 's');
},
clearRect: function (t, e, n, r) {
t = this._wrapX(t), e = this._wrapY(e), this.save(), this.setFillStyle('#ffffff'), this.pdf.rect(t, e, n, r, 'f'), this.restore();
},
save: function () {
this.ctx._fontSize = this.pdf.internal.getFontSize();
var t = new e();
t.copy(this.ctx), this.ctxStack.push(this.ctx), this.ctx = t;
},
restore: function () {
this.ctx = this.ctxStack.pop(), this.setFillStyle(this.ctx.fillStyle), this.setStrokeStyle(this.ctx.strokeStyle), this.setFont(this.ctx.font), this.pdf.setFontSize(this.ctx._fontSize), this.setLineCap(this.ctx.lineCap), this.setLineWidth(this.ctx.lineWidth), this.setLineJoin(this.ctx.lineJoin);
},
beginPath: function () {
this.path = [];
},
closePath: function () {
this.path.push({ type: 'close' });
},
setFillStyle: function (t) {
var e, n, r, i, o = this.internal.rxRgb.exec(t);
null != o ? (e = parseInt(o[1]), n = parseInt(o[2]), r = parseInt(o[3])) : (o = this.internal.rxRgba.exec(t), null != o ? (e = parseInt(o[1]), n = parseInt(o[2]), r = parseInt(o[3]), i = parseInt(o[4])) : ('#' != t.charAt(0) && (t = CssColors.colorNameToHex(t), t || (t = '#000000')), this.ctx.fillStyle = t, 4 === t.length ? (e = this.ctx.fillStyle.substring(1, 2), e += e, n = this.ctx.fillStyle.substring(2, 3), n += n, r = this.ctx.fillStyle.substring(3, 4), r += r) : (e = this.ctx.fillStyle.substring(1, 3), n = this.ctx.fillStyle.substring(3, 5), r = this.ctx.fillStyle.substring(5, 7)), e = parseInt(e, 16), n = parseInt(n, 16), r = parseInt(r, 16))), this.pdf.setFillColor(e, n, r, { a: i }), this.pdf.setTextColor(e, n, r, { a: i });
},
setStrokeStyle: function (t) {
'#' != t.charAt(0) && (t = CssColors.colorNameToHex(t), t || (t = '#000000')), this.ctx.strokeStyle = t;
var e = this.ctx.strokeStyle.substring(1, 3);
e = parseInt(e, 16);
var n = this.ctx.strokeStyle.substring(3, 5);
n = parseInt(n, 16);
var r = this.ctx.strokeStyle.substring(5, 7);
r = parseInt(r, 16), this.pdf.setDrawColor(e, n, r);
},
fillText: function (t, e, n, r) {
e = this._wrapX(e), n = this._wrapY(n), this.pdf.text(t, e, this._getBaseline(n));
},
strokeText: function (t, e, n, r) {
e = this._wrapX(e), n = this._wrapY(n), this.pdf.text(t, e, this._getBaseline(n), { stroke: !0 });
},
setFont: function (t) {
this.ctx.font = t;
var e = /\s*(\w+)\s+(\w+)\s+(\w+)\s+([\d\.]+)(px|pt|em)\s+["']?(\w+)['"]?/;
if (c = e.exec(t), null != c) {
var n = c[1], r = (c[2], c[3]), i = c[4], o = c[5], s = c[6];
i = 'px' === o ? Math.floor(parseFloat(i)) : 'em' === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(i)), this.pdf.setFontSize(i), 'bold' === r || '700' === r ? this.pdf.setFontStyle('bold') : 'italic' === n ? this.pdf.setFontStyle('italic') : this.pdf.setFontStyle('normal');
var a = s;
this.pdf.setFont(a, l);
} else {
var e = /(\d+)(pt|px|em)\s+(\w+)\s*(\w+)?/, c = e.exec(t);
if (null != c) {
var u = c[1], a = (c[2], c[3]), l = c[4];
l || (l = 'normal'), u = 'em' === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(u)), this.pdf.setFontSize(u), this.pdf.setFont(a, l);
}
}
},
setTextBaseline: function (t) {
this.ctx.textBaseline = t;
},
getTextBaseline: function () {
return this.ctx.textBaseline;
},
setLineWidth: function (t) {
this.ctx.lineWidth = t, this.pdf.setLineWidth(t);
},
setLineCap: function (t) {
this.ctx.lineCap = t, this.pdf.setLineCap(t);
},
setLineJoin: function (t) {
this.ctx.lineJon = t, this.pdf.setLineJoin(t);
},
moveTo: function (t, e) {
t = this._wrapX(t), e = this._wrapY(e);
var n = {
type: 'mt',
x: t,
y: e
};
this.path.push(n);
},
_wrapX: function (t) {
return this.pageWrapXEnabled ? t % this.pageWrapX : t;
},
_wrapY: function (t) {
return this.pageWrapYEnabled ? (this._gotoPage(this._page(t)), (t - this.lastBreak) % this.pageWrapY) : t;
},
lastBreak: 0,
pageBreaks: [],
_page: function (t) {
if (this.pageWrapYEnabled) {
this.lastBreak = 0;
for (var e = 0, n = 0, r = 0; r < this.pageBreaks.length; r++)
if (t >= this.pageBreaks[r]) {
e++, 0 === this.lastBreak && n++;
var i = this.pageBreaks[r] - this.lastBreak;
this.lastBreak = this.pageBreaks[r];
var o = Math.floor(i / this.pageWrapY);
n += o;
}
if (0 === this.lastBreak) {
var o = Math.floor(t / this.pageWrapY) + 1;
n += o;
}
return n + e;
}
return this.pdf.internal.getCurrentPageInfo().pageNumber;
},
_gotoPage: function (t) {
},
lineTo: function (t, e) {
t = this._wrapX(t), e = this._wrapY(e);
var n = {
type: 'lt',
x: t,
y: e
};
this.path.push(n);
},
bezierCurveTo: function (t, e, n, r, i, o) {
t = this._wrapX(t), e = this._wrapY(e), n = this._wrapX(n), r = this._wrapY(r), i = this._wrapX(i), o = this._wrapY(o);
var s = {
type: 'bct',
x1: t,
y1: e,
x2: n,
y2: r,
x: i,
y: o
};
this.path.push(s);
},
quadraticCurveTo: function (t, e, n, r) {
t = this._wrapX(t), e = this._wrapY(e), n = this._wrapX(n), r = this._wrapY(r);
var i = {
type: 'qct',
x1: t,
y1: e,
x: n,
y: r
};
this.path.push(i);
},
arc: function (t, e, n, r, i, o) {
t = this._wrapX(t), e = this._wrapY(e);
var s = {
type: 'arc',
x: t,
y: e,
radius: n,
startAngle: r,
endAngle: i,
anticlockwise: o
};
this.path.push(s);
},
drawImage: function (t, e, n, r, i, o, s, a, c) {
void 0 !== o && (e = o, n = s, r = a, i = c), e = this._wrapX(e), n = this._wrapY(n);
var u, l = /data:image\/(\w+).*/i, h = l.exec(t);
u = null != h ? h[1] : 'png', this.pdf.addImage(t, u, e, n, r, i);
},
stroke: function () {
for (var t, e = [], n = !1, r = 0; r < this.path.length; r++) {
var i = this.path[r];
switch (i.type) {
case 'mt':
t = i, 'undefined' != typeof t && (this.pdf.lines(e, t.x, t.y, null, 's'), e = []);
break;
case 'lt':
var o = [
i.x - this.path[r - 1].x,
i.y - this.path[r - 1].y
];
e.push(o);
break;
case 'bct':
var o = [
i.x1 - this.path[r - 1].x,
i.y1 - this.path[r - 1].y,
i.x2 - this.path[r - 1].x,
i.y2 - this.path[r - 1].y,
i.x - this.path[r - 1].x,
i.y - this.path[r - 1].y
];
e.push(o);
break;
case 'qct':
var s = this.path[r - 1].x + 2 / 3 * (i.x1 - this.path[r - 1].x), a = this.path[r - 1].y + 2 / 3 * (i.y1 - this.path[r - 1].y), c = i.x + 2 / 3 * (i.x1 - i.x), u = i.y + 2 / 3 * (i.y1 - i.y), l = i.x, h = i.y, o = [
s - this.path[r - 1].x,
a - this.path[r - 1].y,
c - this.path[r - 1].x,
u - this.path[r - 1].y,
l - this.path[r - 1].x,
h - this.path[r - 1].y
];
e.push(o);
break;
case 'close':
n = !0;
}
}
'undefined' != typeof t && this.pdf.lines(e, t.x, t.y, null, 's', n);
for (var r = 0; r < this.path.length; r++) {
var i = this.path[r];
switch (i.type) {
case 'arc':
var t = 360 * i.startAngle / (2 * Math.PI), d = 360 * i.endAngle / (2 * Math.PI);
this.internal.arc(i.x, i.y, i.radius, t, d, i.anticlockwise, 's');
}
}
this.path = [];
},
fill: function () {
for (var t, e = [], n = 0; n < this.path.length; n++) {
var r = this.path[n];
switch (r.type) {
case 'mt':
t = r, 'undefined' != typeof t && (this.pdf.lines(e, t.x, t.y, null, 'f'), e = []);
break;
case 'lt':
var i = [
r.x - this.path[n - 1].x,
r.y - this.path[n - 1].y
];
e.push(i);
break;
case 'bct':
var i = [
r.x1 - this.path[n - 1].x,
r.y1 - this.path[n - 1].y,
r.x2 - this.path[n - 1].x,
r.y2 - this.path[n - 1].y,
r.x - this.path[n - 1].x,
r.y - this.path[n - 1].y
];
e.push(i);
break;
case 'qct':
var o = this.path[n - 1].x + 2 / 3 * (r.x1 - this.path[n - 1].x), s = this.path[n - 1].y + 2 / 3 * (r.y1 - this.path[n - 1].y), a = r.x + 2 / 3 * (r.x1 - r.x), c = r.y + 2 / 3 * (r.y1 - r.y), u = r.x, l = r.y, i = [
o - this.path[n - 1].x,
s - this.path[n - 1].y,
a - this.path[n - 1].x,
c - this.path[n - 1].y,
u - this.path[n - 1].x,
l - this.path[n - 1].y
];
e.push(i);
}
}
'undefined' != typeof t && this.pdf.lines(e, t.x, t.y, null, 'f');
for (var n = 0; n < this.path.length; n++) {
var r = this.path[n];
switch (r.type) {
case 'arc':
var t = 360 * r.startAngle / (2 * Math.PI), h = 360 * r.endAngle / (2 * Math.PI);
this.internal.arc(r.x, r.y, r.radius, t, h, r.anticlockwise, 'f');
break;
case 'close':
this.pdf.internal.out('h');
}
}
this.path = [];
},
clip: function () {
},
translate: function (t, e) {
this.ctx._translate = {
x: t,
y: e
};
},
measureText: function (t) {
var e = this.pdf;
return {
getWidth: function () {
var n = e.internal.getFontSize(), r = e.getStringUnitWidth(t) * n / e.internal.scaleFactor;
return r;
},
get width() {
return this.getWidth(t);
}
};
},
_getBaseline: function (t) {
var e = parseInt(this.pdf.internal.getFontSize()), n = 0.25 * e;
switch (this.ctx.textBaseline) {
case 'bottom':
return t - n;
case 'top':
return t + e;
case 'hanging':
return t + e - n;
case 'middle':
return t + e / 2 - n;
case 'ideographic':
return t;
case 'alphabetic':
default:
return t;
}
}
};
var n = t.context2d;
return Object.defineProperty(n, 'fillStyle', {
set: function (t) {
this.setFillStyle(t);
},
get: function () {
return this.ctx.fillStyle;
}
}), Object.defineProperty(n, 'textBaseline', {
set: function (t) {
this.setTextBaseline(t);
},
get: function () {
return this.getTextBaseline();
}
}), Object.defineProperty(n, 'font', {
set: function (t) {
this.setFont(t);
},
get: function () {
return this.getFont();
}
}), n.internal = {}, n.internal.rxRgb = /rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/, n.internal.rxRgba = /rgba\s*\(\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\s*\)/, n.internal.arc = function (t, e, n, r, i, o, s) {
for (var a = this.pdf.internal.scaleFactor, c = this.pdf.internal.pageSize.height, u = this.pdf.internal.f2, l = r * (Math.PI / 180), h = i * (Math.PI / 180), d = this.createArc(n, l, h, o), f = 0; f < d.length; f++) {
var p = d[f];
0 == f ? this.pdf.internal.out([
u((p.x1 + t) * a),
u((c - (p.y1 + e)) * a),
'm',
u((p.x2 + t) * a),
u((c - (p.y2 + e)) * a),
u((p.x3 + t) * a),
u((c - (p.y3 + e)) * a),
u((p.x4 + t) * a),
u((c - (p.y4 + e)) * a),
'c'
].join(' ')) : this.pdf.internal.out([
u((p.x2 + t) * a),
u((c - (p.y2 + e)) * a),
u((p.x3 + t) * a),
u((c - (p.y3 + e)) * a),
u((p.x4 + t) * a),
u((c - (p.y4 + e)) * a),
'c'
].join(' '));
}
null !== s && this.pdf.internal.out(this.pdf.internal.getStyle(s));
}, n.internal.createArc = function (t, e, n, r) {
var i = 0.00001, o = 2 * Math.PI, s = e;
(o > s || s > o) && (s %= o);
var a = n;
(o > a || a > o) && (a %= o);
for (var c = [], u = Math.PI / 2, l = r ? -1 : 1, h = e, d = Math.min(o, Math.abs(a - s)); d > i;) {
var f = h + l * Math.min(d, u);
c.push(this.createSmallArc(t, h, f)), d -= Math.abs(f - h), h = f;
}
return c;
}, n.internal.createSmallArc = function (t, e, n) {
var r = (n - e) / 2, i = t * Math.cos(r), o = t * Math.sin(r), s = i, a = -o, c = s * s + a * a, u = c + s * i + a * o, l = 4 / 3 * (Math.sqrt(2 * c * u) - u) / (s * o - a * i), h = s - l * a, d = a + l * s, f = h, p = -d, m = r + e, g = Math.cos(m), w = Math.sin(m);
return {
x1: t * Math.cos(e),
y1: t * Math.sin(e),
x2: h * g - d * w,
y2: h * w + d * g,
x3: f * g - p * w,
y3: f * w + p * g,
x4: t * Math.cos(n),
y4: t * Math.sin(n)
};
}, this;
}(jsPDF.API), function (t) {
var e, n, r, i, o, s, a, c, u, l, h, d, f, p, m, g, w, y, v;
e = function () {
function t() {
}
return function (e) {
return t.prototype = e, new t();
};
}(), u = function (t) {
var e, n, r, i, o, s, a;
for (n = 0, r = t.length, e = void 0, i = !1, s = !1; !i && n !== r;)
e = t[n] = t[n].trimLeft(), e && (i = !0), n++;
for (n = r - 1; r && !s && -1 !== n;)
e = t[n] = t[n].trimRight(), e && (s = !0), n--;
for (o = /\s+$/g, a = !0, n = 0; n !== r;)
'\u2028' != t[n] && (e = t[n].replace(/\s+/g, ' '), a && (e = e.trimLeft()), e && (a = o.test(e)), t[n] = e), n++;
return t;
}, l = function (t, e, n, r) {
return this.pdf = t, this.x = e, this.y = n, this.settings = r, this.watchFunctions = [], this.init(), this;
}, h = function (t) {
var e, n, i;
for (e = void 0, i = t.split(','), n = i.shift(); !e && n;)
e = r[n.trim().toLowerCase()], n = i.shift();
return e;
}, d = function (t) {
t = 'auto' === t ? '0px' : t, t.indexOf('em') > -1 && !isNaN(Number(t.replace('em', ''))) && (t = 18.719 * Number(t.replace('em', '')) + 'px'), t.indexOf('pt') > -1 && !isNaN(Number(t.replace('pt', ''))) && (t = 1.333 * Number(t.replace('pt', '')) + 'px');
var e, n, r;
return n = void 0, e = 16, (r = f[t]) ? r : (r = {
'xx-small': 9,
'x-small': 11,
small: 13,
medium: 16,
large: 19,
'x-large': 23,
'xx-large': 28,
auto: 0
}[{ css_line_height_string: t }], r !== n ? f[t] = r / e : (r = parseFloat(t)) ? f[t] = r / e : (r = t.match(/([\d\.]+)(px)/), 3 === r.length ? f[t] = parseFloat(r[1]) / e : f[t] = 1));
}, c = function (t) {
var e, n, r;
return r = function (t) {
var e;
return e = function (t) {
return document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(t, null) : t.currentStyle ? t.currentStyle : t.style;
}(t), function (t) {
return t = t.replace(/-\D/g, function (t) {
return t.charAt(1).toUpperCase();
}), e[t];
};
}(t), e = {}, n = void 0, e['font-family'] = h(r('font-family')) || 'times', e['font-style'] = i[r('font-style')] || 'normal', e['text-align'] = TextAlignMap[r('text-align')] || 'left', n = o[r('font-weight')] || 'normal', 'bold' === n && ('normal' === e['font-style'] ? e['font-style'] = n : e['font-style'] = n + e['font-style']), e['font-size'] = d(r('font-size')) || 1, e['line-height'] = d(r('line-height')) || 1, e.display = 'inline' === r('display') ? 'inline' : 'block', n = 'block' === e.display, e['margin-top'] = n && d(r('margin-top')) || 0, e['margin-bottom'] = n && d(r('margin-bottom')) || 0, e['padding-top'] = n && d(r('padding-top')) || 0, e['padding-bottom'] = n && d(r('padding-bottom')) || 0, e['margin-left'] = n && d(r('margin-left')) || 0, e['margin-right'] = n && d(r('margin-right')) || 0, e['padding-left'] = n && d(r('padding-left')) || 0, e['padding-right'] = n && d(r('padding-right')) || 0, e['page-break-before'] = r('page-break-before') || 'auto', e['float'] = s[r('cssFloat')] || 'none', e.clear = a[r('clear')] || 'none', e.color = r('color'), e;
}, p = function (t, e, n) {
var r, i, o, s, a;
if (o = !1, i = void 0, s = void 0, a = void 0, r = n['#' + t.id])
if ('function' == typeof r)
o = r(t, e);
else
for (i = 0, s = r.length; !o && i !== s;)
o = r[i](t, e), i++;
if (r = n[t.nodeName], !o && r)
if ('function' == typeof r)
o = r(t, e);
else
for (i = 0, s = r.length; !o && i !== s;)
o = r[i](t, e), i++;
return o;
}, v = function (t, e) {
var n, r, i, o, s, a, c, u, l, h;
for (n = [], r = [], i = 0, h = t.rows[0].cells.length, u = t.clientWidth; h > i;)
l = t.rows[0].cells[i], r[i] = {
name: l.textContent.toLowerCase().replace(/\s+/g, ''),
prompt: l.textContent.replace(/\r?\n/g, ''),
width: l.clientWidth / u * e.pdf.internal.pageSize.width
}, i++;
for (i = 1; i < t.rows.length;) {
for (a = t.rows[i], s = {}, o = 0; o < a.cells.length;)
s[r[o].name] = a.cells[o].textContent.replace(/\r?\n/g, ''), o++;
n.push(s), i++;
}
return c = {
rows: n,
headers: r
};
};
var b = {
SCRIPT: 1,
STYLE: 1,
NOSCRIPT: 1,
OBJECT: 1,
EMBED: 1,
SELECT: 1
}, x = 1;
n = function (t, r, i) {
var o, s, a, u, l, h, d, f, g;
for (s = t.childNodes, o = void 0, a = c(t), l = 'block' === a.display, l && (r.setBlockBoundary(), r.setBlockStyle(a)), d = 19.049976 / 25.4, u = 0, h = s.length; h > u;) {
if (o = s[u], 'object' == typeof o) {
if (r.executeWatchFunctions(o), 1 === o.nodeType && 'HEADER' === o.nodeName) {
var w = o, y = r.pdf.margins_doc.top;
r.pdf.internal.events.subscribe('addPage', function (t) {
r.y = y, n(w, r, i), r.pdf.margins_doc.top = r.y + 10, r.y += 10;
}, !1);
}
if (8 === o.nodeType && '#comment' === o.nodeName)
~o.textContent.indexOf('ADD_PAGE') && (r.pdf.addPage(), r.y = r.pdf.margins_doc.top);
else if (1 !== o.nodeType || b[o.nodeName])
if (3 === o.nodeType) {
var k = o.nodeValue;
if (o.nodeValue && 'LI' === o.parentNode.nodeName)
if ('OL' === o.parentNode.parentNode.nodeName)
k = x++ + '. ' + k;
else {
var A = a['font-size'];
offsetX = (3 - 0.75 * A) * r.pdf.internal.scaleFactor, offsetY = 0.75 * A * r.pdf.internal.scaleFactor, radius = 1.74 * A / r.pdf.internal.scaleFactor, g = function (t, e) {
this.pdf.circle(t + offsetX, e + offsetY, radius, 'FD');
};
}
o.ownerDocument.body.contains(o) && r.addText(k, a);
} else
'string' == typeof o && r.addText(o, a);
else {
var C;
if ('IMG' === o.nodeName) {
var E = o.getAttribute('src');
C = m[r.pdf.sHashCode(E) || E];
}
if (C) {
r.pdf.internal.pageSize.height - r.pdf.margins_doc.bottom < r.y + o.height && r.y > r.pdf.margins_doc.top && (r.pdf.addPage(), r.y = r.pdf.margins_doc.top, r.executeWatchFunctions(o));
var S = c(o), F = r.x, T = 12 / r.pdf.internal.scaleFactor, P = (S['margin-left'] + S['padding-left']) * T, _ = (S['margin-right'] + S['padding-right']) * T, I = (S['margin-top'] + S['padding-top']) * T, q = (S['margin-bottom'] + S['padding-bottom']) * T;
F += void 0 !== S['float'] && 'right' === S['float'] ? r.settings.width - o.width - _ : P, r.pdf.addImage(C, F, r.y + I, o.width, o.height), C = void 0, 'right' === S['float'] || 'left' === S['float'] ? (r.watchFunctions.push(function (t, e, n, i) {
return r.y >= e ? (r.x += t, r.settings.width += n, !0) : i && 1 === i.nodeType && !b[i.nodeName] && r.x + i.width > r.pdf.margins_doc.left + r.pdf.margins_doc.width ? (r.x += t, r.y = e, r.settings.width += n, !0) : !1;
}.bind(this, 'left' === S['float'] ? -o.width - P - _ : 0, r.y + o.height + I + q, o.width)), r.watchFunctions.push(function (t, e, n) {
return r.y < t && e === r.pdf.internal.getNumberOfPages() ? 1 === n.nodeType && 'both' === c(n).clear ? (r.y = t, !0) : !1 : !0;
}.bind(this, r.y + o.height, r.pdf.internal.getNumberOfPages())), r.settings.width -= o.width + P + _, 'left' === S['float'] && (r.x += o.width + P + _)) : r.y += o.height + I + q;
} else if ('TABLE' === o.nodeName)
f = v(o, r), r.y += 10, r.pdf.table(r.x, r.y, f.rows, f.headers, {
autoSize: !1,
printHeaders: i.printHeaders,
margins: r.pdf.margins_doc,
css: c(o)
}), r.y = r.pdf.lastCellPos.y + r.pdf.lastCellPos.h + 20;
else if ('OL' === o.nodeName || 'UL' === o.nodeName)
x = 1, p(o, r, i) || n(o, r, i), r.y += 10;
else if ('LI' === o.nodeName) {
var O = r.x;
r.x += 20 / r.pdf.internal.scaleFactor, r.y += 3, p(o, r, i) || n(o, r, i), r.x = O;
} else
'BR' === o.nodeName ? (r.y += a['font-size'] * r.pdf.internal.scaleFactor, r.addText('\u2028', e(a))) : p(o, r, i) || n(o, r, i);
}
}
u++;
}
return i.outY = r.y, l ? r.setBlockBoundary(g) : void 0;
}, m = {}, g = function (t, e, n, r) {
function i() {
e.pdf.internal.events.publish('imagesLoaded'), r(s);
}
function o(t, n, r) {
if (t) {
var o = new Image();
s = ++u, o.crossOrigin = '', o.onerror = o.onload = function () {
if (o.complete && (0 === o.src.indexOf('data:image/') && (o.width = n || o.width || 0, o.height = r || o.height || 0), o.width + o.height)) {
var s = e.pdf.sHashCode(t) || t;
m[s] = m[s] || o;
}
--u || i();
}, o.src = t;
}
}
for (var s, a = t.getElementsByTagName('img'), c = a.length, u = 0; c--;)
o(a[c].getAttribute('src'), a[c].width, a[c].height);
return u || i();
}, w = function (t, e, r) {
var i = t.getElementsByTagName('footer');
if (i.length > 0) {
i = i[0];
var o = e.pdf.internal.write, s = e.y;
e.pdf.internal.write = function () {
}, n(i, e, r);
var a = Math.ceil(e.y - s) + 5;
e.y = s, e.pdf.internal.write = o, e.pdf.margins_doc.bottom += a;
for (var c = function (t) {
var o = void 0 !== t ? t.pageNumber : 1, s = e.y;
e.y = e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom, e.pdf.margins_doc.bottom -= a;
for (var c = i.getElementsByTagName('span'), u = 0; u < c.length; ++u)
(' ' + c[u].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' pageCounter ') > -1 && (c[u].innerHTML = o), (' ' + c[u].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' totalPages ') > -1 && (c[u].innerHTML = '###jsPDFVarTotalPages###');
n(i, e, r), e.pdf.margins_doc.bottom += a, e.y = s;
}, u = i.getElementsByTagName('span'), l = 0; l < u.length; ++l)
(' ' + u[l].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' totalPages ') > -1 && e.pdf.internal.events.subscribe('htmlRenderingFinished', e.pdf.putTotalPages.bind(e.pdf, '###jsPDFVarTotalPages###'), !0);
e.pdf.internal.events.subscribe('addPage', c, !1), c(), b.FOOTER = 1;
}
}, y = function (t, e, r, i, o, s) {
if (!e)
return !1;
'string' == typeof e || e.parentNode || (e = '' + e.innerHTML), 'string' == typeof e && (e = function (t) {
var e, n, r, i;
return r = 'jsPDFhtmlText' + Date.now().toString() + (1000 * Math.random()).toFixed(0), i = 'position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;', n = document.createElement('div'), n.style.cssText = i, n.innerHTML = '<iframe style="height:1px;width:1px" name="' + r + '" />', document.body.appendChild(n), e = window.frames[r], e.document.open(), e.document.writeln(t), e.document.close(), e.document.body;
}(e.replace(/<\/?script[^>]*?>/gi, '')));
var a, c = new l(t, r, i, o);
return g.call(this, e, c, o.elementHandlers, function (t) {
w(e, c, o.elementHandlers), n(e, c, o.elementHandlers), c.pdf.internal.events.publish('htmlRenderingFinished'), a = c.dispose(), 'function' == typeof s ? s(a) : t && console.error('jsPDF Warning: rendering issues? provide a callback to fromHTML!');
}), a || {
x: c.x,
y: c.y
};
}, l.prototype.init = function () {
return this.paragraph = {
text: [],
style: []
}, this.pdf.internal.write('q');
}, l.prototype.dispose = function () {
return this.pdf.internal.write('Q'), {
x: this.x,
y: this.y,
ready: !0
};
}, l.prototype.executeWatchFunctions = function (t) {
var e = !1, n = [];
if (this.watchFunctions.length > 0) {
for (var r = 0; r < this.watchFunctions.length; ++r)
this.watchFunctions[r](t) === !0 ? e = !0 : n.push(this.watchFunctions[r]);
this.watchFunctions = n;
}
return e;
}, l.prototype.splitFragmentsIntoLines = function (t, n) {
var r, i, o, s, a, c, u, l, h, d, f, p, m, g, w;
for (i = 12, f = this.pdf.internal.scaleFactor, a = {}, o = void 0, d = void 0, s = void 0, c = void 0, w = void 0, h = void 0, l = void 0, u = void 0, p = [], m = [p], r = 0, g = this.settings.width; t.length;)
if (c = t.shift(), w = n.shift(), c)
if (o = w['font-family'], d = w['font-style'], s = a[o + d], s || (s = this.pdf.internal.getFont(o, d).metadata.Unicode, a[o + d] = s), h = {
widths: s.widths,
kerning: s.kerning,
fontSize: w['font-size'] * i,
textIndent: r
}, l = this.pdf.getStringUnitWidth(c, h) * h.fontSize / f, '\u2028' == c)
p = [], m.push(p);
else if (r + l > g) {
for (u = this.pdf.splitTextToSize(c, g, h), p.push([
u.shift(),
w
]); u.length;)
p = [[
u.shift(),
w
]], m.push(p);
r = this.pdf.getStringUnitWidth(p[0][0], h) * h.fontSize / f;
} else
p.push([
c,
w
]), r += l;
if (void 0 !== w['text-align'] && ('center' === w['text-align'] || 'right' === w['text-align'] || 'justify' === w['text-align']))
for (var y = 0; y < m.length; ++y) {
var v = this.pdf.getStringUnitWidth(m[y][0][0], h) * h.fontSize / f;
y > 0 && (m[y][0][1] = e(m[y][0][1]));
var b = g - v;
if ('right' === w['text-align'])
m[y][0][1]['margin-left'] = b;
else if ('center' === w['text-align'])
m[y][0][1]['margin-left'] = b / 2;
else if ('justify' === w['text-align']) {
var x = m[y][0][0].split(' ').length - 1;
m[y][0][1]['word-spacing'] = b / x, y === m.length - 1 && (m[y][0][1]['word-spacing'] = 0);
}
}
return m;
}, l.prototype.RenderTextFragment = function (t, e) {
var n, r, i;
i = 0, n = 12, this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize() && (this.pdf.internal.write('ET', 'Q'), this.pdf.addPage(), this.y = this.pdf.margins_doc.top, this.pdf.internal.write('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), e.color, 'Td'), i = Math.max(i, e['line-height'], e['font-size']), this.pdf.internal.write(0, (-1 * n * i).toFixed(2), 'Td')), r = this.pdf.internal.getFont(e['font-family'], e['font-style']);
var o = this.getPdfColor(e.color);
o !== this.lastTextColor && (this.pdf.internal.write(o), this.lastTextColor = o), void 0 !== e['word-spacing'] && e['word-spacing'] > 0 && this.pdf.internal.write(e['word-spacing'].toFixed(2), 'Tw'), this.pdf.internal.write('/' + r.id, (n * e['font-size']).toFixed(2), 'Tf', '(' + this.pdf.internal.pdfEscape(t) + ') Tj'), void 0 !== e['word-spacing'] && this.pdf.internal.write(0, 'Tw');
}, l.prototype.getPdfColor = function (t) {
var e, n, r, i, o = /rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/, s = o.exec(t);
if (null != s ? (n = parseInt(s[1]), r = parseInt(s[2]), i = parseInt(s[3])) : ('#' != t.charAt(0) && (t = CssColors.colorNameToHex(t), t || (t = '#000000')), n = t.substring(1, 3), n = parseInt(n, 16), r = t.substring(3, 5), r = parseInt(r, 16), i = t.substring(5, 7), i = parseInt(i, 16)), 'string' == typeof n && /^#[0-9A-Fa-f]{6}$/.test(n)) {
var a = parseInt(n.substr(1), 16);
n = a >> 16 & 255, r = a >> 8 & 255, i = 255 & a;
}
var c = this.f3;
return e = 0 === n && 0 === r && 0 === i || 'undefined' == typeof r ? c(n / 255) + ' g' : [
c(n / 255),
c(r / 255),
c(i / 255),
'rg'
].join(' ');
}, l.prototype.f3 = function (t) {
return t.toFixed(3);
}, l.prototype.renderParagraph = function (t) {
var e, n, r, i, o, s, a, c, l, h, d, f, p, m, g;
if (i = u(this.paragraph.text), m = this.paragraph.style, e = this.paragraph.blockstyle, p = this.paragraph.priorblockstyle || {}, this.paragraph = {
text: [],
style: [],
blockstyle: {},
priorblockstyle: e
}, i.join('').trim()) {
c = this.splitFragmentsIntoLines(i, m), a = void 0, l = void 0, n = 12, r = n / this.pdf.internal.scaleFactor, this.priorMarginBottom = this.priorMarginBottom || 0, f = (Math.max((e['margin-top'] || 0) - this.priorMarginBottom, 0) + (e['padding-top'] || 0)) * r, d = ((e['margin-bottom'] || 0) + (e['padding-bottom'] || 0)) * r, this.priorMarginBottom = e['margin-bottom'] || 0, 'always' === e['page-break-before'] && (this.pdf.addPage(), this.y = 0, f = ((e['margin-top'] || 0) + (e['padding-top'] || 0)) * r), h = this.pdf.internal.write, o = void 0, s = void 0, this.y += f, h('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), 'Td');
for (var w = 0; c.length;) {
for (a = c.shift(), l = 0, o = 0, s = a.length; o !== s;)
a[o][0].trim() && (l = Math.max(l, a[o][1]['line-height'], a[o][1]['font-size']), g = 7 * a[o][1]['font-size']), o++;
var y = 0, v = 0;
void 0 !== a[0][1]['margin-left'] && a[0][1]['margin-left'] > 0 && (wantedIndent = this.pdf.internal.getCoordinateString(a[0][1]['margin-left']), y = wantedIndent - w, w = wantedIndent);
var v = Math.max(e['margin-left'] || 0, 0) * r;
for (h(y + v, (-1 * n * l).toFixed(2), 'Td'), o = 0, s = a.length; o !== s;)
a[o][0] && this.RenderTextFragment(a[o][0], a[o][1]), o++;
if (this.y += l * r, this.executeWatchFunctions(a[0][1]) && c.length > 0) {
var b = [], x = [];
c.forEach(function (t) {
for (var e = 0, n = t.length; e !== n;)
t[e][0] && (b.push(t[e][0] + ' '), x.push(t[e][1])), ++e;
}), c = this.splitFragmentsIntoLines(u(b), x), h('ET', 'Q'), h('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), 'Td');
}
}
return t && 'function' == typeof t && t.call(this, this.x - 9, this.y - g / 2), h('ET', 'Q'), this.y += d;
}
}, l.prototype.setBlockBoundary = function (t) {
return this.renderParagraph(t);
}, l.prototype.setBlockStyle = function (t) {
return this.paragraph.blockstyle = t;
}, l.prototype.addText = function (t, e) {
return this.paragraph.text.push(t), this.paragraph.style.push(e);
}, r = {
helvetica: 'helvetica',
'sans-serif': 'helvetica',
'times new roman': 'times',
serif: 'times',
times: 'times',
monospace: 'courier',
courier: 'courier'
}, o = {
100: 'normal',
200: 'normal',
300: 'normal',
400: 'normal',
500: 'bold',
600: 'bold',
700: 'bold',
800: 'bold',
900: 'bold',
normal: 'normal',
bold: 'bold',
bolder: 'bold',
lighter: 'normal'
}, i = {
normal: 'normal',
italic: 'italic',
oblique: 'italic'
}, TextAlignMap = {
left: 'left',
right: 'right',
center: 'center',
justify: 'justify'
}, s = {
none: 'none',
right: 'right',
left: 'left'
}, a = {
none: 'none',
both: 'both'
}, f = { normal: 1 }, t.fromHTML = function (t, e, n, r, i, o) {
'use strict';
return this.margins_doc = o || {
top: 0,
bottom: 0
}, r || (r = {}), r.elementHandlers || (r.elementHandlers = {}), y(this, t, isNaN(e) ? 4 : e, isNaN(n) ? 4 : n, r, i);
};
}(jsPDF.API), function (t) {
'use strict';
var e, n, r;
t.addJS = function (t) {
return r = t, this.internal.events.subscribe('postPutResources', function (t) {
e = this.internal.newObject(), this.internal.write('<< /Names [(EmbeddedJS) ' + (e + 1) + ' 0 R] >>', 'endobj'), n = this.internal.newObject(), this.internal.write('<< /S /JavaScript /JS (', r, ') >>', 'endobj');
}), this.internal.events.subscribe('putCatalog', function () {
void 0 !== e && void 0 !== n && this.internal.write('/Names <</JavaScript ' + e + ' 0 R>>');
}), this;
};
}(jsPDF.API), function (t) {
'use strict';
return t.events.push([
'postPutResources',
function () {
var t = this, e = /^(\d+) 0 obj$/;
if (this.outline.root.children.length > 0)
for (var n = t.outline.render().split(/\r\n/), r = 0; r < n.length; r++) {
var i = n[r], o = e.exec(i);
if (null != o) {
var s = o[1];
t.internal.newObjectDeferredBegin(s);
}
t.internal.write(i);
}
if (this.outline.createNamedDestinations) {
for (var a = this.internal.pages.length, c = [], r = 0; a > r; r++) {
var u = t.internal.newObject();
c.push(u);
var l = t.internal.getPageInfo(r + 1);
t.internal.write('<< /D[' + l.objId + ' 0 R /XYZ null null null]>> endobj');
}
var h = t.internal.newObject();
t.internal.write('<< /Names [ ');
for (var r = 0; r < c.length; r++)
t.internal.write('(page_' + (r + 1) + ')' + c[r] + ' 0 R');
t.internal.write(' ] >>', 'endobj');
t.internal.newObject();
t.internal.write('<< /Dests ' + h + ' 0 R'), t.internal.write('>>', 'endobj');
}
}
]), t.events.push([
'putCatalog',
function () {
var t = this;
t.outline.root.children.length > 0 && (t.internal.write('/Outlines', this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t.internal.write('/Names ' + namesOid + ' 0 R'));
}
]), t.events.push([
'initialized',
function () {
var t = this;
t.outline = {
createNamedDestinations: !1,
root: { children: [] }
};
t.outline.add = function (t, e, n) {
var r = {
title: e,
options: n,
children: []
};
return null == t && (t = this.root), t.children.push(r), r;
}, t.outline.render = function () {
return this.ctx = {}, this.ctx.val = '', this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
}, t.outline.genIds_r = function (e) {
e.id = t.internal.newObjectDeferred();
for (var n = 0; n < e.children.length; n++)
this.genIds_r(e.children[n]);
}, t.outline.renderRoot = function (t) {
this.objStart(t), this.line('/Type /Outlines'), t.children.length > 0 && (this.line('/First ' + this.makeRef(t.children[0])), this.line('/Last ' + this.makeRef(t.children[t.children.length - 1]))), this.line('/Count ' + this.count_r({ count: 0 }, t)), this.objEnd();
}, t.outline.renderItems = function (e) {
for (var n = 0; n < e.children.length; n++) {
var r = e.children[n];
this.objStart(r), this.line('/Title ' + this.makeString(r.title)), this.line('/Parent ' + this.makeRef(e)), n > 0 && this.line('/Prev ' + this.makeRef(e.children[n - 1])), n < e.children.length - 1 && this.line('/Next ' + this.makeRef(e.children[n + 1])), r.children.length > 0 && (this.line('/First ' + this.makeRef(r.children[0])), this.line('/Last ' + this.makeRef(r.children[r.children.length - 1])));
var i = this.count = this.count_r({ count: 0 }, r);
if (i > 0 && this.line('/Count ' + i), r.options && r.options.pageNumber) {
var o = t.internal.getPageInfo(r.options.pageNumber);
this.line('/Dest [' + o.objId + ' 0 R /XYZ 0 ' + this.ctx.pdf.internal.pageSize.height + ' 0]');
}
this.objEnd();
}
for (var n = 0; n < e.children.length; n++) {
var r = e.children[n];
this.renderItems(r);
}
}, t.outline.line = function (t) {
this.ctx.val += t + '\r\n';
}, t.outline.makeRef = function (t) {
return t.id + ' 0 R';
}, t.outline.makeString = function (e) {
return '(' + t.internal.pdfEscape(e) + ')';
}, t.outline.objStart = function (t) {
this.ctx.val += '\r\n' + t.id + ' 0 obj\r\n<<\r\n';
}, t.outline.objEnd = function (t) {
this.ctx.val += '>> \r\nendobj\r\n';
}, t.outline.count_r = function (t, e) {
for (var n = 0; n < e.children.length; n++)
t.count++, this.count_r(t, e.children[n]);
return t.count;
};
}
]), this;
}(jsPDF.API), function (t) {
'use strict';
var e = function () {
return 'function' != typeof PNG || 'function' != typeof FlateStream;
}, n = function (e) {
return e !== t.image_compression.NONE && r();
}, r = function () {
var t = 'function' == typeof Deflater;
if (!t)
throw new Error('requires deflate.js for compression');
return t;
}, i = function (e, n, r, i) {
var c = 5, f = l;
switch (i) {
case t.image_compression.FAST:
c = 3, f = u;
break;
case t.image_compression.MEDIUM:
c = 6, f = h;
break;
case t.image_compression.SLOW:
c = 9, f = d;
}
e = a(e, n, r, f);
var p = new Uint8Array(o(c)), m = s(e), g = new Deflater(c), w = g.append(e), y = g.flush(), v = p.length + w.length + y.length, b = new Uint8Array(v + 4);
return b.set(p), b.set(w, p.length), b.set(y, p.length + w.length), b[v++] = m >>> 24 & 255, b[v++] = m >>> 16 & 255, b[v++] = m >>> 8 & 255, b[v++] = 255 & m, t.arrayBufferToBinaryString(b);
}, o = function (t, e) {
var n = 8, r = Math.LOG2E * Math.log(32768) - 8, i = r << 4 | n, o = i << 8, s = Math.min(3, (e - 1 & 255) >> 1);
return o |= s << 6, o |= 0, o += 31 - o % 31, [
i,
255 & o & 255
];
}, s = function (t, e) {
for (var n, r = 1, i = 65535 & r, o = r >>> 16 & 65535, s = t.length, a = 0; s > 0;) {
n = s > e ? e : s, s -= n;
do
i += t[a++], o += i;
while (--n);
i %= 65521, o %= 65521;
}
return (o << 16 | i) >>> 0;
}, a = function (t, e, n, r) {
for (var i, o, s, a = t.length / e, c = new Uint8Array(t.length + a), u = p(), l = 0; a > l; l++) {
if (s = l * e, i = t.subarray(s, s + e), r)
c.set(r(i, n, o), s + l);
else {
for (var h = 0, d = u.length, f = []; d > h; h++)
f[h] = u[h](i, n, o);
var g = m(f.concat());
c.set(f[g], s + l);
}
o = i;
}
return c;
}, c = function (t, e, n) {
var r = Array.apply([], t);
return r.unshift(0), r;
}, u = function (t, e, n) {
var r, i = [], o = 0, s = t.length;
for (i[0] = 1; s > o; o++)
r = t[o - e] || 0, i[o + 1] = t[o] - r + 256 & 255;
return i;
}, l = function (t, e, n) {
var r, i = [], o = 0, s = t.length;
for (i[0] = 2; s > o; o++)
r = n && n[o] || 0, i[o + 1] = t[o] - r + 256 & 255;
return i;
}, h = function (t, e, n) {
var r, i, o = [], s = 0, a = t.length;
for (o[0] = 3; a > s; s++)
r = t[s - e] || 0, i = n && n[s] || 0, o[s + 1] = t[s] + 256 - (r + i >>> 1) & 255;
return o;
}, d = function (t, e, n) {
var r, i, o, s, a = [], c = 0, u = t.length;
for (a[0] = 4; u > c; c++)
r = t[c - e] || 0, i = n && n[c] || 0, o = n && n[c - e] || 0, s = f(r, i, o), a[c + 1] = t[c] - s + 256 & 255;
return a;
}, f = function (t, e, n) {
var r = t + e - n, i = Math.abs(r - t), o = Math.abs(r - e), s = Math.abs(r - n);
return o >= i && s >= i ? t : s >= o ? e : n;
}, p = function () {
return [
c,
u,
l,
h,
d
];
}, m = function (t) {
for (var e, n, r, i = 0, o = t.length; o > i;)
e = g(t[i].slice(1)), (n > e || !n) && (n = e, r = i), i++;
return r;
}, g = function (t) {
for (var e = 0, n = t.length, r = 0; n > e;)
r += Math.abs(t[e++]);
return r;
};
t.processPNG = function (t, r, o, s, a) {
var c, u, l, h, d, f, p = this.color_spaces.DEVICE_RGB, m = this.decode.FLATE_DECODE, g = 8;
if (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t)) {
if (e())
throw new Error('PNG support requires png.js and zlib.js');
if (c = new PNG(t), t = c.imgData, g = c.bits, p = c.colorSpace, h = c.colors, -1 !== [
4,
6
].indexOf(c.colorType)) {
if (8 === c.bits)
for (var w, y, v = 32 == c.pixelBitlength ? new Uint32Array(c.decodePixels().buffer) : 16 == c.pixelBitlength ? new Uint16Array(c.decodePixels().buffer) : new Uint8Array(c.decodePixels().buffer), b = v.length, x = new Uint8Array(b * c.colors), k = new Uint8Array(b), A = c.pixelBitlength - c.bits, C = 0, E = 0; b > C; C++) {
for (w = v[C], y = 0; A > y;)
x[E++] = w >>> y & 255, y += c.bits;
k[C] = w >>> y & 255;
}
if (16 === c.bits) {
for (var w, v = new Uint32Array(c.decodePixels().buffer), b = v.length, x = new Uint8Array(b * (32 / c.pixelBitlength) * c.colors), k = new Uint8Array(b * (32 / c.pixelBitlength)), S = c.colors > 1, C = 0, E = 0, F = 0; b > C;)
w = v[C++], x[E++] = w >>> 0 & 255, S && (x[E++] = w >>> 16 & 255, w = v[C++], x[E++] = w >>> 0 & 255), k[F++] = w >>> 16 & 255;
g = 8;
}
n(s) ? (t = i(x, c.width * c.colors, c.colors, s), f = i(k, c.width, 1, s)) : (t = x, f = k, m = null);
}
if (3 === c.colorType && (p = this.color_spaces.INDEXED, d = c.palette, c.transparency.indexed)) {
for (var T = c.transparency.indexed, P = 0, C = 0, b = T.length; b > C; ++C)
P += T[C];
if (P /= 255, P === b - 1 && -1 !== T.indexOf(0))
l = [T.indexOf(0)];
else if (P !== b) {
for (var v = c.decodePixels(), k = new Uint8Array(v.length), C = 0, b = v.length; b > C; C++)
k[C] = T[v[C]];
f = i(k, c.width, 1);
}
}
return u = m === this.decode.FLATE_DECODE ? '/Predictor 15 /Colors ' + h + ' /BitsPerComponent ' + g + ' /Columns ' + c.width : '/Colors ' + h + ' /BitsPerComponent ' + g + ' /Columns ' + c.width, (this.isArrayBuffer(t) || this.isArrayBufferView(t)) && (t = this.arrayBufferToBinaryString(t)), (f && this.isArrayBuffer(f) || this.isArrayBufferView(f)) && (f = this.arrayBufferToBinaryString(f)), this.createImageInfo(t, c.width, c.height, p, g, m, r, o, u, l, d, f);
}
throw new Error('Unsupported PNG image data, try using JPEG instead.');
};
}(jsPDF.API), function (t) {
'use strict';
t.autoPrint = function () {
var t;
return this.internal.events.subscribe('postPutResources', function () {
t = this.internal.newObject(), this.internal.write('<< /S/Named /Type/Action /N/Print >>', 'endobj');
}), this.internal.events.subscribe('putCatalog', function () {
this.internal.write('/OpenAction ' + t + ' 0 R');
}), this;
};
}(jsPDF.API), function (t) {
'use strict';
var e = t.getCharWidthsArray = function (t, e) {
e || (e = {});
var n, r, i, o = e.widths ? e.widths : this.internal.getFont().metadata.Unicode.widths, s = o.fof ? o.fof : 1, a = e.kerning ? e.kerning : this.internal.getFont().metadata.Unicode.kerning, c = a.fof ? a.fof : 1, u = 0, l = o[0] || s, h = [];
for (n = 0, r = t.length; r > n; n++)
i = t.charCodeAt(n), h.push((o[i] || l) / s + (a[i] && a[i][u] || 0) / c), u = i;
return h;
}, n = function (t) {
for (var e = t.length, n = 0; e;)
e--, n += t[e];
return n;
}, r = t.getStringUnitWidth = function (t, r) {
return n(e.call(this, t, r));
}, i = function (t, e, n, r) {
for (var i = [], o = 0, s = t.length, a = 0; o !== s && a + e[o] < n;)
a += e[o], o++;
i.push(t.slice(0, o));
var c = o;
for (a = 0; o !== s;)
a + e[o] > r && (i.push(t.slice(c, o)), a = 0, c = o), a += e[o], o++;
return c !== o && i.push(t.slice(c, o)), i;
}, o = function (t, o, s) {
s || (s = {});
var a, c, u, l, h, d, f = [], p = [f], m = s.textIndent || 0, g = 0, w = 0, y = t.split(' '), v = e(' ', s)[0];
if (d = -1 === s.lineIndent ? y[0].length + 2 : s.lineIndent || 0) {
var b = Array(d).join(' '), x = [];
y.map(function (t) {
t = t.split(/\s*\n/), t.length > 1 ? x = x.concat(t.map(function (t, e) {
return (e && t.length ? '\n' : '') + t;
})) : x.push(t[0]);
}), y = x, d = r(b, s);
}
for (u = 0, l = y.length; l > u; u++) {
var k = 0;
if (a = y[u], d && '\n' == a[0] && (a = a.substr(1), k = 1), c = e(a, s), w = n(c), m + g + w > o || k) {
if (w > o) {
for (h = i(a, c, o - (m + g), o), f.push(h.shift()), f = [h.pop()]; h.length;)
p.push([h.shift()]);
w = n(c.slice(a.length - f[0].length));
} else
f = [a];
p.push(f), m = w + d, g = v;
} else
f.push(a), m += g + w, g = v;
}
if (d)
var A = function (t, e) {
return (e ? b : '') + t.join(' ');
};
else
var A = function (t) {
return t.join(' ');
};
return p.map(A);
};
t.splitTextToSize = function (t, e, n) {
n || (n = {});
var r, i = n.fontSize || this.internal.getFontSize(), s = function (t) {
var e = { 0: 1 }, n = {};
if (t.widths && t.kerning)
return {
widths: t.widths,
kerning: t.kerning
};
var r = this.internal.getFont(t.fontName, t.fontStyle), i = 'Unicode';
return r.metadata[i] ? {
widths: r.metadata[i].widths || e,
kerning: r.metadata[i].kerning || n
} : {
widths: e,
kerning: n
};
}.call(this, n);
r = Array.isArray(t) ? t : t.split(/\r?\n/);
var a = 1 * this.internal.scaleFactor * e / i;
s.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i : 0, s.lineIndent = n.lineIndent;
var c, u, l = [];
for (c = 0, u = r.length; u > c; c++)
l = l.concat(o(r[c], a, s));
return l;
};
}(jsPDF.API), function (t) {
'use strict';
var e = function (t) {
for (var e = '0123456789abcdef', n = 'klmnopqrstuvwxyz', r = {}, i = 0; i < n.length; i++)
r[n[i]] = e[i];
var o, s, a, c, u, l = {}, h = 1, d = l, f = [], p = '', m = '', g = t.length - 1;
for (i = 1; i != g;)
u = t[i], i += 1, '\'' == u ? s ? (c = s.join(''), s = o) : s = [] : s ? s.push(u) : '{' == u ? (f.push([
d,
c
]), d = {}, c = o) : '}' == u ? (a = f.pop(), a[0][a[1]] = d, c = o, d = a[0]) : '-' == u ? h = -1 : c === o ? r.hasOwnProperty(u) ? (p += r[u], c = parseInt(p, 16) * h, h = 1, p = '') : p += u : r.hasOwnProperty(u) ? (m += r[u], d[c] = parseInt(m, 16) * h, h = 1, c = o, m = '') : m += u;
return l;
}, n = {
codePages: ['WinAnsiEncoding'],
WinAnsiEncoding: e('{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}')
}, r = {
Unicode: {
Courier: n,
'Courier-Bold': n,
'Courier-BoldOblique': n,
'Courier-Oblique': n,
Helvetica: n,
'Helvetica-Bold': n,
'Helvetica-BoldOblique': n,
'Helvetica-Oblique': n,
'Times-Roman': n,
'Times-Bold': n,
'Times-BoldItalic': n,
'Times-Italic': n
}
}, i = {
Unicode: {
'Courier-Oblique': e('{\'widths\'{k3w\'fof\'6o}\'kerning\'{\'fof\'-6o}}'),
'Times-BoldItalic': e('{\'widths\'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t\'fof\'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}\'kerning\'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}\'fof\'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}'),
'Helvetica-Bold': e('{\'widths\'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u\'fof\'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}\'kerning\'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}\'fof\'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}'),
Courier: e('{\'widths\'{k3w\'fof\'6o}\'kerning\'{\'fof\'-6o}}'),
'Courier-BoldOblique': e('{\'widths\'{k3w\'fof\'6o}\'kerning\'{\'fof\'-6o}}'),
'Times-Bold': e('{\'widths\'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t\'fof\'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}\'kerning\'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}\'fof\'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}'),
Helvetica: e('{\'widths\'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u\'fof\'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}\'kerning\'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}\'fof\'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}'),
'Helvetica-BoldOblique': e('{\'widths\'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u\'fof\'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}\'kerning\'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}\'fof\'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}'),
'Courier-Bold': e('{\'widths\'{k3w\'fof\'6o}\'kerning\'{\'fof\'-6o}}'),
'Times-Italic': e('{\'widths\'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n\'fof\'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}\'kerning\'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}\'fof\'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}'),
'Times-Roman': e('{\'widths\'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s\'fof\'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}\'kerning\'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}\'fof\'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}'),
'Helvetica-Oblique': e('{\'widths\'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u\'fof\'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}\'kerning\'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}\'fof\'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}')
}
};
t.events.push([
'addFont',
function (t) {
var e, n, o, s = 'Unicode';
e = i[s][t.PostScriptName], e && (n = t.metadata[s] ? t.metadata[s] : t.metadata[s] = {}, n.widths = e.widths, n.kerning = e.kerning), o = r[s][t.PostScriptName], o && (n = t.metadata[s] ? t.metadata[s] : t.metadata[s] = {}, n.encoding = o, o.codePages && o.codePages.length && (t.encoding = o.codePages[0]));
}
]);
}(jsPDF.API), function (t) {
'use strict';
t.addSVG = function (t, e, n, r, i) {
function o(t, e) {
var n = e.createElement('style');
n.type = 'text/css', n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(e.createTextNode(t)), e.getElementsByTagName('head')[0].appendChild(n);
}
function s(t) {
var e = 'childframe', n = t.createElement('iframe');
return o('.jsPDF_sillysvg_iframe {display:none;position:absolute;}', t), n.name = e, n.setAttribute('width', 0), n.setAttribute('height', 0), n.setAttribute('frameborder', '0'), n.setAttribute('scrolling', 'no'), n.setAttribute('seamless', 'seamless'), n.setAttribute('class', 'jsPDF_sillysvg_iframe'), t.body.appendChild(n), n;
}
function a(t, e) {
var n = (e.contentWindow || e.contentDocument).document;
return n.write(t), n.close(), n.getElementsByTagName('svg')[0];
}
function c(t) {
for (var e = parseFloat(t[1]), n = parseFloat(t[2]), r = [], i = 3, o = t.length; o > i;)
'c' === t[i] ? (r.push([
parseFloat(t[i + 1]),
parseFloat(t[i + 2]),
parseFloat(t[i + 3]),
parseFloat(t[i + 4]),
parseFloat(t[i + 5]),
parseFloat(t[i + 6])
]), i += 7) : 'l' === t[i] ? (r.push([
parseFloat(t[i + 1]),
parseFloat(t[i + 2])
]), i += 3) : i += 1;
return [
e,
n,
r
];
}
var u;
if (e === u || n === u)
throw new Error('addSVG needs values for \'x\' and \'y\'');
var l = s(document), h = a(t, l), d = [
1,
1
], f = parseFloat(h.getAttribute('width')), p = parseFloat(h.getAttribute('height'));
f && p && (r && i ? d = [
r / f,
i / p
] : r ? d = [
r / f,
r / f
] : i && (d = [
i / p,
i / p
]));
var m, g, w, y, v = h.childNodes;
for (m = 0, g = v.length; g > m; m++)
w = v[m], w.tagName && 'PATH' === w.tagName.toUpperCase() && (y = c(w.getAttribute('d').split(' ')), y[0] = y[0] * d[0] + e, y[1] = y[1] * d[1] + n, this.lines.call(this, y[2], y[0], y[1], d));
return this;
};
}(jsPDF.API), function (t) {
'use strict';
t.putTotalPages = function (t) {
for (var e = new RegExp(t, 'g'), n = 1; n <= this.internal.getNumberOfPages(); n++)
for (var r = 0; r < this.internal.pages[n].length; r++)
this.internal.pages[n][r] = this.internal.pages[n][r].replace(e, this.internal.getNumberOfPages());
return this;
};
}(jsPDF.API), function (t) {
'use strict';
if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL)
try {
return void new Blob();
} catch (e) {
}
var n = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || function (t) {
var e = function (t) {
return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1];
}, n = function () {
this.data = [];
}, r = function (t, e, n) {
this.data = t, this.size = t.length, this.type = e, this.encoding = n;
}, i = n.prototype, o = r.prototype, s = t.FileReaderSync, a = function (t) {
this.code = this[this.name = t];
}, c = 'NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR'.split(' '), u = c.length, l = t.URL || t.webkitURL || t, h = l.createObjectURL, d = l.revokeObjectURL, f = l, p = t.btoa, m = t.atob, g = t.ArrayBuffer, w = t.Uint8Array, y = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
for (r.fake = o.fake = !0; u--;)
a.prototype[c[u]] = u + 1;
return l.createObjectURL || (f = t.URL = function (t) {
var e, n = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
return n.href = t, 'origin' in n || ('data:' === n.protocol.toLowerCase() ? n.origin = null : (e = t.match(y), n.origin = e && e[1])), n;
}), f.createObjectURL = function (t) {
var e, n = t.type;
return null === n && (n = 'application/octet-stream'), t instanceof r ? (e = 'data:' + n, 'base64' === t.encoding ? e + ';base64,' + t.data : 'URI' === t.encoding ? e + ',' + decodeURIComponent(t.data) : p ? e + ';base64,' + p(t.data) : e + ',' + encodeURIComponent(t.data)) : h ? h.call(l, t) : void 0;
}, f.revokeObjectURL = function (t) {
'data:' !== t.substring(0, 5) && d && d.call(l, t);
}, i.append = function (t) {
var n = this.data;
if (w && (t instanceof g || t instanceof w)) {
for (var i = '', o = new w(t), c = 0, u = o.length; u > c; c++)
i += String.fromCharCode(o[c]);
n.push(i);
} else if ('Blob' === e(t) || 'File' === e(t)) {
if (!s)
throw new a('NOT_READABLE_ERR');
var l = new s();
n.push(l.readAsBinaryString(t));
} else
t instanceof r ? 'base64' === t.encoding && m ? n.push(m(t.data)) : 'URI' === t.encoding ? n.push(decodeURIComponent(t.data)) : 'raw' === t.encoding && n.push(t.data) : ('string' != typeof t && (t += ''), n.push(unescape(encodeURIComponent(t))));
}, i.getBlob = function (t) {
return arguments.length || (t = null), new r(this.data.join(''), t, 'raw');
}, i.toString = function () {
return '[object BlobBuilder]';
}, o.slice = function (t, e, n) {
var i = arguments.length;
return 3 > i && (n = null), new r(this.data.slice(t, i > 1 ? e : this.data.length), n, this.encoding);
}, o.toString = function () {
return '[object Blob]';
}, o.close = function () {
this.size = 0, delete this.data;
}, n;
}(t);
t.Blob = function (t, e) {
var r = e ? e.type || '' : '', i = new n();
if (t)
for (var o = 0, s = t.length; s > o; o++)
Uint8Array && t[o] instanceof Uint8Array ? i.append(t[o].buffer) : i.append(t[o]);
var a = i.getBlob(r);
return !a.slice && a.webkitSlice && (a.slice = a.webkitSlice), a;
};
var r = Object.getPrototypeOf || function (t) {
return t.__proto__;
};
t.Blob.prototype = r(new t.Blob());
}('undefined' != typeof self && self || 'undefined' != typeof window && window || this.content || this);
var saveAs = saveAs || function (t) {
'use strict';
if ('undefined' == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
var e = t.document, n = function () {
return t.URL || t.webkitURL || t;
}, r = e.createElementNS('http://www.w3.org/1999/xhtml', 'a'), i = 'download' in r, o = function (t) {
var e = new MouseEvent('click');
t.dispatchEvent(e);
}, s = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent), a = t.webkitRequestFileSystem, c = t.requestFileSystem || a || t.mozRequestFileSystem, u = function (e) {
(t.setImmediate || t.setTimeout)(function () {
throw e;
}, 0);
}, l = 'application/octet-stream', h = 0, d = 500, f = function (e) {
var r = function () {
'string' == typeof e ? n().revokeObjectURL(e) : e.remove();
};
t.chrome ? r() : setTimeout(r, d);
}, p = function (t, e, n) {
e = [].concat(e);
for (var r = e.length; r--;) {
var i = t['on' + e[r]];
if ('function' == typeof i)
try {
i.call(t, n || t);
} catch (o) {
u(o);
}
}
}, m = function (t) {
return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([
'\uFEFF',
t
], { type: t.type }) : t;
}, g = function (e, u, d) {
d || (e = m(e));
var g, w, y, v = this, b = e.type, x = !1, k = function () {
p(v, 'writestart progress write writeend'.split(' '));
}, A = function () {
if (w && s && 'undefined' != typeof FileReader) {
var r = new FileReader();
return r.onloadend = function () {
var t = r.result;
w.location.href = 'data:attachment/file' + t.slice(t.search(/[,;]/)), v.readyState = v.DONE, k();
}, r.readAsDataURL(e), void (v.readyState = v.INIT);
}
if (!x && g || (g = n().createObjectURL(e)), w)
w.location.href = g;
else {
var i = t.open(g, '_blank');
void 0 == i && s && (t.location.href = g);
}
v.readyState = v.DONE, k(), f(g);
}, C = function (t) {
return function () {
return v.readyState !== v.DONE ? t.apply(this, arguments) : void 0;
};
}, E = {
create: !0,
exclusive: !1
};
return v.readyState = v.INIT, u || (u = 'download'), i ? (g = n().createObjectURL(e), void setTimeout(function () {
r.href = g, r.download = u, o(r), k(), f(g), v.readyState = v.DONE;
})) : (t.chrome && b && b !== l && (y = e.slice || e.webkitSlice, e = y.call(e, 0, e.size, l), x = !0), a && 'download' !== u && (u += '.download'), (b === l || a) && (w = t), c ? (h += e.size, void c(t.TEMPORARY, h, C(function (t) {
t.root.getDirectory('saved', E, C(function (t) {
var n = function () {
t.getFile(u, E, C(function (t) {
t.createWriter(C(function (n) {
n.onwriteend = function (e) {
w.location.href = t.toURL(), v.readyState = v.DONE, p(v, 'writeend', e), f(t);
}, n.onerror = function () {
var t = n.error;
t.code !== t.ABORT_ERR && A();
}, 'writestart progress write abort'.split(' ').forEach(function (t) {
n['on' + t] = v['on' + t];
}), n.write(e), v.abort = function () {
n.abort(), v.readyState = v.DONE;
}, v.readyState = v.WRITING;
}), A);
}), A);
};
t.getFile(u, { create: !1 }, C(function (t) {
t.remove(), n();
}), C(function (t) {
t.code === t.NOT_FOUND_ERR ? n() : A();
}));
}), A);
}), A)) : void A());
}, w = g.prototype, y = function (t, e, n) {
return new g(t, e, n);
};
return 'undefined' != typeof navigator && navigator.msSaveOrOpenBlob ? function (t, e, n) {
return n || (t = m(t)), navigator.msSaveOrOpenBlob(t, e || 'download');
} : (w.abort = function () {
var t = this;
t.readyState = t.DONE, p(t, 'abort');
}, w.readyState = w.INIT = 0, w.WRITING = 1, w.DONE = 2, w.error = w.onwritestart = w.onprogress = w.onwrite = w.onabort = w.onerror = w.onwriteend = null, y);
}
}('undefined' != typeof self && self || 'undefined' != typeof window && window || this.content);
'undefined' != typeof module && module.exports && (module.exports.saveAs = saveAs), void function (t, e) {
'object' == typeof module ? module.exports = e() : t.adler32cs = e();
}(jsPDF, function () {
var t = 'function' == typeof ArrayBuffer && 'function' == typeof Uint8Array, e = null, n = function () {
if (!t)
return function () {
return !1;
};
try {
var n = require('buffer');
'function' == typeof n.Buffer && (e = n.Buffer);
} catch (r) {
}
return function (t) {
return t instanceof ArrayBuffer || null !== e && t instanceof e;
};
}(), r = function () {
return null !== e ? function (t) {
return new e(t, 'utf8').toString('binary');
} : function (t) {
return unescape(encodeURIComponent(t));
};
}(), i = 65521, o = function (t, e) {
for (var n = 65535 & t, r = t >>> 16, o = 0, s = e.length; s > o; o++)
n = (n + (255 & e.charCodeAt(o))) % i, r = (r + n) % i;
return (r << 16 | n) >>> 0;
}, s = function (t, e) {
for (var n = 65535 & t, r = t >>> 16, o = 0, s = e.length; s > o; o++)
n = (n + e[o]) % i, r = (r + n) % i;
return (r << 16 | n) >>> 0;
}, a = {}, c = a.Adler32 = function () {
var e = function (t) {
if (!(this instanceof e))
throw new TypeError('Constructor cannot called be as a function.');
if (!isFinite(t = null == t ? 1 : +t))
throw new Error('First arguments needs to be a finite number.');
this.checksum = t >>> 0;
}, i = e.prototype = {};
return i.constructor = e, e.from = function (t) {
return t.prototype = i, t;
}(function (t) {
if (!(this instanceof e))
throw new TypeError('Constructor cannot called be as a function.');
if (null == t)
throw new Error('First argument needs to be a string.');
this.checksum = o(1, t.toString());
}), e.fromUtf8 = function (t) {
return t.prototype = i, t;
}(function (t) {
if (!(this instanceof e))
throw new TypeError('Constructor cannot called be as a function.');
if (null == t)
throw new Error('First argument needs to be a string.');
var n = r(t.toString());
this.checksum = o(1, n);
}), t && (e.fromBuffer = function (t) {
return t.prototype = i, t;
}(function (t) {
if (!(this instanceof e))
throw new TypeError('Constructor cannot called be as a function.');
if (!n(t))
throw new Error('First argument needs to be ArrayBuffer.');
var r = new Uint8Array(t);
return this.checksum = s(1, r);
})), i.update = function (t) {
if (null == t)
throw new Error('First argument needs to be a string.');
return t = t.toString(), this.checksum = o(this.checksum, t);
}, i.updateUtf8 = function (t) {
if (null == t)
throw new Error('First argument needs to be a string.');
var e = r(t.toString());
return this.checksum = o(this.checksum, e);
}, t && (i.updateBuffer = function (t) {
if (!n(t))
throw new Error('First argument needs to be ArrayBuffer.');
var e = new Uint8Array(t);
return this.checksum = s(this.checksum, e);
}), i.clone = function () {
return new c(this.checksum);
}, e;
}();
return a.from = function (t) {
if (null == t)
throw new Error('First argument needs to be a string.');
return o(1, t.toString());
}, a.fromUtf8 = function (t) {
if (null == t)
throw new Error('First argument needs to be a string.');
var e = r(t.toString());
return o(1, e);
}, t && (a.fromBuffer = function (t) {
if (!n(t))
throw new Error('First argument need to be ArrayBuffer.');
var e = new Uint8Array(t);
return s(1, e);
}), a;
});
var CssColors = {};
CssColors._colorsTable = {
aliceblue: '#f0f8ff',
antiquewhite: '#faebd7',
aqua: '#00ffff',
aquamarine: '#7fffd4',
azure: '#f0ffff',
beige: '#f5f5dc',
bisque: '#ffe4c4',
black: '#000000',
blanchedalmond: '#ffebcd',
blue: '#0000ff',
blueviolet: '#8a2be2',
brown: '#a52a2a',
burlywood: '#deb887',
cadetblue: '#5f9ea0',
chartreuse: '#7fff00',
chocolate: '#d2691e',
coral: '#ff7f50',
cornflowerblue: '#6495ed',
cornsilk: '#fff8dc',
crimson: '#dc143c',
cyan: '#00ffff',
darkblue: '#00008b',
darkcyan: '#008b8b',
darkgoldenrod: '#b8860b',
darkgray: '#a9a9a9',
darkgreen: '#006400',
darkkhaki: '#bdb76b',
darkmagenta: '#8b008b',
darkolivegreen: '#556b2f',
darkorange: '#ff8c00',
darkorchid: '#9932cc',
darkred: '#8b0000',
darksalmon: '#e9967a',
darkseagreen: '#8fbc8f',
darkslateblue: '#483d8b',
darkslategray: '#2f4f4f',
darkturquoise: '#00ced1',
darkviolet: '#9400d3',
deeppink: '#ff1493',
deepskyblue: '#00bfff',
dimgray: '#696969',
dodgerblue: '#1e90ff',
firebrick: '#b22222',
floralwhite: '#fffaf0',
forestgreen: '#228b22',
fuchsia: '#ff00ff',
gainsboro: '#dcdcdc',
ghostwhite: '#f8f8ff',
gold: '#ffd700',
goldenrod: '#daa520',
gray: '#808080',
green: '#008000',
greenyellow: '#adff2f',
honeydew: '#f0fff0',
hotpink: '#ff69b4',
'indianred ': '#cd5c5c',
indigo: '#4b0082',
ivory: '#fffff0',
khaki: '#f0e68c',
lavender: '#e6e6fa',
lavenderblush: '#fff0f5',
lawngreen: '#7cfc00',
lemonchiffon: '#fffacd',
lightblue: '#add8e6',
lightcoral: '#f08080',
lightcyan: '#e0ffff',
lightgoldenrodyellow: '#fafad2',
lightgrey: '#d3d3d3',
lightgreen: '#90ee90',
lightpink: '#ffb6c1',
lightsalmon: '#ffa07a',
lightseagreen: '#20b2aa',
lightskyblue: '#87cefa',
lightslategray: '#778899',
lightsteelblue: '#b0c4de',
lightyellow: '#ffffe0',
lime: '#00ff00',
limegreen: '#32cd32',
linen: '#faf0e6',
magenta: '#ff00ff',
maroon: '#800000',
mediumaquamarine: '#66cdaa',
mediumblue: '#0000cd',
mediumorchid: '#ba55d3',
mediumpurple: '#9370d8',
mediumseagreen: '#3cb371',
mediumslateblue: '#7b68ee',
mediumspringgreen: '#00fa9a',
mediumturquoise: '#48d1cc',
mediumvioletred: '#c71585',
midnightblue: '#191970',
mintcream: '#f5fffa',
mistyrose: '#ffe4e1',
moccasin: '#ffe4b5',
navajowhite: '#ffdead',
navy: '#000080',
oldlace: '#fdf5e6',
olive: '#808000',
olivedrab: '#6b8e23',
orange: '#ffa500',
orangered: '#ff4500',
orchid: '#da70d6',
palegoldenrod: '#eee8aa',
palegreen: '#98fb98',
paleturquoise: '#afeeee',
palevioletred: '#d87093',
papayawhip: '#ffefd5',
peachpuff: '#ffdab9',
peru: '#cd853f',
pink: '#ffc0cb',
plum: '#dda0dd',
powderblue: '#b0e0e6',
purple: '#800080',
red: '#ff0000',
rosybrown: '#bc8f8f',
royalblue: '#4169e1',
saddlebrown: '#8b4513',
salmon: '#fa8072',
sandybrown: '#f4a460',
seagreen: '#2e8b57',
seashell: '#fff5ee',
sienna: '#a0522d',
silver: '#c0c0c0',
skyblue: '#87ceeb',
slateblue: '#6a5acd',
slategray: '#708090',
snow: '#fffafa',
springgreen: '#00ff7f',
steelblue: '#4682b4',
tan: '#d2b48c',
teal: '#008080',
thistle: '#d8bfd8',
tomato: '#ff6347',
turquoise: '#40e0d0',
violet: '#ee82ee',
wheat: '#f5deb3',
white: '#ffffff',
whitesmoke: '#f5f5f5',
yellow: '#ffff00',
yellowgreen: '#9acd32'
}, CssColors.colorNameToHex = function (t) {
return t = t.toLowerCase(), 'undefined' != typeof this._colorsTable[t] ? this._colorsTable[t] : !1;
};
var Deflater = function (t) {
function e() {
function t(t) {
var e, n, i, o, s, c, u = r.dyn_tree, l = r.stat_desc.static_tree, h = r.stat_desc.extra_bits, d = r.stat_desc.extra_base, p = r.stat_desc.max_length, m = 0;
for (o = 0; a >= o; o++)
t.bl_count[o] = 0;
for (u[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; f > e; e++)
n = t.heap[e], o = u[2 * u[2 * n + 1] + 1] + 1, o > p && (o = p, m++), u[2 * n + 1] = o, n > r.max_code || (t.bl_count[o]++, s = 0, n >= d && (s = h[n - d]), c = u[2 * n], t.opt_len += c * (o + s), l && (t.static_len += c * (l[2 * n + 1] + s)));
if (0 !== m) {
do {
for (o = p - 1; 0 === t.bl_count[o];)
o--;
t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, m -= 2;
} while (m > 0);
for (o = p; 0 !== o; o--)
for (n = t.bl_count[o]; 0 !== n;)
i = t.heap[--e], i > r.max_code || (u[2 * i + 1] != o && (t.opt_len += (o - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = o), n--);
}
}
function e(t, e) {
var n = 0;
do
n |= 1 & t, t >>>= 1, n <<= 1;
while (--e > 0);
return n >>> 1;
}
function n(t, n, r) {
var i, o, s, c = [], u = 0;
for (i = 1; a >= i; i++)
c[i] = u = u + r[i - 1] << 1;
for (o = 0; n >= o; o++)
s = t[2 * o + 1], 0 !== s && (t[2 * o] = e(c[s]++, s));
}
var r = this;
r.build_tree = function (e) {
var i, o, s, a = r.dyn_tree, c = r.stat_desc.static_tree, u = r.stat_desc.elems, l = -1;
for (e.heap_len = 0, e.heap_max = f, i = 0; u > i; i++)
0 !== a[2 * i] ? (e.heap[++e.heap_len] = l = i, e.depth[i] = 0) : a[2 * i + 1] = 0;
for (; e.heap_len < 2;)
s = e.heap[++e.heap_len] = 2 > l ? ++l : 0, a[2 * s] = 1, e.depth[s] = 0, e.opt_len--, c && (e.static_len -= c[2 * s + 1]);
for (r.max_code = l, i = Math.floor(e.heap_len / 2); i >= 1; i--)
e.pqdownheap(a, i);
s = u;
do
i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], e.pqdownheap(a, 1), o = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = o, a[2 * s] = a[2 * i] + a[2 * o], e.depth[s] = Math.max(e.depth[i], e.depth[o]) + 1, a[2 * i + 1] = a[2 * o + 1] = s, e.heap[1] = s++, e.pqdownheap(a, 1);
while (e.heap_len >= 2);
e.heap[--e.heap_max] = e.heap[1], t(e), n(a, r.max_code, e.bl_count);
};
}
function n(t, e, n, r, i) {
var o = this;
o.static_tree = t, o.extra_bits = e, o.extra_base = n, o.elems = r, o.max_length = i;
}
function r(t, e, n, r, i) {
var o = this;
o.good_length = t, o.max_lazy = e, o.nice_length = n, o.max_chain = r, o.func = i;
}
function i(t, e, n, r) {
var i = t[2 * e], o = t[2 * n];
return o > i || i == o && r[e] <= r[n];
}
function o() {
function t() {
var t;
for (_t = 2 * St, qt[Rt - 1] = 0, t = 0; Rt - 1 > t; t++)
qt[t] = 0;
Yt = M[Gt].max_lazy, Jt = M[Gt].good_length, Kt = M[Gt].nice_length, Xt = M[Gt].max_chain, Ut = 0, jt = 0, Wt = 0, Lt = Vt = tt - 1, zt = 0, Ot = 0;
}
function r() {
var t;
for (t = 0; d > t; t++)
$t[2 * t] = 0;
for (t = 0; c > t; t++)
Zt[2 * t] = 0;
for (t = 0; u > t; t++)
te[2 * t] = 0;
$t[2 * p] = 1, ee.opt_len = ee.static_len = 0, ae = ue = 0;
}
function o() {
ne.dyn_tree = $t, ne.stat_desc = n.static_l_desc, re.dyn_tree = Zt, re.stat_desc = n.static_d_desc, ie.dyn_tree = te, ie.stat_desc = n.static_bl_desc, he = 0, de = 0, le = 8, r();
}
function s(t, e) {
var n, r, i = -1, o = t[1], s = 0, a = 7, c = 4;
for (0 === o && (a = 138, c = 3), t[2 * (e + 1) + 1] = 65535, n = 0; e >= n; n++)
r = o, o = t[2 * (n + 1) + 1], ++s < a && r == o || (c > s ? te[2 * r] += s : 0 !== r ? (r != i && te[2 * r]++, te[2 * g]++) : 10 >= s ? te[2 * w]++ : te[2 * y]++, s = 0, i = r, 0 === o ? (a = 138, c = 3) : r == o ? (a = 6, c = 3) : (a = 7, c = 4));
}
function a() {
var t;
for (s($t, ne.max_code), s(Zt, re.max_code), ie.build_tree(ee), t = u - 1; t >= 3 && 0 === te[2 * e.bl_order[t] + 1]; t--);
return ee.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}
function l(t) {
ee.pending_buf[ee.pending++] = t;
}
function f(t) {
l(255 & t), l(t >>> 8 & 255);
}
function m(t) {
l(t >> 8 & 255), l(255 & t & 255);
}
function R(t, e) {
var n, r = e;
de > v - r ? (n = t, he |= n << de & 65535, f(he), he = n >>> v - de, de += r - v) : (he |= t << de & 65535, de += r);
}
function rt(t, e) {
var n = 2 * t;
R(65535 & e[n], 65535 & e[n + 1]);
}
function it(t, e) {
var n, r, i = -1, o = t[1], s = 0, a = 7, c = 4;
for (0 === o && (a = 138, c = 3), n = 0; e >= n; n++)
if (r = o, o = t[2 * (n + 1) + 1], !(++s < a && r == o)) {
if (c > s) {
do
rt(r, te);
while (0 !== --s);
} else
0 !== r ? (r != i && (rt(r, te), s--), rt(g, te), R(s - 3, 2)) : 10 >= s ? (rt(w, te), R(s - 3, 3)) : (rt(y, te), R(s - 11, 7));
s = 0, i = r, 0 === o ? (a = 138, c = 3) : r == o ? (a = 6, c = 3) : (a = 7, c = 4);
}
}
function ot(t, n, r) {
var i;
for (R(t - 257, 5), R(n - 1, 5), R(r - 4, 4), i = 0; r > i; i++)
R(te[2 * e.bl_order[i] + 1], 3);
it($t, t - 1), it(Zt, n - 1);
}
function st() {
16 == de ? (f(he), he = 0, de = 0) : de >= 8 && (l(255 & he), he >>>= 8, de -= 8);
}
function at() {
R($ << 1, 3), rt(p, n.static_ltree), st(), 9 > 1 + le + 10 - de && (R($ << 1, 3), rt(p, n.static_ltree), st()), le = 7;
}
function ct(t, n) {
var r, i, o;
if (ee.pending_buf[ce + 2 * ae] = t >>> 8 & 255, ee.pending_buf[ce + 2 * ae + 1] = 255 & t, ee.pending_buf[oe + ae] = 255 & n, ae++, 0 === t ? $t[2 * n]++ : (ue++, t--, $t[2 * (e._length_code[n] + h + 1)]++, Zt[2 * e.d_code(t)]++), 0 === (8191 & ae) && Gt > 2) {
for (r = 8 * ae, i = Ut - jt, o = 0; c > o; o++)
r += Zt[2 * o] * (5 + e.extra_dbits[o]);
if (r >>>= 3, ue < Math.floor(ae / 2) && r < Math.floor(i / 2))
return !0;
}
return ae == se - 1;
}
function ut(t, n) {
var r, i, o, s, a = 0;
if (0 !== ae)
do
r = ee.pending_buf[ce + 2 * a] << 8 & 65280 | 255 & ee.pending_buf[ce + 2 * a + 1], i = 255 & ee.pending_buf[oe + a], a++, 0 === r ? rt(i, t) : (o = e._length_code[i], rt(o + h + 1, t), s = e.extra_lbits[o], 0 !== s && (i -= e.base_length[o], R(i, s)), r--, o = e.d_code(r), rt(o, n), s = e.extra_dbits[o], 0 !== s && (r -= e.base_dist[o], R(r, s)));
while (ae > a);
rt(p, t), le = t[2 * p + 1];
}
function lt() {
de > 8 ? f(he) : de > 0 && l(255 & he), he = 0, de = 0;
}
function ht(t, e, n) {
lt(), le = 8, n && (f(e), f(~e)), ee.pending_buf.set(Pt.subarray(t, t + e), ee.pending), ee.pending += e;
}
function dt(t, e, n) {
R((K << 1) + (n ? 1 : 0), 3), ht(t, e, !0);
}
function ft(t, e, i) {
var o, s, c = 0;
Gt > 0 ? (ne.build_tree(ee), re.build_tree(ee), c = a(), o = ee.opt_len + 3 + 7 >>> 3, s = ee.static_len + 3 + 7 >>> 3, o >= s && (o = s)) : o = s = e + 5, o >= e + 4 && -1 != t ? dt(t, e, i) : s == o ? (R(($ << 1) + (i ? 1 : 0), 3), ut(n.static_ltree, n.static_dtree)) : (R((Z << 1) + (i ? 1 : 0), 3), ot(ne.max_code + 1, re.max_code + 1, c + 1), ut($t, Zt)), r(), i && lt();
}
function pt(t) {
ft(jt >= 0 ? jt : -1, Ut - jt, t), jt = Ut, xt.flush_pending();
}
function mt() {
var t, e, n, r;
do {
if (r = _t - Wt - Ut, 0 === r && 0 === Ut && 0 === Wt)
r = St;
else if (-1 == r)
r--;
else if (Ut >= St + St - nt) {
Pt.set(Pt.subarray(St, St + St), 0), Ht -= St, Ut -= St, jt -= St, t = Rt, n = t;
do
e = 65535 & qt[--n], qt[n] = e >= St ? e - St : 0;
while (0 !== --t);
t = St, n = t;
do
e = 65535 & It[--n], It[n] = e >= St ? e - St : 0;
while (0 !== --t);
r += St;
}
if (0 === xt.avail_in)
return;
t = xt.read_buf(Pt, Ut + Wt, r), Wt += t, Wt >= tt && (Ot = 255 & Pt[Ut], Ot = (Ot << Nt ^ 255 & Pt[Ut + 1]) & Dt);
} while (nt > Wt && 0 !== xt.avail_in);
}
function gt(t) {
var e, n = 65535;
for (n > At - 5 && (n = At - 5);;) {
if (1 >= Wt) {
if (mt(), 0 === Wt && t == C)
return U;
if (0 === Wt)
break;
}
if (Ut += Wt, Wt = 0, e = jt + n, (0 === Ut || Ut >= e) && (Wt = Ut - e, Ut = e, pt(!1), 0 === xt.avail_out))
return U;
if (Ut - jt >= St - nt && (pt(!1), 0 === xt.avail_out))
return U;
}
return pt(t == F), 0 === xt.avail_out ? t == F ? W : U : t == F ? V : H;
}
function wt(t) {
var e, n, r = Xt, i = Ut, o = Vt, s = Ut > St - nt ? Ut - (St - nt) : 0, a = Kt, c = Tt, u = Ut + et, l = Pt[i + o - 1], h = Pt[i + o];
Vt >= Jt && (r >>= 2), a > Wt && (a = Wt);
do
if (e = t, Pt[e + o] == h && Pt[e + o - 1] == l && Pt[e] == Pt[i] && Pt[++e] == Pt[i + 1]) {
i += 2, e++;
do ;
while (Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && u > i);
if (n = et - (u - i), i = u - et, n > o) {
if (Ht = t, o = n, n >= a)
break;
l = Pt[i + o - 1], h = Pt[i + o];
}
}
while ((t = 65535 & It[t & c]) > s && 0 !== --r);
return Wt >= o ? o : Wt;
}
function yt(t) {
for (var e, n = 0;;) {
if (nt > Wt) {
if (mt(), nt > Wt && t == C)
return U;
if (0 === Wt)
break;
}
if (Wt >= tt && (Ot = (Ot << Nt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, n = 65535 & qt[Ot], It[Ut & Tt] = qt[Ot], qt[Ot] = Ut), 0 !== n && St - nt >= (Ut - n & 65535) && Qt != k && (Lt = wt(n)), Lt >= tt)
if (e = ct(Ut - Ht, Lt - tt), Wt -= Lt, Yt >= Lt && Wt >= tt) {
Lt--;
do
Ut++, Ot = (Ot << Nt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, n = 65535 & qt[Ot], It[Ut & Tt] = qt[Ot], qt[Ot] = Ut;
while (0 !== --Lt);
Ut++;
} else
Ut += Lt, Lt = 0, Ot = 255 & Pt[Ut], Ot = (Ot << Nt ^ 255 & Pt[Ut + 1]) & Dt;
else
e = ct(0, 255 & Pt[Ut]), Wt--, Ut++;
if (e && (pt(!1), 0 === xt.avail_out))
return U;
}
return pt(t == F), 0 === xt.avail_out ? t == F ? W : U : t == F ? V : H;
}
function vt(t) {
for (var e, n, r = 0;;) {
if (nt > Wt) {
if (mt(), nt > Wt && t == C)
return U;
if (0 === Wt)
break;
}
if (Wt >= tt && (Ot = (Ot << Nt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, r = 65535 & qt[Ot], It[Ut & Tt] = qt[Ot], qt[Ot] = Ut), Vt = Lt, Mt = Ht, Lt = tt - 1, 0 !== r && Yt > Vt && St - nt >= (Ut - r & 65535) && (Qt != k && (Lt = wt(r)), 5 >= Lt && (Qt == x || Lt == tt && Ut - Ht > 4096) && (Lt = tt - 1)), Vt >= tt && Vt >= Lt) {
n = Ut + Wt - tt, e = ct(Ut - 1 - Mt, Vt - tt), Wt -= Vt - 1, Vt -= 2;
do
++Ut <= n && (Ot = (Ot << Nt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, r = 65535 & qt[Ot], It[Ut & Tt] = qt[Ot], qt[Ot] = Ut);
while (0 !== --Vt);
if (zt = 0, Lt = tt - 1, Ut++, e && (pt(!1), 0 === xt.avail_out))
return U;
} else if (0 !== zt) {
if (e = ct(0, 255 & Pt[Ut - 1]), e && pt(!1), Ut++, Wt--, 0 === xt.avail_out)
return U;
} else
zt = 1, Ut++, Wt--;
}
return 0 !== zt && (e = ct(0, 255 & Pt[Ut - 1]), zt = 0), pt(t == F), 0 === xt.avail_out ? t == F ? W : U : t == F ? V : H;
}
function bt(e) {
return e.total_in = e.total_out = 0, e.msg = null, ee.pending = 0, ee.pending_out = 0, kt = G, Et = C, o(), t(), T;
}
var xt, kt, At, Ct, Et, St, Ft, Tt, Pt, _t, It, qt, Ot, Rt, Bt, Dt, Nt, jt, Lt, Mt, zt, Ut, Ht, Wt, Vt, Xt, Yt, Gt, Qt, Jt, Kt, $t, Zt, te, ee = this, ne = new e(), re = new e(), ie = new e();
ee.depth = [];
var oe, se, ae, ce, ue, le, he, de;
ee.bl_count = [], ee.heap = [], $t = [], Zt = [], te = [], ee.pqdownheap = function (t, e) {
for (var n = ee.heap, r = n[e], o = e << 1; o <= ee.heap_len && (o < ee.heap_len && i(t, n[o + 1], n[o], ee.depth) && o++, !i(t, r, n[o], ee.depth));)
n[e] = n[o], e = o, o <<= 1;
n[e] = r;
}, ee.deflateInit = function (t, e, n, r, i, o) {
return r || (r = J), i || (i = D), o || (o = A), t.msg = null, e == b && (e = 6), 1 > i || i > B || r != J || 9 > n || n > 15 || 0 > e || e > 9 || 0 > o || o > k ? I : (t.dstate = ee, Ft = n, St = 1 << Ft, Tt = St - 1, Bt = i + 7, Rt = 1 << Bt, Dt = Rt - 1, Nt = Math.floor((Bt + tt - 1) / tt), Pt = new Uint8Array(2 * St), It = [], qt = [], se = 1 << i + 6, ee.pending_buf = new Uint8Array(4 * se), At = 4 * se, ce = Math.floor(se / 2), oe = 3 * se, Gt = e, Qt = o, Ct = 255 & r, bt(t));
}, ee.deflateEnd = function () {
return kt != Y && kt != G && kt != Q ? I : (ee.pending_buf = null, qt = null, It = null, Pt = null, ee.dstate = null, kt == G ? q : T);
}, ee.deflateParams = function (t, e, n) {
var r = T;
return e == b && (e = 6), 0 > e || e > 9 || 0 > n || n > k ? I : (M[Gt].func != M[e].func && 0 !== t.total_in && (r = t.deflate(E)), Gt != e && (Gt = e, Yt = M[Gt].max_lazy, Jt = M[Gt].good_length, Kt = M[Gt].nice_length, Xt = M[Gt].max_chain), Qt = n, r);
}, ee.deflateSetDictionary = function (t, e, n) {
var r, i = n, o = 0;
if (!e || kt != Y)
return I;
if (tt > i)
return T;
for (i > St - nt && (i = St - nt, o = n - i), Pt.set(e.subarray(o, o + i), 0), Ut = i, jt = i, Ot = 255 & Pt[0], Ot = (Ot << Nt ^ 255 & Pt[1]) & Dt, r = 0; i - tt >= r; r++)
Ot = (Ot << Nt ^ 255 & Pt[r + (tt - 1)]) & Dt, It[r & Tt] = qt[Ot], qt[Ot] = r;
return T;
}, ee.deflate = function (t, e) {
var n, r, i, o, s;
if (e > F || 0 > e)
return I;
if (!t.next_out || !t.next_in && 0 !== t.avail_in || kt == Q && e != F)
return t.msg = z[_ - I], I;
if (0 === t.avail_out)
return t.msg = z[_ - O], O;
if (xt = t, o = Et, Et = e, kt == Y && (r = J + (Ft - 8 << 4) << 8, i = (Gt - 1 & 255) >> 1, i > 3 && (i = 3), r |= i << 6, 0 !== Ut && (r |= X), r += 31 - r % 31, kt = G, m(r)), 0 !== ee.pending) {
if (xt.flush_pending(), 0 === xt.avail_out)
return Et = -1, T;
} else if (0 === xt.avail_in && o >= e && e != F)
return xt.msg = z[_ - O], O;
if (kt == Q && 0 !== xt.avail_in)
return t.msg = z[_ - O], O;
if (0 !== xt.avail_in || 0 !== Wt || e != C && kt != Q) {
switch (s = -1, M[Gt].func) {
case N:
s = gt(e);
break;
case j:
s = yt(e);
break;
case L:
s = vt(e);
}
if (s != W && s != V || (kt = Q), s == U || s == W)
return 0 === xt.avail_out && (Et = -1), T;
if (s == H) {
if (e == E)
at();
else if (dt(0, 0, !1), e == S)
for (n = 0; Rt > n; n++)
qt[n] = 0;
if (xt.flush_pending(), 0 === xt.avail_out)
return Et = -1, T;
}
}
return e != F ? T : P;
};
}
function s() {
var t = this;
t.next_in_index = 0, t.next_out_index = 0, t.avail_in = 0, t.total_in = 0, t.avail_out = 0, t.total_out = 0;
}
var a = 15, c = 30, u = 19, l = 29, h = 256, d = h + 1 + l, f = 2 * d + 1, p = 256, m = 7, g = 16, w = 17, y = 18, v = 16, b = -1, x = 1, k = 2, A = 0, C = 0, E = 1, S = 3, F = 4, T = 0, P = 1, _ = 2, I = -2, q = -3, O = -5, R = [
0,
1,
2,
3,
4,
4,
5,
5,
6,
6,
6,
6,
7,
7,
7,
7,
8,
8,
8,
8,
8,
8,
8,
8,
9,
9,
9,
9,
9,
9,
9,
9,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
11,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
12,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
13,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
14,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
15,
0,
0,
16,
17,
18,
18,
19,
19,
20,
20,
20,
20,
21,
21,
21,
21,
22,
22,
22,
22,
22,
22,
22,
22,
23,
23,
23,
23,
23,
23,
23,
23,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
28,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29,
29
];
e._length_code = [
0,
1,
2,
3,
4,
5,
6,
7,
8,
8,
9,
9,
10,
10,
11,
11,
12,
12,
12,
12,
13,
13,
13,
13,
14,
14,
14,
14,
15,
15,
15,
15,
16,
16,
16,
16,
16,
16,
16,
16,
17,
17,
17,
17,
17,
17,
17,
17,
18,
18,
18,
18,
18,
18,
18,
18,
19,
19,
19,
19,
19,
19,
19,
19,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
20,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
21,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
22,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
23,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
24,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
25,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
26,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
27,
28
], e.base_length = [
0,
1,
2,
3,
4,
5,
6,
7,
8,
10,
12,
14,
16,
20,
24,
28,
32,
40,
48,
56,
64,
80,
96,
112,
128,
160,
192,
224,
0
], e.base_dist = [
0,
1,
2,
3,
4,
6,
8,
12,
16,
24,
32,
48,
64,
96,
128,
192,
256,
384,
512,
768,
1024,
1536,
2048,
3072,
4096,
6144,
8192,
12288,
16384,
24576
], e.d_code = function (t) {
return 256 > t ? R[t] : R[256 + (t >>> 7)];
}, e.extra_lbits = [
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
2,
2,
2,
2,
3,
3,
3,
3,
4,
4,
4,
4,
5,
5,
5,
5,
0
], e.extra_dbits = [
0,
0,
0,
0,
1,
1,
2,
2,
3,
3,
4,
4,
5,
5,
6,
6,
7,
7,
8,
8,
9,
9,
10,
10,
11,
11,
12,
12,
13,
13
], e.extra_blbits = [
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
3,
7
], e.bl_order = [
16,
17,
18,
0,
8,
7,
9,
6,
10,
5,
11,
4,
12,
3,
13,
2,
14,
1,
15
], n.static_ltree = [
12,
8,
140,
8,
76,
8,
204,
8,
44,
8,
172,
8,
108,
8,
236,
8,
28,
8,
156,
8,
92,
8,
220,
8,
60,
8,
188,
8,
124,
8,
252,
8,
2,
8,
130,
8,
66,
8,
194,
8,
34,
8,
162,
8,
98,
8,
226,
8,
18,
8,
146,
8,
82,
8,
210,
8,
50,
8,
178,
8,
114,
8,
242,
8,
10,
8,
138,
8,
74,
8,
202,
8,
42,
8,
170,
8,
106,
8,
234,
8,
26,
8,
154,
8,
90,
8,
218,
8,
58,
8,
186,
8,
122,
8,
250,
8,
6,
8,
134,
8,
70,
8,
198,
8,
38,
8,
166,
8,
102,
8,
230,
8,
22,
8,
150,
8,
86,
8,
214,
8,
54,
8,
182,
8,
118,
8,
246,
8,
14,
8,
142,
8,
78,
8,
206,
8,
46,
8,
174,
8,
110,
8,
238,
8,
30,
8,
158,
8,
94,
8,
222,
8,
62,
8,
190,
8,
126,
8,
254,
8,
1,
8,
129,
8,
65,
8,
193,
8,
33,
8,
161,
8,
97,
8,
225,
8,
17,
8,
145,
8,
81,
8,
209,
8,
49,
8,
177,
8,
113,
8,
241,
8,
9,
8,
137,
8,
73,
8,
201,
8,
41,
8,
169,
8,
105,
8,
233,
8,
25,
8,
153,
8,
89,
8,
217,
8,
57,
8,
185,
8,
121,
8,
249,
8,
5,
8,
133,
8,
69,
8,
197,
8,
37,
8,
165,
8,
101,
8,
229,
8,
21,
8,
149,
8,
85,
8,
213,
8,
53,
8,
181,
8,
117,
8,
245,
8,
13,
8,
141,
8,
77,
8,
205,
8,
45,
8,
173,
8,
109,
8,
237,
8,
29,
8,
157,
8,
93,
8,
221,
8,
61,
8,
189,
8,
125,
8,
253,
8,
19,
9,
275,
9,
147,
9,
403,
9,
83,
9,
339,
9,
211,
9,
467,
9,
51,
9,
307,
9,
179,
9,
435,
9,
115,
9,
371,
9,
243,
9,
499,
9,
11,
9,
267,
9,
139,
9,
395,
9,
75,
9,
331,
9,
203,
9,
459,
9,
43,
9,
299,
9,
171,
9,
427,
9,
107,
9,
363,
9,
235,
9,
491,
9,
27,
9,
283,
9,
155,
9,
411,
9,
91,
9,
347,
9,
219,
9,
475,
9,
59,
9,
315,
9,
187,
9,
443,
9,
123,
9,
379,
9,
251,
9,
507,
9,
7,
9,
263,
9,
135,
9,
391,
9,
71,
9,
327,
9,
199,
9,
455,
9,
39,
9,
295,
9,
167,
9,
423,
9,
103,
9,
359,
9,
231,
9,
487,
9,
23,
9,
279,
9,
151,
9,
407,
9,
87,
9,
343,
9,
215,
9,
471,
9,
55,
9,
311,
9,
183,
9,
439,
9,
119,
9,
375,
9,
247,
9,
503,
9,
15,
9,
271,
9,
143,
9,
399,
9,
79,
9,
335,
9,
207,
9,
463,
9,
47,
9,
303,
9,
175,
9,
431,
9,
111,
9,
367,
9,
239,
9,
495,
9,
31,
9,
287,
9,
159,
9,
415,
9,
95,
9,
351,
9,
223,
9,
479,
9,
63,
9,
319,
9,
191,
9,
447,
9,
127,
9,
383,
9,
255,
9,
511,
9,
0,
7,
64,
7,
32,
7,
96,
7,
16,
7,
80,
7,
48,
7,
112,
7,
8,
7,
72,
7,
40,
7,
104,
7,
24,
7,
88,
7,
56,
7,
120,
7,
4,
7,
68,
7,
36,
7,
100,
7,
20,
7,
84,
7,
52,
7,
116,
7,
3,
8,
131,
8,
67,
8,
195,
8,
35,
8,
163,
8,
99,
8,
227,
8
], n.static_dtree = [
0,
5,
16,
5,
8,
5,
24,
5,
4,
5,
20,
5,
12,
5,
28,
5,
2,
5,
18,
5,
10,
5,
26,
5,
6,
5,
22,
5,
14,
5,
30,
5,
1,
5,
17,
5,
9,
5,
25,
5,
5,
5,
21,
5,
13,
5,
29,
5,
3,
5,
19,
5,
11,
5,
27,
5,
7,
5,
23,
5
], n.static_l_desc = new n(n.static_ltree, e.extra_lbits, h + 1, d, a), n.static_d_desc = new n(n.static_dtree, e.extra_dbits, 0, c, a), n.static_bl_desc = new n(null, e.extra_blbits, 0, u, m);
var B = 9, D = 8, N = 0, j = 1, L = 2, M = [
new r(0, 0, 0, 0, N),
new r(4, 4, 8, 4, j),
new r(4, 5, 16, 8, j),
new r(4, 6, 32, 32, j),
new r(4, 4, 16, 16, L),
new r(8, 16, 32, 32, L),
new r(8, 16, 128, 128, L),
new r(8, 32, 128, 256, L),
new r(32, 128, 258, 1024, L),
new r(32, 258, 258, 4096, L)
], z = [
'need dictionary',
'stream end',
'',
'',
'stream error',
'data error',
'',
'buffer error',
'',
''
], U = 0, H = 1, W = 2, V = 3, X = 32, Y = 42, G = 113, Q = 666, J = 8, K = 0, $ = 1, Z = 2, tt = 3, et = 258, nt = et + tt + 1;
return s.prototype = {
deflateInit: function (t, e) {
var n = this;
return n.dstate = new o(), e || (e = a), n.dstate.deflateInit(n, t, e);
},
deflate: function (t) {
var e = this;
return e.dstate ? e.dstate.deflate(e, t) : I;
},
deflateEnd: function () {
var t = this;
if (!t.dstate)
return I;
var e = t.dstate.deflateEnd();
return t.dstate = null, e;
},
deflateParams: function (t, e) {
var n = this;
return n.dstate ? n.dstate.deflateParams(n, t, e) : I;
},
deflateSetDictionary: function (t, e) {
var n = this;
return n.dstate ? n.dstate.deflateSetDictionary(n, t, e) : I;
},
read_buf: function (t, e, n) {
var r = this, i = r.avail_in;
return i > n && (i = n), 0 === i ? 0 : (r.avail_in -= i, t.set(r.next_in.subarray(r.next_in_index, r.next_in_index + i), e), r.next_in_index += i, r.total_in += i, i);
},
flush_pending: function () {
var t = this, e = t.dstate.pending;
e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0));
}
}, function (t) {
var e = this, n = new s(), r = 512, i = C, o = new Uint8Array(r);
'undefined' == typeof t && (t = b), n.deflateInit(t), n.next_out = o, e.append = function (t, e) {
var s, a, c = [], u = 0, l = 0, h = 0;
if (t.length) {
n.next_in_index = 0, n.next_in = t, n.avail_in = t.length;
do {
if (n.next_out_index = 0, n.avail_out = r, s = n.deflate(i), s != T)
throw 'deflating: ' + n.msg;
n.next_out_index && (n.next_out_index == r ? c.push(new Uint8Array(o)) : c.push(new Uint8Array(o.subarray(0, n.next_out_index)))), h += n.next_out_index, e && n.next_in_index > 0 && n.next_in_index != u && (e(n.next_in_index), u = n.next_in_index);
} while (n.avail_in > 0 || 0 === n.avail_out);
return a = new Uint8Array(h), c.forEach(function (t) {
a.set(t, l), l += t.length;
}), a;
}
}, e.flush = function () {
var t, e, i = [], s = 0, a = 0;
do {
if (n.next_out_index = 0, n.avail_out = r, t = n.deflate(F), t != P && t != T)
throw 'deflating: ' + n.msg;
r - n.avail_out > 0 && i.push(new Uint8Array(o.subarray(0, n.next_out_index))), a += n.next_out_index;
} while (n.avail_in > 0 || 0 === n.avail_out);
return n.deflateEnd(), e = new Uint8Array(a), i.forEach(function (t) {
e.set(t, s), s += t.length;
}), e;
};
};
}(this);
(function (t, e, n, r, i, o, s) {
function a(t, e, n, r) {
return p(t, t, n, r, e).then(function (i) {
I('Document cloned');
var o = '[' + Wt + '=\'true\']';
t.querySelector(o).removeAttribute(Wt);
var s = i.contentWindow, a = s.document.querySelector(o), u = 'function' == typeof e.onclone ? Promise.resolve(e.onclone(s.document)) : Promise.resolve(!0);
return u.then(function () {
return c(a, i, e, n, r);
});
});
}
function c(t, n, r, i, o) {
var s = n.contentWindow, a = new Rt(s.document), c = new P(r, a), f = L(t), p = 'view' === r.type ? i : h(s.document), m = 'view' === r.type ? o : d(s.document), g = new Ut(p, m, c, r, e), w = new z(t, g, a, c, r);
return w.ready.then(function () {
I('Finished rendering');
var e;
return e = 'view' === r.type ? l(g.canvas, {
width: g.canvas.width,
height: g.canvas.height,
top: 0,
left: 0,
x: 0,
y: 0
}) : t === s.document.body || t === s.document.documentElement || null != r.canvas ? g.canvas : l(g.canvas, {
width: null != r.width ? r.width : f.width,
height: null != r.height ? r.height : f.height,
top: f.top,
left: f.left,
x: s.pageXOffset,
y: s.pageYOffset
}), u(n, r), e;
});
}
function u(t, e) {
e.removeContainer && (t.parentNode.removeChild(t), I('Cleaned up container'));
}
function l(t, n) {
var r = e.createElement('canvas'), i = Math.min(t.width - 1, Math.max(0, n.left)), o = Math.min(t.width, Math.max(1, n.left + n.width)), s = Math.min(t.height - 1, Math.max(0, n.top)), a = Math.min(t.height, Math.max(1, n.top + n.height));
return r.width = n.width, r.height = n.height, I('Cropping canvas at:', 'left:', n.left, 'top:', n.top, 'width:', o - i, 'height:', a - s), I('Resulting crop with width', n.width, 'and height', n.height, ' with x', i, 'and y', s), r.getContext('2d').drawImage(t, i, s, o - i, a - s, n.x, n.y, o - i, a - s), r;
}
function h(t) {
return Math.max(Math.max(t.body.scrollWidth, t.documentElement.scrollWidth), Math.max(t.body.offsetWidth, t.documentElement.offsetWidth), Math.max(t.body.clientWidth, t.documentElement.clientWidth));
}
function d(t) {
return Math.max(Math.max(t.body.scrollHeight, t.documentElement.scrollHeight), Math.max(t.body.offsetHeight, t.documentElement.offsetHeight), Math.max(t.body.clientHeight, t.documentElement.clientHeight));
}
function f() {
return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
}
function p(t, e, n, r, i) {
y(t);
var o = t.documentElement.cloneNode(!0), s = e.createElement('iframe');
return s.className = 'html2canvas-container', s.style.visibility = 'hidden', s.style.position = 'fixed', s.style.left = '-10000px', s.style.top = '0px', s.style.border = '0', s.width = n, s.height = r, s.scrolling = 'no', e.body.appendChild(s), new Promise(function (e) {
var n = s.contentWindow.document;
s.contentWindow.onload = s.onload = function () {
var o = setInterval(function () {
n.body.childNodes.length > 0 && (v(t, n), clearInterval(o), 'view' === i.type && s.contentWindow.scrollTo(r, a), e(s));
}, 50);
};
var r = t.defaultView.pageXOffset, a = t.defaultView.pageYOffset;
n.open(), n.write('<!DOCTYPE html><html></html>'), m(t, r, a), n.replaceChild(i.javascriptEnabled === !0 ? n.adoptNode(o) : b(n.adoptNode(o)), n.documentElement), n.close();
});
}
function m(t, e, n) {
e === t.defaultView.pageXOffset && n === t.defaultView.pageYOffset || t.defaultView.scrollTo(e, n);
}
function g(e, n, r, i, o, s) {
return new Et(e, n, t.document).then(w(e)).then(function (t) {
return p(t, r, i, o, s);
});
}
function w(t) {
return function (n) {
var r, i = new DOMParser();
try {
r = i.parseFromString(n, 'text/html');
} catch (o) {
I('DOMParser not supported, falling back to createHTMLDocument'), r = e.implementation.createHTMLDocument('');
try {
r.open(), r.write(n), r.close();
} catch (s) {
I('createHTMLDocument write not supported, falling back to document.body.innerHTML'), r.body.innerHTML = n;
}
}
var a = r.querySelector('base');
if (!a || !a.href.host) {
var c = r.createElement('base');
c.href = t, r.head.insertBefore(c, r.head.firstChild);
}
return r;
};
}
function y(t) {
[].slice.call(t.querySelectorAll('canvas'), 0).forEach(function (t) {
t.setAttribute(Vt, 'canvas-' + Xt++);
});
}
function v(t, e) {
[].slice.call(t.querySelectorAll('[' + Vt + ']'), 0).forEach(function (t) {
try {
var n = e.querySelector('[' + Vt + '="' + t.getAttribute(Vt) + '"]');
n && (n.width = t.width, n.height = t.height, n.getContext('2d').putImageData(t.getContext('2d').getImageData(0, 0, t.width, t.height), 0, 0));
} catch (r) {
I('Unable to copy canvas content from', t, r);
}
t.removeAttribute(Vt);
});
}
function b(t) {
return [].slice.call(t.childNodes, 0).filter(x).forEach(function (e) {
'SCRIPT' === e.tagName ? t.removeChild(e) : b(e);
}), t;
}
function x(t) {
return t.nodeType === Node.ELEMENT_NODE;
}
function k(t) {
var n = e.createElement('a');
return n.href = t, n.href = n.href, n;
}
function A(t) {
if (this.src = t, I('DummyImageContainer for', t), !this.promise || !this.image) {
I('Initiating DummyImageContainer'), A.prototype.image = new Image();
var e = this.image;
A.prototype.promise = new Promise(function (t, n) {
e.onload = t, e.onerror = n, e.src = f(), e.complete === !0 && t(e);
});
}
}
function C(t, n) {
var r, i, o = e.createElement('div'), s = e.createElement('img'), a = e.createElement('span'), c = 'Hidden Text';
o.style.visibility = 'hidden', o.style.fontFamily = t, o.style.fontSize = n, o.style.margin = 0, o.style.padding = 0, e.body.appendChild(o), s.src = f(), s.width = 1, s.height = 1, s.style.margin = 0, s.style.padding = 0, s.style.verticalAlign = 'baseline', a.style.fontFamily = t, a.style.fontSize = n, a.style.margin = 0, a.style.padding = 0, a.appendChild(e.createTextNode(c)), o.appendChild(a), o.appendChild(s), r = s.offsetTop - a.offsetTop + 1, o.removeChild(a), o.appendChild(e.createTextNode(c)), o.style.lineHeight = 'normal', s.style.verticalAlign = 'super', i = s.offsetTop - o.offsetTop + 1, e.body.removeChild(o), this.baseline = r, this.lineWidth = 1, this.middle = i;
}
function E() {
this.data = {};
}
function S(t, e, n) {
this.image = null, this.src = t;
var r = this, i = L(t);
this.promise = (e ? new Promise(function (e) {
'about:blank' === t.contentWindow.document.URL || null == t.contentWindow.document.documentElement ? t.contentWindow.onload = t.onload = function () {
e(t);
} : e(t);
}) : this.proxyLoad(n.proxy, i, n)).then(function (t) {
return html2canvas(t.contentWindow.document.documentElement, {
type: 'view',
width: t.width,
height: t.height,
proxy: n.proxy,
javascriptEnabled: n.javascriptEnabled,
removeContainer: n.removeContainer,
allowTaint: n.allowTaint,
imageTimeout: n.imageTimeout / 2
});
}).then(function (t) {
return r.image = t;
});
}
function F(t) {
this.src = t.value, this.colorStops = [], this.type = null, this.x0 = 0.5, this.y0 = 0.5, this.x1 = 0.5, this.y1 = 0.5, this.promise = Promise.resolve(!0);
}
function T(t, e) {
this.src = t, this.image = new Image();
var n = this;
this.tainted = null, this.promise = new Promise(function (r, i) {
n.image.onload = r, n.image.onerror = i, e && (n.image.crossOrigin = 'anonymous'), n.image.src = t, n.image.complete === !0 && r(n.image);
});
}
function P(e, n) {
this.link = null, this.options = e, this.support = n, this.origin = this.getOrigin(t.location.href);
}
function _(t) {
F.apply(this, arguments), this.type = this.TYPES.LINEAR;
var e = null === t.args[0].match(this.stepRegExp);
e ? t.args[0].split(' ').reverse().forEach(function (t) {
switch (t) {
case 'left':
this.x0 = 0, this.x1 = 1;
break;
case 'top':
this.y0 = 0, this.y1 = 1;
break;
case 'right':
this.x0 = 1, this.x1 = 0;
break;
case 'bottom':
this.y0 = 1, this.y1 = 0;
break;
case 'to':
var e = this.y0, n = this.x0;
this.y0 = this.y1, this.x0 = this.x1, this.x1 = n, this.y1 = e;
}
}, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = t.args.slice(e ? 1 : 0).map(function (t) {
var e = t.match(this.stepRegExp);
return {
color: e[1],
stop: '%' === e[3] ? e[2] / 100 : null
};
}, this), null === this.colorStops[0].stop && (this.colorStops[0].stop = 0), null === this.colorStops[this.colorStops.length - 1].stop && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function (t, e) {
null === t.stop && this.colorStops.slice(e).some(function (n, r) {
return null !== n.stop ? (t.stop = (n.stop - this.colorStops[e - 1].stop) / (r + 1) + this.colorStops[e - 1].stop, !0) : !1;
}, this);
}, this);
}
function I() {
t.html2canvas.logging && t.console && t.console.log && Function.prototype.bind.call(t.console.log, t.console).apply(t.console, [
Date.now() - t.html2canvas.start + 'ms',
'html2canvas:'
].concat([].slice.call(arguments, 0)));
}
function q(t, e) {
this.node = t, this.parent = e, this.stack = null, this.bounds = null, this.borders = null, this.clip = [], this.backgroundClip = [], this.offsetBounds = null, this.visible = null, this.computedStyles = null, this.styles = {}, this.backgroundImages = null, this.transformData = null, this.transformMatrix = null, this.isPseudoElement = !1, this.opacity = null;
}
function O(t) {
var e = t.options[t.selectedIndex || 0];
return e ? e.text || '' : '';
}
function R(t) {
return t && 'matrix' === t[1] ? t[2].split(',').map(function (t) {
return parseFloat(t.trim());
}) : void 0;
}
function B(t) {
return -1 !== t.toString().indexOf('%');
}
function D(t) {
var e, n, r, i, o, s, a, c = ' \r\n\t', u = [], l = 0, h = 0, d = function () {
e && ('"' === n.substr(0, 1) && (n = n.substr(1, n.length - 2)), n && a.push(n), '-' === e.substr(0, 1) && (i = e.indexOf('-', 1) + 1) > 0 && (r = e.substr(0, i), e = e.substr(i)), u.push({
prefix: r,
method: e.toLowerCase(),
value: o,
args: a,
image: null
})), a = [], e = r = n = o = '';
};
return a = [], e = r = n = o = '', t.split('').forEach(function (t) {
if (!(0 === l && c.indexOf(t) > -1)) {
switch (t) {
case '"':
s ? s === t && (s = null) : s = t;
break;
case '(':
if (s)
break;
if (0 === l)
return l = 1, void (o += t);
h++;
break;
case ')':
if (s)
break;
if (1 === l) {
if (0 === h)
return l = 0, o += t, void d();
h--;
}
break;
case ',':
if (s)
break;
if (0 === l)
return void d();
if (1 === l && 0 === h && !e.match(/^url$/i))
return a.push(n), n = '', void (o += t);
}
o += t, 0 === l ? e += t : n += t;
}
}), d(), u;
}
function N(t) {
return t.replace('px', '');
}
function j(t) {
return parseFloat(t);
}
function L(t) {
if (t.getBoundingClientRect) {
var e = t.getBoundingClientRect(), n = null == t.offsetWidth ? e.width : t.offsetWidth;
return {
top: e.top,
bottom: e.bottom || e.top + e.height,
right: e.left + n,
left: e.left,
width: n,
height: null == t.offsetHeight ? e.height : t.offsetHeight
};
}
return {};
}
function M(t) {
var e = t.offsetParent ? M(t.offsetParent) : {
top: 0,
left: 0
};
return {
top: t.offsetTop + e.top,
bottom: t.offsetTop + t.offsetHeight + e.top,
right: t.offsetLeft + e.left + t.offsetWidth,
left: t.offsetLeft + e.left,
width: t.offsetWidth,
height: t.offsetHeight
};
}
function z(t, e, n, r, i) {
I('Starting NodeParser'), this.renderer = e, this.options = i, this.range = null, this.support = n, this.renderQueue = [], this.stack = new Ot(!0, 1, t.ownerDocument, null);
var o = new q(t, null);
if (t === t.ownerDocument.documentElement) {
var s = new q(this.renderer.isTransparent(o.css('backgroundColor')) ? t.ownerDocument.body : t.ownerDocument.documentElement, null);
e.rectangle(0, 0, e.width, e.height, s.css('backgroundColor'));
}
o.visibile = o.isElementVisible(), this.createPseudoHideStyles(t.ownerDocument), this.disableAnimations(t.ownerDocument), this.nodes = bt([o].concat(this.getChildren(o)).filter(function (t) {
return t.visible = t.isElementVisible();
}).map(this.getPseudoElements, this)), this.fontMetrics = new E(), I('Fetched nodes, total:', this.nodes.length), I('Calculate overflow clips'), this.calculateOverflowClips(), I('Start fetching images'), this.images = r.fetch(this.nodes.filter(ht)), this.ready = this.images.ready.then(gt(function () {
return I('Images loaded, starting parsing'), I('Creating stacking contexts'), this.createStackingContexts(), I('Sorting stacking contexts'), this.sortStackingContexts(this.stack), this.parse(this.stack), I('Render queue created with ' + this.renderQueue.length + ' items'), new Promise(gt(function (t) {
i.async ? 'function' == typeof i.async ? i.async.call(this, this.renderQueue, t) : this.renderQueue.length > 0 ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, t)) : t() : (this.renderQueue.forEach(this.paint, this), t());
}, this));
}, this));
}
function U(t) {
return t.parent && t.parent.clip.length;
}
function H(t) {
return t.replace(/(\-[a-z])/g, function (t) {
return t.toUpperCase().replace('-', '');
});
}
function W() {
}
function V(t, e, n, r) {
return t.map(function (i, o) {
if (i.width > 0) {
var s = e.left, a = e.top, c = e.width, u = e.height - t[2].width;
switch (o) {
case 0:
u = t[0].width, i.args = Q({
c1: [
s,
a
],
c2: [
s + c,
a
],
c3: [
s + c - t[1].width,
a + u
],
c4: [
s + t[3].width,
a + u
]
}, r[0], r[1], n.topLeftOuter, n.topLeftInner, n.topRightOuter, n.topRightInner);
break;
case 1:
s = e.left + e.width - t[1].width, c = t[1].width, i.args = Q({
c1: [
s + c,
a
],
c2: [
s + c,
a + u + t[2].width
],
c3: [
s,
a + u
],
c4: [
s,
a + t[0].width
]
}, r[1], r[2], n.topRightOuter, n.topRightInner, n.bottomRightOuter, n.bottomRightInner);
break;
case 2:
a = a + e.height - t[2].width, u = t[2].width, i.args = Q({
c1: [
s + c,
a + u
],
c2: [
s,
a + u
],
c3: [
s + t[3].width,
a
],
c4: [
s + c - t[3].width,
a
]
}, r[2], r[3], n.bottomRightOuter, n.bottomRightInner, n.bottomLeftOuter, n.bottomLeftInner);
break;
case 3:
c = t[3].width, i.args = Q({
c1: [
s,
a + u + t[2].width
],
c2: [
s,
a
],
c3: [
s + c,
a + t[0].width
],
c4: [
s + c,
a + u
]
}, r[3], r[0], n.bottomLeftOuter, n.bottomLeftInner, n.topLeftOuter, n.topLeftInner);
}
}
return i;
});
}
function X(t, e, n, r) {
var i = 4 * ((Math.sqrt(2) - 1) / 3), o = n * i, s = r * i, a = t + n, c = e + r;
return {
topLeft: G({
x: t,
y: c
}, {
x: t,
y: c - s
}, {
x: a - o,
y: e
}, {
x: a,
y: e
}),
topRight: G({
x: t,
y: e
}, {
x: t + o,
y: e
}, {
x: a,
y: c - s
}, {
x: a,
y: c
}),
bottomRight: G({
x: a,
y: e
}, {
x: a,
y: e + s
}, {
x: t + o,
y: c
}, {
x: t,
y: c
}),
bottomLeft: G({
x: a,
y: c
}, {
x: a - o,
y: c
}, {
x: t,
y: e + s
}, {
x: t,
y: e
})
};
}
function Y(t, e, n) {
var r = t.left, i = t.top, o = t.width, s = t.height, a = e[0][0], c = e[0][1], u = e[1][0], l = e[1][1], h = e[2][0], d = e[2][1], f = e[3][0], p = e[3][1], m = o - u, g = s - d, w = o - h, y = s - p;
return {
topLeftOuter: X(r, i, a, c).topLeft.subdivide(0.5),
topLeftInner: X(r + n[3].width, i + n[0].width, Math.max(0, a - n[3].width), Math.max(0, c - n[0].width)).topLeft.subdivide(0.5),
topRightOuter: X(r + m, i, u, l).topRight.subdivide(0.5),
topRightInner: X(r + Math.min(m, o + n[3].width), i + n[0].width, m > o + n[3].width ? 0 : u - n[3].width, l - n[0].width).topRight.subdivide(0.5),
bottomRightOuter: X(r + w, i + g, h, d).bottomRight.subdivide(0.5),
bottomRightInner: X(r + Math.min(w, o - n[3].width), i + Math.min(g, s + n[0].width), Math.max(0, h - n[1].width), d - n[2].width).bottomRight.subdivide(0.5),
bottomLeftOuter: X(r, i + y, f, p).bottomLeft.subdivide(0.5),
bottomLeftInner: X(r + n[3].width, i + y, Math.max(0, f - n[3].width), p - n[2].width).bottomLeft.subdivide(0.5)
};
}
function G(t, e, n, r) {
var i = function (t, e, n) {
return {
x: t.x + (e.x - t.x) * n,
y: t.y + (e.y - t.y) * n
};
};
return {
start: t,
startControl: e,
endControl: n,
end: r,
subdivide: function (o) {
var s = i(t, e, o), a = i(e, n, o), c = i(n, r, o), u = i(s, a, o), l = i(a, c, o), h = i(u, l, o);
return [
G(t, s, u, h),
G(h, l, c, r)
];
},
curveTo: function (t) {
t.push([
'bezierCurve',
e.x,
e.y,
n.x,
n.y,
r.x,
r.y
]);
},
curveToReversed: function (r) {
r.push([
'bezierCurve',
n.x,
n.y,
e.x,
e.y,
t.x,
t.y
]);
}
};
}
function Q(t, e, n, r, i, o, s) {
var a = [];
return e[0] > 0 || e[1] > 0 ? (a.push([
'line',
r[1].start.x,
r[1].start.y
]), r[1].curveTo(a)) : a.push([
'line',
t.c1[0],
t.c1[1]
]), n[0] > 0 || n[1] > 0 ? (a.push([
'line',
o[0].start.x,
o[0].start.y
]), o[0].curveTo(a), a.push([
'line',
s[0].end.x,
s[0].end.y
]), s[0].curveToReversed(a)) : (a.push([
'line',
t.c2[0],
t.c2[1]
]), a.push([
'line',
t.c3[0],
t.c3[1]
])), e[0] > 0 || e[1] > 0 ? (a.push([
'line',
i[1].end.x,
i[1].end.y
]), i[1].curveToReversed(a)) : a.push([
'line',
t.c4[0],
t.c4[1]
]), a;
}
function J(t, e, n, r, i, o, s) {
e[0] > 0 || e[1] > 0 ? (t.push([
'line',
r[0].start.x,
r[0].start.y
]), r[0].curveTo(t), r[1].curveTo(t)) : t.push([
'line',
o,
s
]), (n[0] > 0 || n[1] > 0) && t.push([
'line',
i[0].start.x,
i[0].start.y
]);
}
function K(t) {
return t.cssInt('zIndex') < 0;
}
function $(t) {
return t.cssInt('zIndex') > 0;
}
function Z(t) {
return 0 === t.cssInt('zIndex');
}
function tt(t) {
return -1 !== [
'inline',
'inline-block',
'inline-table'
].indexOf(t.css('display'));
}
function et(t) {
return t instanceof Ot;
}
function nt(t) {
return t.node.data.trim().length > 0;
}
function rt(t) {
return /^(normal|none|0px)$/.test(t.parent.css('letterSpacing'));
}
function it(t) {
return [
'TopLeft',
'TopRight',
'BottomRight',
'BottomLeft'
].map(function (e) {
var n = t.css('border' + e + 'Radius'), r = n.split(' ');
return r.length <= 1 && (r[1] = r[0]), r.map(wt);
});
}
function ot(t) {
return t.nodeType === Node.TEXT_NODE || t.nodeType === Node.ELEMENT_NODE;
}
function st(t) {
var e = t.css('position'), n = -1 !== [
'absolute',
'relative',
'fixed'
].indexOf(e) ? t.css('zIndex') : 'auto';
return 'auto' !== n;
}
function at(t) {
return 'static' !== t.css('position');
}
function ct(t) {
return 'none' !== t.css('float');
}
function ut(t) {
return -1 !== [
'inline-block',
'inline-table'
].indexOf(t.css('display'));
}
function lt(t) {
var e = this;
return function () {
return !t.apply(e, arguments);
};
}
function ht(t) {
return t.node.nodeType === Node.ELEMENT_NODE;
}
function dt(t) {
return t.isPseudoElement === !0;
}
function ft(t) {
return t.node.nodeType === Node.TEXT_NODE;
}
function pt(t) {
return function (e, n) {
return e.cssInt('zIndex') + t.indexOf(e) / t.length - (n.cssInt('zIndex') + t.indexOf(n) / t.length);
};
}
function mt(t) {
return t.getOpacity() < 1;
}
function gt(t, e) {
return function () {
return t.apply(e, arguments);
};
}
function wt(t) {
return parseInt(t, 10);
}
function yt(t) {
return t.width;
}
function vt(t) {
return t.node.nodeType !== Node.ELEMENT_NODE || -1 === [
'SCRIPT',
'HEAD',
'TITLE',
'OBJECT',
'BR',
'OPTION'
].indexOf(t.node.nodeName);
}
function bt(t) {
return [].concat.apply([], t);
}
function xt(t) {
var e = t.substr(0, 1);
return e === t.substr(t.length - 1) && e.match(/'|"/) ? t.substr(1, t.length - 2) : t;
}
function kt(e) {
for (var n, r = [], i = 0, o = !1; e.length;)
At(e[i]) === o ? (n = e.splice(0, i), n.length && r.push(t.html2canvas.punycode.ucs2.encode(n)), o = !o, i = 0) : i++, i >= e.length && (n = e.splice(0, i), n.length && r.push(t.html2canvas.punycode.ucs2.encode(n)));
return r;
}
function At(t) {
return -1 !== [
32,
13,
10,
9,
45
].indexOf(t);
}
function Ct(t) {
return /[^\u0000-\u00ff]/.test(t);
}
function Et(t, e, n) {
var r = Tt(Gt), i = Pt(e, t, r);
return Gt ? zt(i) : Ft(n, i, r).then(function (t) {
return Dt(t.content);
});
}
function St(t, e, n) {
var r = Tt(Qt), i = Pt(e, t, r);
return Qt ? Promise.resolve(i) : Ft(n, i, r).then(function (t) {
return 'data:' + t.type + ';base64,' + t.content;
});
}
function Ft(e, n, r) {
return new Promise(function (i, o) {
var s = e.createElement('script'), a = function () {
delete t.html2canvas.proxy[r], e.body.removeChild(s);
};
t.html2canvas.proxy[r] = function (t) {
a(), i(t);
}, s.src = n, s.onerror = function (t) {
a(), o(t);
}, e.body.appendChild(s);
});
}
function Tt(t) {
return t ? '' : 'html2canvas_' + Date.now() + '_' + ++Yt + '_' + Math.round(100000 * Math.random());
}
function Pt(t, e, n) {
return t + '?url=' + encodeURIComponent(e) + (n.length ? '&callback=html2canvas.proxy.' + n : '');
}
function _t(t, n) {
var r = (e.createElement('script'), e.createElement('a'));
r.href = t, t = r.href, this.src = t, this.image = new Image();
var i = this;
this.promise = new Promise(function (r, o) {
i.image.crossOrigin = 'Anonymous', i.image.onload = r, i.image.onerror = o, new St(t, n, e).then(function (t) {
i.image.src = t;
})['catch'](o);
});
}
function It(t, e, n) {
q.call(this, t, e), this.isPseudoElement = !0, this.before = ':before' === n;
}
function qt(t, e, n, r, i) {
this.width = t, this.height = e, this.images = n, this.options = r, this.document = i;
}
function Ot(t, e, n, r) {
q.call(this, n, r), this.ownStacking = t, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * e;
}
function Rt(t) {
this.rangeBounds = this.testRangeBounds(t), this.cors = this.testCORS(), this.svg = this.testSVG();
}
function Bt(t) {
this.src = t, this.image = null;
var e = this;
this.promise = this.hasFabric().then(function () {
return e.isInline(t) ? Promise.resolve(e.inlineFormatting(t)) : zt(t);
}).then(function (t) {
return new Promise(function (n) {
html2canvas.fabric.loadSVGFromString(t, e.createCanvas.call(e, n));
});
});
}
function Dt(t) {
var e, n, r, i, o, s, a, c, u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', l = t.length, h = '';
for (e = 0; l > e; e += 4)
n = u.indexOf(t[e]), r = u.indexOf(t[e + 1]), i = u.indexOf(t[e + 2]), o = u.indexOf(t[e + 3]), s = n << 2 | r >> 4, a = (15 & r) << 4 | i >> 2, c = (3 & i) << 6 | o, h += 64 === i ? String.fromCharCode(s) : 64 === o || -1 === o ? String.fromCharCode(s, a) : String.fromCharCode(s, a, c);
return h;
}
function Nt(t, e) {
this.src = t, this.image = null;
var n = this;
this.promise = e ? new Promise(function (e, r) {
n.image = new Image(), n.image.onload = e, n.image.onerror = r, n.image.src = 'data:image/svg+xml,' + new XMLSerializer().serializeToString(t), n.image.complete === !0 && e(n.image);
}) : this.hasFabric().then(function () {
return new Promise(function (e) {
html2canvas.fabric.parseSVGDocument(t, n.createCanvas.call(n, e));
});
});
}
function jt(t, e) {
q.call(this, t, e);
}
function Lt(t, e, n) {
return t.length > 0 ? e + n.toUpperCase() : void 0;
}
function Mt(t) {
F.apply(this, arguments), this.type = 'linear' === t.args[0] ? this.TYPES.LINEAR : this.TYPES.RADIAL;
}
function zt(t) {
return new Promise(function (e, n) {
var r = new XMLHttpRequest();
r.open('GET', t), r.onload = function () {
200 === r.status ? e(r.responseText) : n(new Error(r.statusText));
}, r.onerror = function () {
n(new Error('Network Error'));
}, r.send();
});
}
function Ut(t, e) {
qt.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement('canvas'), this.options.canvas || (this.canvas.width = t, this.canvas.height = e), this.ctx = this.canvas.getContext('2d'), this.options.background && this.rectangle(0, 0, t, e, this.options.background), this.taintCtx = this.document.createElement('canvas').getContext('2d'), this.ctx.textBaseline = 'bottom', this.variables = {}, I('Initialized CanvasRenderer with size', t, 'x', e);
}
function Ht(t) {
return t.length > 0;
}
if (!function () {
var n, r, o, s;
!function () {
var t = {}, e = {};
n = function (e, n, r) {
t[e] = {
deps: n,
callback: r
};
}, s = o = r = function (n) {
function i(t) {
if ('.' !== t.charAt(0))
return t;
for (var e = t.split('/'), r = n.split('/').slice(0, -1), i = 0, o = e.length; o > i; i++) {
var s = e[i];
if ('..' === s)
r.pop();
else {
if ('.' === s)
continue;
r.push(s);
}
}
return r.join('/');
}
if (s._eak_seen = t, e[n])
return e[n];
if (e[n] = {}, !t[n])
throw new Error('Could not find module ' + n);
for (var o, a = t[n], c = a.deps, u = a.callback, l = [], h = 0, d = c.length; d > h; h++)
'exports' === c[h] ? l.push(o = {}) : l.push(r(i(c[h])));
var f = u.apply(this, l);
return e[n] = o || f;
};
}(), n('promise/all', [
'./utils',
'exports'
], function (t, e) {
'use strict';
function n(t) {
var e = this;
if (!r(t))
throw new TypeError('You must pass an array to all.');
return new e(function (e, n) {
function r(t) {
return function (e) {
o(t, e);
};
}
function o(t, n) {
a[t] = n, 0 === --c && e(a);
}
var s, a = [], c = t.length;
0 === c && e([]);
for (var u = 0; u < t.length; u++)
s = t[u], s && i(s.then) ? s.then(r(u), n) : o(u, s);
});
}
var r = t.isArray, i = t.isFunction;
e.all = n;
}), n('promise/asap', ['exports'], function (n) {
'use strict';
function r() {
return function () {
process.nextTick(a);
};
}
function o() {
var t = 0, n = new h(a), r = e.createTextNode('');
return n.observe(r, { characterData: !0 }), function () {
r.data = t = ++t % 2;
};
}
function s() {
return function () {
d.setTimeout(a, 1);
};
}
function a() {
for (var t = 0; t < f.length; t++) {
var e = f[t], n = e[0], r = e[1];
n(r);
}
f = [];
}
function c(t, e) {
var n = f.push([
t,
e
]);
1 === n && u();
}
var u, l = 'undefined' != typeof t ? t : {}, h = l.MutationObserver || l.WebKitMutationObserver, d = 'undefined' != typeof i ? i : this, f = [];
u = 'undefined' != typeof process && '[object process]' === {}.toString.call(process) ? r() : h ? o() : s(), n.asap = c;
}), n('promise/cast', ['exports'], function (t) {
'use strict';
function e(t) {
if (t && 'object' == typeof t && t.constructor === this)
return t;
var e = this;
return new e(function (e) {
e(t);
});
}
t.cast = e;
}), n('promise/config', ['exports'], function (t) {
'use strict';
function e(t, e) {
return 2 !== arguments.length ? n[t] : void (n[t] = e);
}
var n = { instrument: !1 };
t.config = n, t.configure = e;
}), n('promise/polyfill', [
'./promise',
'./utils',
'exports'
], function (e, n, r) {
'use strict';
function i() {
var e = 'Promise' in t && 'cast' in t.Promise && 'resolve' in t.Promise && 'reject' in t.Promise && 'all' in t.Promise && 'race' in t.Promise && function () {
var e;
return new t.Promise(function (t) {
e = t;
}), s(e);
}();
e || (t.Promise = o);
}
var o = e.Promise, s = n.isFunction;
r.polyfill = i;
}), n('promise/promise', [
'./config',
'./utils',
'./cast',
'./all',
'./race',
'./resolve',
'./reject',
'./asap',
'exports'
], function (t, e, n, r, i, o, s, a, c) {
'use strict';
function u(t) {
if (!k(t))
throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
if (!(this instanceof u))
throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
this._subscribers = [], l(t, this);
}
function l(t, e) {
function n(t) {
m(e, t);
}
function r(t) {
w(e, t);
}
try {
t(n, r);
} catch (i) {
r(i);
}
}
function h(t, e, n, r) {
var i, o, s, a, c = k(n);
if (c)
try {
i = n(r), s = !0;
} catch (u) {
a = !0, o = u;
}
else
i = r, s = !0;
p(e, i) || (c && s ? m(e, i) : a ? w(e, o) : t === I ? m(e, i) : t === q && w(e, i));
}
function d(t, e, n, r) {
var i = t._subscribers, o = i.length;
i[o] = e, i[o + I] = n, i[o + q] = r;
}
function f(t, e) {
for (var n, r, i = t._subscribers, o = t._detail, s = 0; s < i.length; s += 3)
n = i[s], r = i[s + e], h(e, n, r, o);
t._subscribers = null;
}
function p(t, e) {
var n, r = null;
try {
if (t === e)
throw new TypeError('A promises callback cannot return that same promise.');
if (x(e) && (r = e.then, k(r)))
return r.call(e, function (r) {
return n ? !0 : (n = !0, void (e !== r ? m(t, r) : g(t, r)));
}, function (e) {
return n ? !0 : (n = !0, void w(t, e));
}), !0;
} catch (i) {
return n ? !0 : (w(t, i), !0);
}
return !1;
}
function m(t, e) {
t === e ? g(t, e) : p(t, e) || g(t, e);
}
function g(t, e) {
t._state === P && (t._state = _, t._detail = e, b.async(y, t));
}
function w(t, e) {
t._state === P && (t._state = _, t._detail = e, b.async(v, t));
}
function y(t) {
f(t, t._state = I);
}
function v(t) {
f(t, t._state = q);
}
var b = t.config, x = (t.configure, e.objectOrFunction), k = e.isFunction, A = (e.now, n.cast), C = r.all, E = i.race, S = o.resolve, F = s.reject, T = a.asap;
b.async = T;
var P = void 0, _ = 0, I = 1, q = 2;
u.prototype = {
constructor: u,
_state: void 0,
_detail: void 0,
_subscribers: void 0,
then: function (t, e) {
var n = this, r = new this.constructor(function () {
});
if (this._state) {
var i = arguments;
b.async(function () {
h(n._state, r, i[n._state - 1], n._detail);
});
} else
d(this, r, t, e);
return r;
},
'catch': function (t) {
return this.then(null, t);
}
}, u.all = C, u.cast = A, u.race = E, u.resolve = S, u.reject = F, c.Promise = u;
}), n('promise/race', [
'./utils',
'exports'
], function (t, e) {
'use strict';
function n(t) {
var e = this;
if (!r(t))
throw new TypeError('You must pass an array to race.');
return new e(function (e, n) {
for (var r, i = 0; i < t.length; i++)
r = t[i], r && 'function' == typeof r.then ? r.then(e, n) : e(r);
});
}
var r = t.isArray;
e.race = n;
}), n('promise/reject', ['exports'], function (t) {
'use strict';
function e(t) {
var e = this;
return new e(function (e, n) {
n(t);
});
}
t.reject = e;
}), n('promise/resolve', ['exports'], function (t) {
'use strict';
function e(t) {
var e = this;
return new e(function (e) {
e(t);
});
}
t.resolve = e;
}), n('promise/utils', ['exports'], function (t) {
'use strict';
function e(t) {
return n(t) || 'object' == typeof t && null !== t;
}
function n(t) {
return 'function' == typeof t;
}
function r(t) {
return '[object Array]' === Object.prototype.toString.call(t);
}
var i = Date.now || function () {
return new Date().getTime();
};
t.objectOrFunction = e, t.isFunction = n, t.isArray = r, t.now = i;
}), r('promise/polyfill').polyfill();
}(), 'function' != typeof Object.create || 'function' != typeof e.createElement('canvas').getContext)
return void (t.html2canvas = function () {
return Promise.reject('No canvas support');
});
!function (t) {
function e(t) {
throw RangeError(R[t]);
}
function s(t, e) {
for (var n = t.length, r = []; n--;)
r[n] = e(t[n]);
return r;
}
function a(t, e) {
var n = t.split('@'), r = '';
n.length > 1 && (r = n[0] + '@', t = n[1]);
var i = t.split(O), o = s(i, e).join('.');
return r + o;
}
function c(t) {
for (var e, n, r = [], i = 0, o = t.length; o > i;)
e = t.charCodeAt(i++), e >= 55296 && 56319 >= e && o > i ? (n = t.charCodeAt(i++), 56320 == (64512 & n) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), i--)) : r.push(e);
return r;
}
function u(t) {
return s(t, function (t) {
var e = '';
return t > 65535 && (t -= 65536, e += N(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += N(t);
}).join('');
}
function l(t) {
return 10 > t - 48 ? t - 22 : 26 > t - 65 ? t - 65 : 26 > t - 97 ? t - 97 : A;
}
function h(t, e) {
return t + 22 + 75 * (26 > t) - ((0 != e) << 5);
}
function d(t, e, n) {
var r = 0;
for (t = n ? D(t / F) : t >> 1, t += D(t / e); t > B * E >> 1; r += A)
t = D(t / B);
return D(r + (B + 1) * t / (t + S));
}
function f(t) {
var n, r, i, o, s, a, c, h, f, p, m = [], g = t.length, w = 0, y = P, v = T;
for (r = t.lastIndexOf(_), 0 > r && (r = 0), i = 0; r > i; ++i)
t.charCodeAt(i) >= 128 && e('not-basic'), m.push(t.charCodeAt(i));
for (o = r > 0 ? r + 1 : 0; g > o;) {
for (s = w, a = 1, c = A; o >= g && e('invalid-input'), h = l(t.charCodeAt(o++)), (h >= A || h > D((k - w) / a)) && e('overflow'), w += h * a, f = v >= c ? C : c >= v + E ? E : c - v, !(f > h); c += A)
p = A - f, a > D(k / p) && e('overflow'), a *= p;
n = m.length + 1, v = d(w - s, n, 0 == s), D(w / n) > k - y && e('overflow'), y += D(w / n), w %= n, m.splice(w++, 0, y);
}
return u(m);
}
function p(t) {
var n, r, i, o, s, a, u, l, f, p, m, g, w, y, v, b = [];
for (t = c(t), g = t.length, n = P, r = 0, s = T, a = 0; g > a; ++a)
m = t[a], 128 > m && b.push(N(m));
for (i = o = b.length, o && b.push(_); g > i;) {
for (u = k, a = 0; g > a; ++a)
m = t[a], m >= n && u > m && (u = m);
for (w = i + 1, u - n > D((k - r) / w) && e('overflow'), r += (u - n) * w, n = u, a = 0; g > a; ++a)
if (m = t[a], n > m && ++r > k && e('overflow'), m == n) {
for (l = r, f = A; p = s >= f ? C : f >= s + E ? E : f - s, !(p > l); f += A)
v = l - p, y = A - p, b.push(N(h(p + v % y, 0))), l = D(v / y);
b.push(N(h(l, 0))), s = d(r, w, i == o), r = 0, ++i;
}
++r, ++n;
}
return b.join('');
}
function m(t) {
return a(t, function (t) {
return I.test(t) ? f(t.slice(4).toLowerCase()) : t;
});
}
function g(t) {
return a(t, function (t) {
return q.test(t) ? 'xn--' + p(t) : t;
});
}
var w = 'object' == typeof r && r && !r.nodeType && r, y = 'object' == typeof n && n && !n.nodeType && n, v = 'object' == typeof i && i;
v.global !== v && v.window !== v && v.self !== v || (t = v);
var b, x, k = 2147483647, A = 36, C = 1, E = 26, S = 38, F = 700, T = 72, P = 128, _ = '-', I = /^xn--/, q = /[^\x20-\x7E]/, O = /[\x2E\u3002\uFF0E\uFF61]/g, R = {
overflow: 'Overflow: input needs wider integers to process',
'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
'invalid-input': 'Invalid input'
}, B = A - C, D = Math.floor, N = String.fromCharCode;
if (b = {
version: '1.3.1',
ucs2: {
decode: c,
encode: u
},
decode: f,
encode: p,
toASCII: g,
toUnicode: m
}, 'function' == typeof o && 'object' == typeof o.amd && o.amd)
o('punycode', function () {
return b;
});
else if (w && y)
if (n.exports == w)
y.exports = b;
else
for (x in b)
b.hasOwnProperty(x) && (w[x] = b[x]);
else
t.punycode = b;
}(this);
var Wt = 'data-html2canvas-node', Vt = 'data-html2canvas-canvas-clone', Xt = 0;
t.html2canvas = function (n, r) {
if (r = r || {}, r.logging && (t.html2canvas.logging = !0, t.html2canvas.start = Date.now()), r.async = 'undefined' == typeof r.async ? !0 : r.async, r.allowTaint = 'undefined' == typeof r.allowTaint ? !1 : r.allowTaint, r.removeContainer = 'undefined' == typeof r.removeContainer ? !0 : r.removeContainer, r.javascriptEnabled = 'undefined' == typeof r.javascriptEnabled ? !1 : r.javascriptEnabled, r.imageTimeout = 'undefined' == typeof r.imageTimeout ? 10000 : r.imageTimeout, 'string' == typeof n)
return 'string' != typeof r.proxy ? Promise.reject('Proxy must be used when rendering url') : g(k(n), r.proxy, e, t.innerWidth, t.innerHeight, r).then(function (e) {
return c(e.contentWindow.document.documentElement, e, r, t.innerWidth, t.innerHeight);
});
var i = (n === s ? [e.documentElement] : n.length ? n : [n])[0];
return i.setAttribute(Wt, 'true'), a(i.ownerDocument, r, i.ownerDocument.defaultView.innerWidth, i.ownerDocument.defaultView.innerHeight).then(function (t) {
return 'function' == typeof r.onrendered && (I('options.onrendered is deprecated, html2canvas returns a Promise containing the canvas'), r.onrendered(t)), t;
});
}, t.html2canvas.punycode = this.punycode, t.html2canvas.proxy = {}, E.prototype.getMetrics = function (t, e) {
return this.data[t + '-' + e] === s && (this.data[t + '-' + e] = new C(t, e)), this.data[t + '-' + e];
}, S.prototype.proxyLoad = function (t, e, n) {
var r = this.src;
return g(r.src, t, r.ownerDocument, e.width, e.height, n);
}, F.prototype.TYPES = {
LINEAR: 1,
RADIAL: 2
}, P.prototype.findImages = function (t) {
var e = [];
return t.reduce(function (t, e) {
switch (e.node.nodeName) {
case 'IMG':
return t.concat([{
args: [e.node.src],
method: 'url'
}]);
case 'svg':
case 'IFRAME':
return t.concat([{
args: [e.node],
method: e.node.nodeName
}]);
}
return t;
}, []).forEach(this.addImage(e, this.loadImage), this), e;
}, P.prototype.findBackgroundImage = function (t, e) {
return e.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(t, this.loadImage), this), t;
}, P.prototype.addImage = function (t, e) {
return function (n) {
n.args.forEach(function (r) {
this.imageExists(t, r) || (t.splice(0, 0, e.call(this, n)), I('Added image #' + t.length, 'string' == typeof r ? r.substring(0, 100) : r));
}, this);
};
}, P.prototype.hasImageBackground = function (t) {
return 'none' !== t.method;
}, P.prototype.loadImage = function (t) {
if ('url' === t.method) {
var e = t.args[0];
return !this.isSVG(e) || this.support.svg || this.options.allowTaint ? e.match(/data:image\/.*;base64,/i) ? new T(e.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ''), !1) : this.isSameOrigin(e) || this.options.allowTaint === !0 || this.isSVG(e) ? new T(e, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new T(e, !0) : this.options.proxy ? new _t(e, this.options.proxy) : new A(e) : new Bt(e);
}
return 'linear-gradient' === t.method ? new _(t) : 'gradient' === t.method ? new Mt(t) : 'svg' === t.method ? new Nt(t.args[0], this.support.svg) : 'IFRAME' === t.method ? new S(t.args[0], this.isSameOrigin(t.args[0].src), this.options) : new A(t);
}, P.prototype.isSVG = function (t) {
return 'svg' === t.substring(t.length - 3).toLowerCase() || Bt.prototype.isInline(t);
}, P.prototype.imageExists = function (t, e) {
return t.some(function (t) {
return t.src === e;
});
}, P.prototype.isSameOrigin = function (t) {
return this.getOrigin(t) === this.origin;
}, P.prototype.getOrigin = function (t) {
var n = this.link || (this.link = e.createElement('a'));
return n.href = t, n.href = n.href, n.protocol + n.hostname + n.port;
}, P.prototype.getPromise = function (t) {
return this.timeout(t, this.options.imageTimeout)['catch'](function () {
var e = new A(t.src);
return e.promise.then(function (e) {
t.image = e;
});
});
}, P.prototype.get = function (t) {
var e = null;
return this.images.some(function (n) {
return (e = n).src === t;
}) ? e : null;
}, P.prototype.fetch = function (t) {
return this.images = t.reduce(gt(this.findBackgroundImage, this), this.findImages(t)), this.images.forEach(function (t, e) {
t.promise.then(function () {
I('Succesfully loaded image #' + (e + 1), t);
}, function (n) {
I('Failed loading image #' + (e + 1), t, n);
});
}), this.ready = Promise.all(this.images.map(this.getPromise, this)), I('Finished searching images'), this;
}, P.prototype.timeout = function (t, e) {
var n;
return Promise.race([
t.promise,
new Promise(function (r, i) {
n = setTimeout(function () {
I('Timed out loading image', t), i(t);
}, e);
})
]).then(function (t) {
return clearTimeout(n), t;
});
}, _.prototype = Object.create(F.prototype), _.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, q.prototype.cloneTo = function (t) {
t.visible = this.visible, t.borders = this.borders, t.bounds = this.bounds, t.clip = this.clip, t.backgroundClip = this.backgroundClip, t.computedStyles = this.computedStyles, t.styles = this.styles, t.backgroundImages = this.backgroundImages, t.opacity = this.opacity;
}, q.prototype.getOpacity = function () {
return null === this.opacity ? this.opacity = this.cssFloat('opacity') : this.opacity;
}, q.prototype.assignStack = function (t) {
this.stack = t, t.children.push(this);
}, q.prototype.isElementVisible = function () {
return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : 'none' !== this.css('display') && 'hidden' !== this.css('visibility') && !this.node.hasAttribute('data-html2canvas-ignore') && ('INPUT' !== this.node.nodeName || 'hidden' !== this.node.getAttribute('type'));
}, q.prototype.css = function (t) {
return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ':before' : ':after') : this.computedStyle(null)), this.styles[t] || (this.styles[t] = this.computedStyles[t]);
}, q.prototype.prefixedCss = function (t) {
var e = [
'webkit',
'moz',
'ms',
'o'
], n = this.css(t);
return n === s && e.some(function (e) {
return n = this.css(e + t.substr(0, 1).toUpperCase() + t.substr(1)), n !== s;
}, this), n === s ? null : n;
}, q.prototype.computedStyle = function (t) {
return this.node.ownerDocument.defaultView.getComputedStyle(this.node, t);
}, q.prototype.cssInt = function (t) {
var e = parseInt(this.css(t), 10);
return isNaN(e) ? 0 : e;
}, q.prototype.cssFloat = function (t) {
var e = parseFloat(this.css(t));
return isNaN(e) ? 0 : e;
}, q.prototype.fontWeight = function () {
var t = this.css('fontWeight');
switch (parseInt(t, 10)) {
case 401:
t = 'bold';
break;
case 400:
t = 'normal';
}
return t;
}, q.prototype.parseClip = function () {
var t = this.css('clip').match(this.CLIP);
return t ? {
top: parseInt(t[1], 10),
right: parseInt(t[2], 10),
bottom: parseInt(t[3], 10),
left: parseInt(t[4], 10)
} : null;
}, q.prototype.parseBackgroundImages = function () {
return this.backgroundImages || (this.backgroundImages = D(this.css('backgroundImage')));
}, q.prototype.cssList = function (t, e) {
var n = (this.css(t) || '').split(',');
return n = n[e || 0] || n[0] || 'auto', n = n.trim().split(' '), 1 === n.length && (n = [
n[0],
n[0]
]), n;
}, q.prototype.parseBackgroundSize = function (t, e, n) {
var r, i, o = this.cssList('backgroundSize', n);
if (B(o[0]))
r = t.width * parseFloat(o[0]) / 100;
else {
if (/contain|cover/.test(o[0])) {
var s = t.width / t.height, a = e.width / e.height;
return a > s ^ 'contain' === o[0] ? {
width: t.height * a,
height: t.height
} : {
width: t.width,
height: t.width / a
};
}
r = parseInt(o[0], 10);
}
return i = 'auto' === o[0] && 'auto' === o[1] ? e.height : 'auto' === o[1] ? r / e.width * e.height : B(o[1]) ? t.height * parseFloat(o[1]) / 100 : parseInt(o[1], 10), 'auto' === o[0] && (r = i / e.height * e.width), {
width: r,
height: i
};
}, q.prototype.parseBackgroundPosition = function (t, e, n, r) {
var i, o, s = this.cssList('backgroundPosition', n);
return i = B(s[0]) ? (t.width - (r || e).width) * (parseFloat(s[0]) / 100) : parseInt(s[0], 10), o = 'auto' === s[1] ? i / e.width * e.height : B(s[1]) ? (t.height - (r || e).height) * parseFloat(s[1]) / 100 : parseInt(s[1], 10), 'auto' === s[0] && (i = o / e.height * e.width), {
left: i,
top: o
};
}, q.prototype.parseBackgroundRepeat = function (t) {
return this.cssList('backgroundRepeat', t)[0];
}, q.prototype.parseTextShadows = function () {
var t = this.css('textShadow'), e = [];
if (t && 'none' !== t)
for (var n = t.match(this.TEXT_SHADOW_PROPERTY), r = 0; n && r < n.length; r++) {
var i = n[r].match(this.TEXT_SHADOW_VALUES);
e.push({
color: i[0],
offsetX: i[1] ? parseFloat(i[1].replace('px', '')) : 0,
offsetY: i[2] ? parseFloat(i[2].replace('px', '')) : 0,
blur: i[3] ? i[3].replace('px', '') : 0
});
}
return e;
}, q.prototype.parseTransform = function () {
if (!this.transformData)
if (this.hasTransform()) {
var t = this.parseBounds(), e = this.prefixedCss('transformOrigin').split(' ').map(N).map(j);
e[0] += t.left, e[1] += t.top, this.transformData = {
origin: e,
matrix: this.parseTransformMatrix()
};
} else
this.transformData = {
origin: [
0,
0
],
matrix: [
1,
0,
0,
1,
0,
0
]
};
return this.transformData;
}, q.prototype.parseTransformMatrix = function () {
if (!this.transformMatrix) {
var t = this.prefixedCss('transform'), e = t ? R(t.match(this.MATRIX_PROPERTY)) : null;
this.transformMatrix = e ? e : [
1,
0,
0,
1,
0,
0
];
}
return this.transformMatrix;
}, q.prototype.parseBounds = function () {
return this.bounds || (this.bounds = this.hasTransform() ? M(this.node) : L(this.node));
}, q.prototype.hasTransform = function () {
return '1,0,0,1,0,0' !== this.parseTransformMatrix().join(',') || this.parent && this.parent.hasTransform();
}, q.prototype.getValue = function () {
var t = this.node.value || '';
return t = 'SELECT' === this.node.tagName ? O(this.node) : t, 0 === t.length ? this.node.placeholder || '' : t;
}, q.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, q.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, q.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, q.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, z.prototype.calculateOverflowClips = function () {
this.nodes.forEach(function (t) {
if (ht(t)) {
dt(t) && t.appendToDOM(), t.borders = this.parseBorders(t);
var e = 'hidden' === t.css('overflow') ? [t.borders.clip] : [], n = t.parseClip();
n && -1 !== [
'absolute',
'fixed'
].indexOf(t.css('position')) && e.push([[
'rect',
t.bounds.left + n.left,
t.bounds.top + n.top,
n.right - n.left,
n.bottom - n.top
]]), t.clip = U(t) ? t.parent.clip.concat(e) : e, t.backgroundClip = 'hidden' !== t.css('overflow') ? t.clip.concat([t.borders.clip]) : t.clip, dt(t) && t.cleanDOM();
} else
ft(t) && (t.clip = U(t) ? t.parent.clip : []);
dt(t) || (t.bounds = null);
}, this);
}, z.prototype.asyncRenderer = function (t, e, n) {
n = n || Date.now(), this.paint(t[this.renderIndex++]), t.length === this.renderIndex ? e() : n + 20 > Date.now() ? this.asyncRenderer(t, e, n) : setTimeout(gt(function () {
this.asyncRenderer(t, e);
}, this), 0);
}, z.prototype.createPseudoHideStyles = function (t) {
this.createStyles(t, '.' + It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
}, z.prototype.disableAnimations = function (t) {
this.createStyles(t, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
}, z.prototype.createStyles = function (t, e) {
var n = t.createElement('style');
n.innerHTML = e, t.body.appendChild(n);
}, z.prototype.getPseudoElements = function (t) {
var e = [[t]];
if (t.node.nodeType === Node.ELEMENT_NODE) {
var n = this.getPseudoElement(t, ':before'), r = this.getPseudoElement(t, ':after');
n && e.push(n), r && e.push(r);
}
return bt(e);
}, z.prototype.getPseudoElement = function (t, n) {
var r = t.computedStyle(n);
if (!r || !r.content || 'none' === r.content || '-moz-alt-content' === r.content || 'none' === r.display)
return null;
for (var i = xt(r.content), o = 'url' === i.substr(0, 3), s = e.createElement(o ? 'img' : 'html2canvaspseudoelement'), a = new It(s, t, n), c = r.length - 1; c >= 0; c--) {
var u = H(r.item(c));
s.style[u] = r[u];
}
if (s.className = It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, o)
return s.src = D(i)[0].args[0], [a];
var l = e.createTextNode(i);
return s.appendChild(l), [
a,
new jt(l, a)
];
}, z.prototype.getChildren = function (t) {
return bt([].filter.call(t.node.childNodes, ot).map(function (e) {
var n = [e.nodeType === Node.TEXT_NODE ? new jt(e, t) : new q(e, t)].filter(vt);
return e.nodeType === Node.ELEMENT_NODE && n.length && 'TEXTAREA' !== e.tagName ? n[0].isElementVisible() ? n.concat(this.getChildren(n[0])) : [] : n;
}, this));
}, z.prototype.newStackingContext = function (t, e) {
var n = new Ot(e, t.getOpacity(), t.node, t.parent);
t.cloneTo(n);
var r = e ? n.getParentStack(this) : n.parent.stack;
r.contexts.push(n), t.stack = n;
}, z.prototype.createStackingContexts = function () {
this.nodes.forEach(function (t) {
ht(t) && (this.isRootElement(t) || mt(t) || st(t) || this.isBodyWithTransparentRoot(t) || t.hasTransform()) ? this.newStackingContext(t, !0) : ht(t) && (at(t) && Z(t) || ut(t) || ct(t)) ? this.newStackingContext(t, !1) : t.assignStack(t.parent.stack);
}, this);
}, z.prototype.isBodyWithTransparentRoot = function (t) {
return 'BODY' === t.node.nodeName && this.renderer.isTransparent(t.parent.css('backgroundColor'));
}, z.prototype.isRootElement = function (t) {
return null === t.parent;
}, z.prototype.sortStackingContexts = function (t) {
t.contexts.sort(pt(t.contexts.slice(0))), t.contexts.forEach(this.sortStackingContexts, this);
}, z.prototype.parseTextBounds = function (t) {
return function (e, n, r) {
if ('none' !== t.parent.css('textDecoration').substr(0, 4) || 0 !== e.trim().length) {
if (this.support.rangeBounds && !t.parent.hasTransform()) {
var i = r.slice(0, n).join('').length;
return this.getRangeBounds(t.node, i, e.length);
}
if (t.node && 'string' == typeof t.node.data) {
var o = t.node.splitText(e.length), s = this.getWrapperBounds(t.node, t.parent.hasTransform());
return t.node = o, s;
}
} else
this.support.rangeBounds && !t.parent.hasTransform() || (t.node = t.node.splitText(e.length));
return {};
};
}, z.prototype.getWrapperBounds = function (t, e) {
var n = t.ownerDocument.createElement('html2canvaswrapper'), r = t.parentNode, i = t.cloneNode(!0);
n.appendChild(t.cloneNode(!0)), r.replaceChild(n, t);
var o = e ? M(n) : L(n);
return r.replaceChild(i, n), o;
}, z.prototype.getRangeBounds = function (t, e, n) {
var r = this.range || (this.range = t.ownerDocument.createRange());
return r.setStart(t, e), r.setEnd(t, e + n), r.getBoundingClientRect();
}, z.prototype.parse = function (t) {
var e = t.contexts.filter(K), n = t.children.filter(ht), r = n.filter(lt(ct)), i = r.filter(lt(at)).filter(lt(tt)), o = n.filter(lt(at)).filter(ct), s = r.filter(lt(at)).filter(tt), a = t.contexts.concat(r.filter(at)).filter(Z), c = t.children.filter(ft).filter(nt), u = t.contexts.filter($);
e.concat(i).concat(o).concat(s).concat(a).concat(c).concat(u).forEach(function (t) {
this.renderQueue.push(t), et(t) && (this.parse(t), this.renderQueue.push(new W()));
}, this);
}, z.prototype.paint = function (t) {
try {
t instanceof W ? this.renderer.ctx.restore() : ft(t) ? (dt(t.parent) && t.parent.appendToDOM(), this.paintText(t), dt(t.parent) && t.parent.cleanDOM()) : this.paintNode(t);
} catch (e) {
I(e);
}
}, z.prototype.paintNode = function (t) {
if (et(t) && (this.renderer.setOpacity(t.opacity), this.renderer.ctx.save(), t.hasTransform() && this.renderer.setTransform(t.parseTransform())), 'INPUT' === t.node.nodeName && 'checkbox' === t.node.type)
this.paintCheckbox(t);
else if ('INPUT' === t.node.nodeName && 'radio' === t.node.type)
this.paintRadio(t);
else {
if ('always' === t.css('page-break-before')) {
var e = this.options.canvas.getContext('2d');
'function' == typeof e._pageBreakAt && e._pageBreakAt(t.node.offsetTop);
}
this.paintElement(t);
}
if (t.node.getAttribute) {
var n = t.node.getAttribute('name');
if (null === n)
var n = t.node.getAttribute('id');
if (null !== n) {
var r = this.options.canvas.annotations;
r && r.setName(n, t.bounds);
}
}
}, z.prototype.paintElement = function (t) {
var e = t.parseBounds();
this.renderer.clip(t.backgroundClip, function () {
this.renderer.renderBackground(t, e, t.borders.borders.map(yt));
}, this), this.renderer.clip(t.clip, function () {
this.renderer.renderBorders(t.borders.borders);
}, this), this.renderer.clip(t.backgroundClip, function () {
switch (t.node.nodeName) {
case 'svg':
case 'IFRAME':
var n = this.images.get(t.node);
n ? this.renderer.renderImage(t, e, t.borders, n) : I('Error loading <' + t.node.nodeName + '>', t.node);
break;
case 'IMG':
var r = this.images.get(t.node.src);
r ? this.renderer.renderImage(t, e, t.borders, r) : I('Error loading <img>', t.node.src);
break;
case 'CANVAS':
this.renderer.renderImage(t, e, t.borders, { image: t.node });
break;
case 'SELECT':
case 'INPUT':
case 'TEXTAREA':
this.paintFormValue(t);
}
}, this);
}, z.prototype.paintCheckbox = function (t) {
var e = t.parseBounds(), n = Math.min(e.width, e.height), r = {
width: n - 1,
height: n - 1,
top: e.top,
left: e.left
}, i = [
3,
3
], o = [
i,
i,
i,
i
], s = [
1,
1,
1,
1
].map(function (t) {
return {
color: '#A5A5A5',
width: t
};
}), a = Y(r, o, s);
this.renderer.clip(t.backgroundClip, function () {
this.renderer.rectangle(r.left + 1, r.top + 1, r.width - 2, r.height - 2, '#DEDEDE'), this.renderer.renderBorders(V(s, r, a, o)), t.node.checked && (this.renderer.font('#424242', 'normal', 'normal', 'bold', n - 3 + 'px', 'arial'), this.renderer.text('\u2714', r.left + n / 6, r.top + n - 1));
}, this);
}, z.prototype.paintRadio = function (t) {
var e = t.parseBounds(), n = Math.min(e.width, e.height) - 2;
this.renderer.clip(t.backgroundClip, function () {
this.renderer.circleStroke(e.left + 1, e.top + 1, n, '#DEDEDE', 1, '#A5A5A5'), t.node.checked && this.renderer.circle(Math.ceil(e.left + n / 4) + 1, Math.ceil(e.top + n / 4) + 1, Math.floor(n / 2), '#424242');
}, this);
}, z.prototype.paintFormValue = function (t) {
if (t.getValue().length > 0) {
var e = t.node.ownerDocument, n = e.createElement('html2canvaswrapper'), r = [
'lineHeight',
'textAlign',
'fontFamily',
'fontWeight',
'fontSize',
'color',
'paddingLeft',
'paddingTop',
'paddingRight',
'paddingBottom',
'width',
'height',
'borderLeftStyle',
'borderTopStyle',
'borderLeftWidth',
'borderTopWidth',
'boxSizing',
'whiteSpace',
'wordWrap'
];
r.forEach(function (e) {
try {
n.style[e] = t.css(e);
} catch (r) {
I('html2canvas: Parse: Exception caught in renderFormValue: ' + r.message);
}
});
var i = t.parseBounds();
n.style.position = 'fixed', n.style.left = i.left + 'px', n.style.top = i.top + 'px', n.textContent = t.getValue(), e.body.appendChild(n), this.paintText(new jt(n.firstChild, t)), e.body.removeChild(n);
}
}, z.prototype.paintText = function (e) {
e.applyTextTransform();
var n = t.html2canvas.punycode.ucs2.decode(e.node.data), r = this.options.letterRendering && !rt(e) || Ct(e.node.data) ? n.map(function (e) {
return t.html2canvas.punycode.ucs2.encode([e]);
}) : kt(n), i = e.parent.fontWeight(), o = e.parent.css('fontSize'), a = e.parent.css('fontFamily'), c = e.parent.parseTextShadows();
this.renderer.font(e.parent.css('color'), e.parent.css('fontStyle'), e.parent.css('fontVariant'), i, o, a), c.length ? this.renderer.fontShadow(c[0].color, c[0].offsetX, c[0].offsetY, c[0].blur) : this.renderer.clearShadow(), this.renderer.clip(e.parent.clip, function () {
r.map(this.parseTextBounds(e), this).forEach(function (t, n) {
t && (t.left === s && (t.left = 0), t.bottom === s && (t.bottom = 0), this.renderer.text(r[n], t.left, t.bottom), this.renderTextDecoration(e.parent, t, this.fontMetrics.getMetrics(a, o)), 0 == n && 'LI' === e.parent.node.nodeName && this.renderBullet(e, t), 0 == n && this.renderAnnotation(e.parent, t));
}, this);
}, this);
}, z.prototype.generateListNumber = {
listAlpha: function (t) {
var e, n = '';
do
e = t % 26, n = String.fromCharCode(e + 64) + n, t /= 26;
while (26 * t > 26);
return n;
},
listRoman: function (t) {
var e, n = [
'M',
'CM',
'D',
'CD',
'C',
'XC',
'L',
'XL',
'X',
'IX',
'V',
'IV',
'I'
], r = [
1000,
900,
500,
400,
100,
90,
50,
40,
10,
9,
5,
4,
1
], i = '', o = n.length;
if (0 >= t || t >= 4000)
return t;
for (e = 0; o > e; e += 1)
for (; t >= r[e];)
t -= r[e], i += n[e];
return i;
}
}, z.prototype.listItemText = function (t, e) {
switch (t) {
case 'decimal-leading-zero':
text = 1 === e.toString().length ? e = '0' + e.toString() : e.toString();
break;
case 'upper-roman':
text = this.generateListNumber.listRoman(e);
break;
case 'lower-roman':
text = this.generateListNumber.listRoman(e).toLowerCase();
break;
case 'lower-alpha':
text = this.generateListNumber.listAlpha(e).toLowerCase();
break;
case 'upper-alpha':
text = this.generateListNumber.listAlpha(e);
break;
case 'decimal':
default:
text = e;
}
return text;
}, z.prototype.renderBullet = function (t, e) {
var n = t.parent.css('listStyleType');
if ('none' !== n) {
var r = e.top + (e.bottom - e.top) / 2, i = this.renderer.canvas.getContext('2d'), o = i.measureText('M').width, s = o / 4, a = 0.75 * o, c = e.left - a;
switch (n) {
case 'decimal':
case 'decimal-leading-zero':
case 'upper-alpha':
case 'lower-alpha':
case 'upper-roman':
case 'lower-roman':
var u = t.parent, l = u.parent, h = Array.prototype.slice.call(l.node.children), d = h.indexOf(u.node) + 1, f = this.listItemText(n, d);
f += '.';
var p = e.left - a;
p -= i.measureText(f).width, i.fillText(f, p, e.bottom);
break;
case 'square':
var s = o / 3;
c -= s, r -= s / 2, i.fillRect(c, r, s, s);
break;
case 'circle':
var s = o / 6;
c -= s, i.beginPath(), i.arc(c, r, s, 0, 2 * Math.PI), i.closePath(), i.stroke();
break;
case 'disc':
default:
var s = o / 6;
c -= s, i.beginPath(), i.arc(c, r, s, 0, 2 * Math.PI), i.closePath(), i.fill();
}
}
}, z.prototype.renderTextDecoration = function (t, e, n) {
switch (t.css('textDecoration').split(' ')[0]) {
case 'underline':
this.renderer.rectangle(e.left, Math.round(e.top + n.baseline + n.lineWidth), e.width, 1, t.css('color'));
break;
case 'overline':
this.renderer.rectangle(e.left, Math.round(e.top), e.width, 1, t.css('color'));
break;
case 'line-through':
this.renderer.rectangle(e.left, Math.ceil(e.top + n.middle + n.lineWidth), e.width, 1, t.css('color'));
}
}, z.prototype.renderAnnotation = function (t, e) {
if ('A' === t.node.nodeName) {
var n = t.node.getAttribute('href');
if (n) {
var r = this.options.canvas.annotations;
r && r.createAnnotation(n, t.bounds);
}
}
}, z.prototype.parseBorders = function (t) {
var e = t.parseBounds(), n = it(t), r = [
'Top',
'Right',
'Bottom',
'Left'
].map(function (e) {
return {
width: t.cssInt('border' + e + 'Width'),
color: t.css('border' + e + 'Color'),
args: null
};
}), i = Y(e, n, r);
return {
clip: this.parseBackgroundClip(t, i, r, n, e),
borders: V(r, e, i, n)
};
}, z.prototype.parseBackgroundClip = function (t, e, n, r, i) {
var o = t.css('backgroundClip'), s = [];
switch (o) {
case 'content-box':
case 'padding-box':
J(s, r[0], r[1], e.topLeftInner, e.topRightInner, i.left + n[3].width, i.top + n[0].width), J(s, r[1], r[2], e.topRightInner, e.bottomRightInner, i.left + i.width - n[1].width, i.top + n[0].width), J(s, r[2], r[3], e.bottomRightInner, e.bottomLeftInner, i.left + i.width - n[1].width, i.top + i.height - n[2].width), J(s, r[3], r[0], e.bottomLeftInner, e.topLeftInner, i.left + n[3].width, i.top + i.height - n[2].width);
break;
default:
J(s, r[0], r[1], e.topLeftOuter, e.topRightOuter, i.left, i.top), J(s, r[1], r[2], e.topRightOuter, e.bottomRightOuter, i.left + i.width, i.top), J(s, r[2], r[3], e.bottomRightOuter, e.bottomLeftOuter, i.left + i.width, i.top + i.height), J(s, r[3], r[0], e.bottomLeftOuter, e.topLeftOuter, i.left, i.top + i.height);
}
return s;
};
var Yt = 0, Gt = 'withCredentials' in new XMLHttpRequest(), Qt = 'crossOrigin' in new Image();
It.prototype.cloneTo = function (t) {
It.prototype.cloneTo.call(this, t), t.isPseudoElement = !0, t.before = this.before;
}, It.prototype = Object.create(q.prototype), It.prototype.appendToDOM = function () {
this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += ' ' + this.getHideClass();
}, It.prototype.cleanDOM = function () {
this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), '');
}, It.prototype.getHideClass = function () {
return this['PSEUDO_HIDE_ELEMENT_CLASS_' + (this.before ? 'BEFORE' : 'AFTER')];
}, It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before', It.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after', qt.prototype.renderImage = function (t, e, n, r) {
var i = t.cssInt('paddingLeft'), o = t.cssInt('paddingTop'), s = t.cssInt('paddingRight'), a = t.cssInt('paddingBottom'), c = n.borders, u = e.width - (c[1].width + c[3].width + i + s), l = e.height - (c[0].width + c[2].width + o + a);
this.drawImage(r, 0, 0, r.image.width || u, r.image.height || l, e.left + i + c[3].width, e.top + o + c[0].width, u, l);
}, qt.prototype.renderBackground = function (t, e, n) {
e.height > 0 && e.width > 0 && (this.renderBackgroundColor(t, e), this.renderBackgroundImage(t, e, n));
}, qt.prototype.renderBackgroundColor = function (t, e) {
var n = t.css('backgroundColor');
this.isTransparent(n) || this.rectangle(e.left, e.top, e.width, e.height, t.css('backgroundColor'));
}, qt.prototype.renderBorders = function (t) {
t.forEach(this.renderBorder, this);
}, qt.prototype.renderBorder = function (t) {
this.isTransparent(t.color) || null === t.args || this.drawShape(t.args, t.color);
}, qt.prototype.renderBackgroundImage = function (t, e, n) {
var r = t.parseBackgroundImages();
r.reverse().forEach(function (r, i, o) {
switch (r.method) {
case 'url':
var s = this.images.get(r.args[0]);
s ? this.renderBackgroundRepeating(t, e, s, o.length - (i + 1), n) : I('Error loading background-image', r.args[0]);
break;
case 'linear-gradient':
case 'gradient':
var a = this.images.get(r.value);
a ? this.renderBackgroundGradient(a, e, n) : I('Error loading background-image', r.args[0]);
break;
case 'none':
break;
default:
I('Unknown background-image type', r.args[0]);
}
}, this);
}, qt.prototype.renderBackgroundRepeating = function (t, e, n, r, i) {
var o = t.parseBackgroundSize(e, n.image, r), s = t.parseBackgroundPosition(e, n.image, r, o), a = t.parseBackgroundRepeat(r);
switch (a) {
case 'repeat-x':
case 'repeat no-repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + i[3], e.top + s.top + i[0], 99999, o.height, i);
break;
case 'repeat-y':
case 'no-repeat repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + s.left + i[3], e.top + i[0], o.width, 99999, i);
break;
case 'no-repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + s.left + i[3], e.top + s.top + i[0], o.width, o.height, i);
break;
default:
this.renderBackgroundRepeat(n, s, o, {
top: e.top,
left: e.left
}, i[3], i[0]);
}
}, qt.prototype.isTransparent = function (t) {
return !t || 'transparent' === t || 'rgba(0, 0, 0, 0)' === t;
}, Ot.prototype = Object.create(q.prototype), Ot.prototype.getParentStack = function (t) {
var e = this.parent ? this.parent.stack : null;
return e ? e.ownStacking ? e : e.getParentStack(t) : t.stack;
}, Rt.prototype.testRangeBounds = function (t) {
var e, n, r, i, o = !1;
return t.createRange && (e = t.createRange(), e.getBoundingClientRect && (n = t.createElement('boundtest'), n.style.height = '123px', n.style.display = 'block', t.body.appendChild(n), e.selectNode(n), r = e.getBoundingClientRect(), i = r.height, 123 === i && (o = !0), t.body.removeChild(n))), o;
}, Rt.prototype.testCORS = function () {
return 'undefined' != typeof new Image().crossOrigin;
}, Rt.prototype.testSVG = function () {
var t = new Image(), n = e.createElement('canvas'), r = n.getContext('2d');
t.src = 'data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\'></svg>';
try {
r.drawImage(t, 0, 0), n.toDataURL();
} catch (i) {
return !1;
}
return !0;
}, Bt.prototype.hasFabric = function () {
return html2canvas.fabric ? Promise.resolve() : Promise.reject(new Error('html2canvas.svg.js is not loaded, cannot render svg'));
}, Bt.prototype.inlineFormatting = function (t) {
return /^data:image\/svg\+xml;base64,/.test(t) ? this.decode64(this.removeContentType(t)) : this.removeContentType(t);
}, Bt.prototype.removeContentType = function (t) {
return t.replace(/^data:image\/svg\+xml(;base64)?,/, '');
}, Bt.prototype.isInline = function (t) {
return /^data:image\/svg\+xml/i.test(t);
}, Bt.prototype.createCanvas = function (t) {
var e = this;
return function (n, r) {
var i = new html2canvas.fabric.StaticCanvas('c');
e.image = i.lowerCanvasEl, i.setWidth(r.width).setHeight(r.height).add(html2canvas.fabric.util.groupSVGElements(n, r)).renderAll(), t(i.lowerCanvasEl);
};
}, Bt.prototype.decode64 = function (e) {
return 'function' == typeof t.atob ? t.atob(e) : Dt(e);
}, Nt.prototype = Object.create(Bt.prototype), jt.prototype = Object.create(q.prototype), jt.prototype.applyTextTransform = function () {
this.node.data = this.transform(this.parent.css('textTransform'));
}, jt.prototype.transform = function (t) {
var e = this.node.data;
switch (t) {
case 'lowercase':
return e.toLowerCase();
case 'capitalize':
return e.replace(/(^|\s|:|-|\(|\))([a-z])/g, Lt);
case 'uppercase':
return e.toUpperCase();
default:
return e;
}
}, Mt.prototype = Object.create(F.prototype), Ut.prototype = Object.create(qt.prototype), Ut.prototype.setFillStyle = function (t) {
return this.ctx.fillStyle = t, this.ctx;
}, Ut.prototype.rectangle = function (t, e, n, r, i) {
this.setFillStyle(i).fillRect(t, e, n, r);
}, Ut.prototype.circle = function (t, e, n, r) {
this.setFillStyle(r), this.ctx.beginPath(), this.ctx.arc(t + n / 2, e + n / 2, n / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
}, Ut.prototype.circleStroke = function (t, e, n, r, i, o) {
this.circle(t, e, n, r), this.ctx.strokeStyle = o, this.ctx.stroke();
}, Ut.prototype.drawShape = function (t, e) {
this.shape(t), this.setFillStyle(e).fill();
}, Ut.prototype.taints = function (t) {
if (null === t.tainted) {
this.taintCtx.drawImage(t.image, 0, 0);
try {
this.taintCtx.getImageData(0, 0, 1, 1), t.tainted = !1;
} catch (n) {
this.taintCtx = e.createElement('canvas').getContext('2d'), t.tainted = !0;
}
}
return t.tainted;
}, Ut.prototype.drawImage = function (t, e, n, r, i, o, s, a, c) {
this.taints(t) && !this.options.allowTaint || this.ctx.drawImage(t.image, e, n, r, i, o, s, a, c);
}, Ut.prototype.clip = function (t, e, n) {
this.ctx.save(), t.filter(Ht).forEach(function (t) {
this.shape(t).clip();
}, this), e.call(n), this.ctx.restore();
}, Ut.prototype.shape = function (t) {
return this.ctx.beginPath(), t.forEach(function (t, e) {
'rect' === t[0] ? this.ctx.rect.apply(this.ctx, t.slice(1)) : this.ctx[0 === e ? 'moveTo' : t[0] + 'To'].apply(this.ctx, t.slice(1));
}, this), this.ctx.closePath(), this.ctx;
}, Ut.prototype.font = function (t, e, n, r, i, o) {
this.setFillStyle(t).font = [
e,
n,
r,
i,
o
].join(' ').split(',')[0];
}, Ut.prototype.fontShadow = function (t, e, n, r) {
this.setVariable('shadowColor', t).setVariable('shadowOffsetY', e).setVariable('shadowOffsetX', n).setVariable('shadowBlur', r);
}, Ut.prototype.clearShadow = function () {
this.setVariable('shadowColor', 'rgba(0,0,0,0)');
}, Ut.prototype.setOpacity = function (t) {
this.ctx.globalAlpha = t;
}, Ut.prototype.setTransform = function (t) {
this.ctx.translate(t.origin[0], t.origin[1]), this.ctx.transform.apply(this.ctx, t.matrix), this.ctx.translate(-t.origin[0], -t.origin[1]);
}, Ut.prototype.setVariable = function (t, e) {
return this.variables[t] !== e && (this.variables[t] = this.ctx[t] = e), this;
}, Ut.prototype.text = function (t, e, n) {
this.ctx.fillText(t, e, n);
}, Ut.prototype.backgroundRepeatShape = function (t, e, n, r, i, o, s, a, c) {
var u = [
[
'line',
Math.round(i),
Math.round(o)
],
[
'line',
Math.round(i + s),
Math.round(o)
],
[
'line',
Math.round(i + s),
Math.round(a + o)
],
[
'line',
Math.round(i),
Math.round(a + o)
]
];
this.clip([u], function () {
this.renderBackgroundRepeat(t, e, n, r, c[3], c[0]);
}, this);
}, Ut.prototype.renderBackgroundRepeat = function (t, e, n, r, i, o) {
var s = Math.round(r.left + e.left + i), a = Math.round(r.top + e.top + o);
this.setFillStyle(this.ctx.createPattern(this.resizeImage(t, n), 'repeat')), this.ctx.translate(s, a), this.ctx.fill(), this.ctx.translate(-s, -a);
}, Ut.prototype.renderBackgroundGradient = function (t, e) {
if (t instanceof _) {
var n = this.ctx.createLinearGradient(e.left + e.width * t.x0, e.top + e.height * t.y0, e.left + e.width * t.x1, e.top + e.height * t.y1);
t.colorStops.forEach(function (t) {
n.addColorStop(t.stop, t.color);
}), this.rectangle(e.left, e.top, e.width, e.height, n);
}
}, Ut.prototype.resizeImage = function (t, n) {
var r = t.image;
if (r.width === n.width && r.height === n.height)
return r;
var i, o = e.createElement('canvas');
return o.width = n.width, o.height = n.height, i = o.getContext('2d'), i.drawImage(r, 0, 0, r.width, r.height, 0, 0, n.width, n.height), o;
};
}.call({}, window, document));
var html2canvasNodeAttribute = 'data-html2canvas-node', html2canvasCanvasCloneAttribute = 'data-html2canvas-canvas-clone', html2canvasCanvasCloneIndex = 0;
window.html2canvas = function (t, e) {
if (e = e || {}, e.logging && (window.html2canvas.logging = !0, window.html2canvas.start = Date.now()), e.async = 'undefined' == typeof e.async ? !0 : e.async, e.allowTaint = 'undefined' == typeof e.allowTaint ? !1 : e.allowTaint, e.removeContainer = 'undefined' == typeof e.removeContainer ? !0 : e.removeContainer, e.javascriptEnabled = 'undefined' == typeof e.javascriptEnabled ? !1 : e.javascriptEnabled, e.imageTimeout = 'undefined' == typeof e.imageTimeout ? 10000 : e.imageTimeout, 'string' == typeof t)
return 'string' != typeof e.proxy ? Promise.reject('Proxy must be used when rendering url') : loadUrlDocument(absoluteUrl(t), e.proxy, document, window.innerWidth, window.innerHeight, e).then(function (t) {
return renderWindow(t.contentWindow.document.documentElement, t, e, window.innerWidth, window.innerHeight);
});
var n = (void 0 === t ? [document.documentElement] : t.length ? t : [t])[0];
return n.setAttribute(html2canvasNodeAttribute, 'true'), renderDocument(n.ownerDocument, e, n.ownerDocument.defaultView.innerWidth, n.ownerDocument.defaultView.innerHeight).then(function (t) {
return 'function' == typeof e.onrendered && (log('options.onrendered is deprecated, html2canvas returns a Promise containing the canvas'), e.onrendered(t)), t;
});
}, window.html2canvas.punycode = this.punycode, window.html2canvas.proxy = {}, 'function' == typeof Object.create && 'function' == typeof document.createElement('canvas').getContext || (window.html2canvas = function () {
return Promise.reject('No canvas support');
}), FontMetrics.prototype.getMetrics = function (t, e) {
return void 0 === this.data[t + '-' + e] && (this.data[t + '-' + e] = new Font(t, e)), this.data[t + '-' + e];
}, FrameContainer.prototype.proxyLoad = function (t, e, n) {
var r = this.src;
return loadUrlDocument(r.src, t, r.ownerDocument, e.width, e.height, n);
}, GradientContainer.prototype.TYPES = {
LINEAR: 1,
RADIAL: 2
}, ImageLoader.prototype.findImages = function (t) {
var e = [];
return t.reduce(function (t, e) {
switch (e.node.nodeName) {
case 'IMG':
return t.concat([{
args: [e.node.src],
method: 'url'
}]);
case 'svg':
case 'IFRAME':
return t.concat([{
args: [e.node],
method: e.node.nodeName
}]);
}
return t;
}, []).forEach(this.addImage(e, this.loadImage), this), e;
}, ImageLoader.prototype.findBackgroundImage = function (t, e) {
return e.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(t, this.loadImage), this), t;
}, ImageLoader.prototype.addImage = function (t, e) {
return function (n) {
n.args.forEach(function (r) {
this.imageExists(t, r) || (t.splice(0, 0, e.call(this, n)), log('Added image #' + t.length, 'string' == typeof r ? r.substring(0, 100) : r));
}, this);
};
}, ImageLoader.prototype.hasImageBackground = function (t) {
return 'none' !== t.method;
}, ImageLoader.prototype.loadImage = function (t) {
if ('url' === t.method) {
var e = t.args[0];
return !this.isSVG(e) || this.support.svg || this.options.allowTaint ? e.match(/data:image\/.*;base64,/i) ? new ImageContainer(e.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ''), !1) : this.isSameOrigin(e) || this.options.allowTaint === !0 || this.isSVG(e) ? new ImageContainer(e, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new ImageContainer(e, !0) : this.options.proxy ? new ProxyImageContainer(e, this.options.proxy) : new DummyImageContainer(e) : new SVGContainer(e);
}
return 'linear-gradient' === t.method ? new LinearGradientContainer(t) : 'gradient' === t.method ? new WebkitGradientContainer(t) : 'svg' === t.method ? new SVGNodeContainer(t.args[0], this.support.svg) : 'IFRAME' === t.method ? new FrameContainer(t.args[0], this.isSameOrigin(t.args[0].src), this.options) : new DummyImageContainer(t);
}, ImageLoader.prototype.isSVG = function (t) {
return 'svg' === t.substring(t.length - 3).toLowerCase() || SVGContainer.prototype.isInline(t);
}, ImageLoader.prototype.imageExists = function (t, e) {
return t.some(function (t) {
return t.src === e;
});
}, ImageLoader.prototype.isSameOrigin = function (t) {
return this.getOrigin(t) === this.origin;
}, ImageLoader.prototype.getOrigin = function (t) {
var e = this.link || (this.link = document.createElement('a'));
return e.href = t, e.href = e.href, e.protocol + e.hostname + e.port;
}, ImageLoader.prototype.getPromise = function (t) {
return this.timeout(t, this.options.imageTimeout)['catch'](function () {
var e = new DummyImageContainer(t.src);
return e.promise.then(function (e) {
t.image = e;
});
});
}, ImageLoader.prototype.get = function (t) {
var e = null;
return this.images.some(function (n) {
return (e = n).src === t;
}) ? e : null;
}, ImageLoader.prototype.fetch = function (t) {
return this.images = t.reduce(bind(this.findBackgroundImage, this), this.findImages(t)), this.images.forEach(function (t, e) {
t.promise.then(function () {
log('Succesfully loaded image #' + (e + 1), t);
}, function (n) {
log('Failed loading image #' + (e + 1), t, n);
});
}), this.ready = Promise.all(this.images.map(this.getPromise, this)), log('Finished searching images'), this;
}, ImageLoader.prototype.timeout = function (t, e) {
var n;
return Promise.race([
t.promise,
new Promise(function (r, i) {
n = setTimeout(function () {
log('Timed out loading image', t), i(t);
}, e);
})
]).then(function (t) {
return clearTimeout(n), t;
});
}, LinearGradientContainer.prototype = Object.create(GradientContainer.prototype), LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, NodeContainer.prototype.cloneTo = function (t) {
t.visible = this.visible, t.borders = this.borders, t.bounds = this.bounds, t.clip = this.clip, t.backgroundClip = this.backgroundClip, t.computedStyles = this.computedStyles, t.styles = this.styles, t.backgroundImages = this.backgroundImages, t.opacity = this.opacity;
}, NodeContainer.prototype.getOpacity = function () {
return null === this.opacity ? this.opacity = this.cssFloat('opacity') : this.opacity;
}, NodeContainer.prototype.assignStack = function (t) {
this.stack = t, t.children.push(this);
}, NodeContainer.prototype.isElementVisible = function () {
return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : 'none' !== this.css('display') && 'hidden' !== this.css('visibility') && !this.node.hasAttribute('data-html2canvas-ignore') && ('INPUT' !== this.node.nodeName || 'hidden' !== this.node.getAttribute('type'));
}, NodeContainer.prototype.css = function (t) {
return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ':before' : ':after') : this.computedStyle(null)), this.styles[t] || (this.styles[t] = this.computedStyles[t]);
}, NodeContainer.prototype.prefixedCss = function (t) {
var e = [
'webkit',
'moz',
'ms',
'o'
], n = this.css(t);
return void 0 === n && e.some(function (e) {
return n = this.css(e + t.substr(0, 1).toUpperCase() + t.substr(1)), void 0 !== n;
}, this), void 0 === n ? null : n;
}, NodeContainer.prototype.computedStyle = function (t) {
return this.node.ownerDocument.defaultView.getComputedStyle(this.node, t);
}, NodeContainer.prototype.cssInt = function (t) {
var e = parseInt(this.css(t), 10);
return isNaN(e) ? 0 : e;
}, NodeContainer.prototype.cssFloat = function (t) {
var e = parseFloat(this.css(t));
return isNaN(e) ? 0 : e;
}, NodeContainer.prototype.fontWeight = function () {
var t = this.css('fontWeight');
switch (parseInt(t, 10)) {
case 401:
t = 'bold';
break;
case 400:
t = 'normal';
}
return t;
}, NodeContainer.prototype.parseClip = function () {
var t = this.css('clip').match(this.CLIP);
return t ? {
top: parseInt(t[1], 10),
right: parseInt(t[2], 10),
bottom: parseInt(t[3], 10),
left: parseInt(t[4], 10)
} : null;
}, NodeContainer.prototype.parseBackgroundImages = function () {
return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css('backgroundImage')));
}, NodeContainer.prototype.cssList = function (t, e) {
var n = (this.css(t) || '').split(',');
return n = n[e || 0] || n[0] || 'auto', n = n.trim().split(' '), 1 === n.length && (n = [
n[0],
n[0]
]), n;
}, NodeContainer.prototype.parseBackgroundSize = function (t, e, n) {
var r, i, o = this.cssList('backgroundSize', n);
if (isPercentage(o[0]))
r = t.width * parseFloat(o[0]) / 100;
else {
if (/contain|cover/.test(o[0])) {
var s = t.width / t.height, a = e.width / e.height;
return a > s ^ 'contain' === o[0] ? {
width: t.height * a,
height: t.height
} : {
width: t.width,
height: t.width / a
};
}
r = parseInt(o[0], 10);
}
return i = 'auto' === o[0] && 'auto' === o[1] ? e.height : 'auto' === o[1] ? r / e.width * e.height : isPercentage(o[1]) ? t.height * parseFloat(o[1]) / 100 : parseInt(o[1], 10), 'auto' === o[0] && (r = i / e.height * e.width), {
width: r,
height: i
};
}, NodeContainer.prototype.parseBackgroundPosition = function (t, e, n, r) {
var i, o, s = this.cssList('backgroundPosition', n);
return i = isPercentage(s[0]) ? (t.width - (r || e).width) * (parseFloat(s[0]) / 100) : parseInt(s[0], 10), o = 'auto' === s[1] ? i / e.width * e.height : isPercentage(s[1]) ? (t.height - (r || e).height) * parseFloat(s[1]) / 100 : parseInt(s[1], 10), 'auto' === s[0] && (i = o / e.height * e.width), {
left: i,
top: o
};
}, NodeContainer.prototype.parseBackgroundRepeat = function (t) {
return this.cssList('backgroundRepeat', t)[0];
}, NodeContainer.prototype.parseTextShadows = function () {
var t = this.css('textShadow'), e = [];
if (t && 'none' !== t)
for (var n = t.match(this.TEXT_SHADOW_PROPERTY), r = 0; n && r < n.length; r++) {
var i = n[r].match(this.TEXT_SHADOW_VALUES);
e.push({
color: i[0],
offsetX: i[1] ? parseFloat(i[1].replace('px', '')) : 0,
offsetY: i[2] ? parseFloat(i[2].replace('px', '')) : 0,
blur: i[3] ? i[3].replace('px', '') : 0
});
}
return e;
}, NodeContainer.prototype.parseTransform = function () {
if (!this.transformData)
if (this.hasTransform()) {
var t = this.parseBounds(), e = this.prefixedCss('transformOrigin').split(' ').map(removePx).map(asFloat);
e[0] += t.left, e[1] += t.top, this.transformData = {
origin: e,
matrix: this.parseTransformMatrix()
};
} else
this.transformData = {
origin: [
0,
0
],
matrix: [
1,
0,
0,
1,
0,
0
]
};
return this.transformData;
}, NodeContainer.prototype.parseTransformMatrix = function () {
if (!this.transformMatrix) {
var t = this.prefixedCss('transform'), e = t ? parseMatrix(t.match(this.MATRIX_PROPERTY)) : null;
this.transformMatrix = e ? e : [
1,
0,
0,
1,
0,
0
];
}
return this.transformMatrix;
}, NodeContainer.prototype.parseBounds = function () {
return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
}, NodeContainer.prototype.hasTransform = function () {
return '1,0,0,1,0,0' !== this.parseTransformMatrix().join(',') || this.parent && this.parent.hasTransform();
}, NodeContainer.prototype.getValue = function () {
var t = this.node.value || '';
return t = 'SELECT' === this.node.tagName ? selectionValue(this.node) : t, 0 === t.length ? this.node.placeholder || '' : t;
}, NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, NodeParser.prototype.calculateOverflowClips = function () {
this.nodes.forEach(function (t) {
if (isElement(t)) {
isPseudoElement(t) && t.appendToDOM(), t.borders = this.parseBorders(t);
var e = 'hidden' === t.css('overflow') ? [t.borders.clip] : [], n = t.parseClip();
n && -1 !== [
'absolute',
'fixed'
].indexOf(t.css('position')) && e.push([[
'rect',
t.bounds.left + n.left,
t.bounds.top + n.top,
n.right - n.left,
n.bottom - n.top
]]), t.clip = hasParentClip(t) ? t.parent.clip.concat(e) : e, t.backgroundClip = 'hidden' !== t.css('overflow') ? t.clip.concat([t.borders.clip]) : t.clip, isPseudoElement(t) && t.cleanDOM();
} else
isTextNode(t) && (t.clip = hasParentClip(t) ? t.parent.clip : []);
isPseudoElement(t) || (t.bounds = null);
}, this);
}, NodeParser.prototype.asyncRenderer = function (t, e, n) {
n = n || Date.now(), this.paint(t[this.renderIndex++]), t.length === this.renderIndex ? e() : n + 20 > Date.now() ? this.asyncRenderer(t, e, n) : setTimeout(bind(function () {
this.asyncRenderer(t, e);
}, this), 0);
}, NodeParser.prototype.createPseudoHideStyles = function (t) {
this.createStyles(t, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
}, NodeParser.prototype.disableAnimations = function (t) {
this.createStyles(t, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
}, NodeParser.prototype.createStyles = function (t, e) {
var n = t.createElement('style');
n.innerHTML = e, t.body.appendChild(n);
}, NodeParser.prototype.getPseudoElements = function (t) {
var e = [[t]];
if (t.node.nodeType === Node.ELEMENT_NODE) {
var n = this.getPseudoElement(t, ':before'), r = this.getPseudoElement(t, ':after');
n && e.push(n), r && e.push(r);
}
return flatten(e);
}, NodeParser.prototype.getPseudoElement = function (t, e) {
var n = t.computedStyle(e);
if (!n || !n.content || 'none' === n.content || '-moz-alt-content' === n.content || 'none' === n.display)
return null;
for (var r = stripQuotes(n.content), i = 'url' === r.substr(0, 3), o = document.createElement(i ? 'img' : 'html2canvaspseudoelement'), s = new PseudoElementContainer(o, t, e), a = n.length - 1; a >= 0; a--) {
var c = toCamelCase(n.item(a));
o.style[c] = n[c];
}
if (o.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, i)
return o.src = parseBackgrounds(r)[0].args[0], [s];
var u = document.createTextNode(r);
return o.appendChild(u), [
s,
new TextContainer(u, s)
];
}, NodeParser.prototype.getChildren = function (t) {
return flatten([].filter.call(t.node.childNodes, renderableNode).map(function (e) {
var n = [e.nodeType === Node.TEXT_NODE ? new TextContainer(e, t) : new NodeContainer(e, t)].filter(nonIgnoredElement);
return e.nodeType === Node.ELEMENT_NODE && n.length && 'TEXTAREA' !== e.tagName ? n[0].isElementVisible() ? n.concat(this.getChildren(n[0])) : [] : n;
}, this));
}, NodeParser.prototype.newStackingContext = function (t, e) {
var n = new StackingContext(e, t.getOpacity(), t.node, t.parent);
t.cloneTo(n);
var r = e ? n.getParentStack(this) : n.parent.stack;
r.contexts.push(n), t.stack = n;
}, NodeParser.prototype.createStackingContexts = function () {
this.nodes.forEach(function (t) {
isElement(t) && (this.isRootElement(t) || hasOpacity(t) || isPositionedForStacking(t) || this.isBodyWithTransparentRoot(t) || t.hasTransform()) ? this.newStackingContext(t, !0) : isElement(t) && (isPositioned(t) && zIndex0(t) || isInlineBlock(t) || isFloating(t)) ? this.newStackingContext(t, !1) : t.assignStack(t.parent.stack);
}, this);
}, NodeParser.prototype.isBodyWithTransparentRoot = function (t) {
return 'BODY' === t.node.nodeName && this.renderer.isTransparent(t.parent.css('backgroundColor'));
}, NodeParser.prototype.isRootElement = function (t) {
return null === t.parent;
}, NodeParser.prototype.sortStackingContexts = function (t) {
t.contexts.sort(zIndexSort(t.contexts.slice(0))), t.contexts.forEach(this.sortStackingContexts, this);
}, NodeParser.prototype.parseTextBounds = function (t) {
return function (e, n, r) {
if ('none' !== t.parent.css('textDecoration').substr(0, 4) || 0 !== e.trim().length) {
if (this.support.rangeBounds && !t.parent.hasTransform()) {
var i = r.slice(0, n).join('').length;
return this.getRangeBounds(t.node, i, e.length);
}
if (t.node && 'string' == typeof t.node.data) {
var o = t.node.splitText(e.length), s = this.getWrapperBounds(t.node, t.parent.hasTransform());
return t.node = o, s;
}
} else
this.support.rangeBounds && !t.parent.hasTransform() || (t.node = t.node.splitText(e.length));
return {};
};
}, NodeParser.prototype.getWrapperBounds = function (t, e) {
var n = t.ownerDocument.createElement('html2canvaswrapper'), r = t.parentNode, i = t.cloneNode(!0);
n.appendChild(t.cloneNode(!0)), r.replaceChild(n, t);
var o = e ? offsetBounds(n) : getBounds(n);
return r.replaceChild(i, n), o;
}, NodeParser.prototype.getRangeBounds = function (t, e, n) {
var r = this.range || (this.range = t.ownerDocument.createRange());
return r.setStart(t, e), r.setEnd(t, e + n), r.getBoundingClientRect();
}, NodeParser.prototype.parse = function (t) {
var e = t.contexts.filter(negativeZIndex), n = t.children.filter(isElement), r = n.filter(not(isFloating)), i = r.filter(not(isPositioned)).filter(not(inlineLevel)), o = n.filter(not(isPositioned)).filter(isFloating), s = r.filter(not(isPositioned)).filter(inlineLevel), a = t.contexts.concat(r.filter(isPositioned)).filter(zIndex0), c = t.children.filter(isTextNode).filter(hasText), u = t.contexts.filter(positiveZIndex);
e.concat(i).concat(o).concat(s).concat(a).concat(c).concat(u).forEach(function (t) {
this.renderQueue.push(t), isStackingContext(t) && (this.parse(t), this.renderQueue.push(new ClearTransform()));
}, this);
}, NodeParser.prototype.paint = function (t) {
try {
t instanceof ClearTransform ? this.renderer.ctx.restore() : isTextNode(t) ? (isPseudoElement(t.parent) && t.parent.appendToDOM(), this.paintText(t), isPseudoElement(t.parent) && t.parent.cleanDOM()) : this.paintNode(t);
} catch (e) {
log(e);
}
}, NodeParser.prototype.paintNode = function (t) {
isStackingContext(t) && (this.renderer.setOpacity(t.opacity), this.renderer.ctx.save(), t.hasTransform() && this.renderer.setTransform(t.parseTransform())), 'INPUT' === t.node.nodeName && 'checkbox' === t.node.type ? this.paintCheckbox(t) : 'INPUT' === t.node.nodeName && 'radio' === t.node.type ? this.paintRadio(t) : this.paintElement(t);
}, NodeParser.prototype.paintElement = function (t) {
var e = t.parseBounds();
this.renderer.clip(t.backgroundClip, function () {
this.renderer.renderBackground(t, e, t.borders.borders.map(getWidth));
}, this), this.renderer.clip(t.clip, function () {
this.renderer.renderBorders(t.borders.borders);
}, this), this.renderer.clip(t.backgroundClip, function () {
switch (t.node.nodeName) {
case 'svg':
case 'IFRAME':
var n = this.images.get(t.node);
n ? this.renderer.renderImage(t, e, t.borders, n) : log('Error loading <' + t.node.nodeName + '>', t.node);
break;
case 'IMG':
var r = this.images.get(t.node.src);
r ? this.renderer.renderImage(t, e, t.borders, r) : log('Error loading <img>', t.node.src);
break;
case 'CANVAS':
this.renderer.renderImage(t, e, t.borders, { image: t.node });
break;
case 'SELECT':
case 'INPUT':
case 'TEXTAREA':
this.paintFormValue(t);
}
}, this);
}, NodeParser.prototype.paintCheckbox = function (t) {
var e = t.parseBounds(), n = Math.min(e.width, e.height), r = {
width: n - 1,
height: n - 1,
top: e.top,
left: e.left
}, i = [
3,
3
], o = [
i,
i,
i,
i
], s = [
1,
1,
1,
1
].map(function (t) {
return {
color: '#A5A5A5',
width: t
};
}), a = calculateCurvePoints(r, o, s);
this.renderer.clip(t.backgroundClip, function () {
this.renderer.rectangle(r.left + 1, r.top + 1, r.width - 2, r.height - 2, '#DEDEDE'), this.renderer.renderBorders(calculateBorders(s, r, a, o)), t.node.checked && (this.renderer.font('#424242', 'normal', 'normal', 'bold', n - 3 + 'px', 'arial'), this.renderer.text('\u2714', r.left + n / 6, r.top + n - 1));
}, this);
}, NodeParser.prototype.paintRadio = function (t) {
var e = t.parseBounds(), n = Math.min(e.width, e.height) - 2;
this.renderer.clip(t.backgroundClip, function () {
this.renderer.circleStroke(e.left + 1, e.top + 1, n, '#DEDEDE', 1, '#A5A5A5'), t.node.checked && this.renderer.circle(Math.ceil(e.left + n / 4) + 1, Math.ceil(e.top + n / 4) + 1, Math.floor(n / 2), '#424242');
}, this);
}, NodeParser.prototype.paintFormValue = function (t) {
if (t.getValue().length > 0) {
var e = t.node.ownerDocument, n = e.createElement('html2canvaswrapper'), r = [
'lineHeight',
'textAlign',
'fontFamily',
'fontWeight',
'fontSize',
'color',
'paddingLeft',
'paddingTop',
'paddingRight',
'paddingBottom',
'width',
'height',
'borderLeftStyle',
'borderTopStyle',
'borderLeftWidth',
'borderTopWidth',
'boxSizing',
'whiteSpace',
'wordWrap',
'list-style-type'
];
r.forEach(function (e) {
try {
n.style[e] = t.css(e);
} catch (r) {
log('html2canvas: Parse: Exception caught in renderFormValue: ' + r.message);
}
});
var i = t.parseBounds();
n.style.position = 'fixed', n.style.left = i.left + 'px', n.style.top = i.top + 'px', n.textContent = t.getValue(), e.body.appendChild(n), this.paintText(new TextContainer(n.firstChild, t)), e.body.removeChild(n);
}
}, NodeParser.prototype.paintText = function (t) {
t.applyTextTransform();
var e = window.html2canvas.punycode.ucs2.decode(t.node.data), n = this.options.letterRendering && !noLetterSpacing(t) || hasUnicode(t.node.data) ? e.map(function (t) {
return window.html2canvas.punycode.ucs2.encode([t]);
}) : getWords(e), r = t.parent.fontWeight(), i = t.parent.css('fontSize'), o = t.parent.css('fontFamily'), s = t.parent.parseTextShadows();
this.renderer.font(t.parent.css('color'), t.parent.css('fontStyle'), t.parent.css('fontVariant'), r, i, o), s.length ? this.renderer.fontShadow(s[0].color, s[0].offsetX, s[0].offsetY, s[0].blur) : this.renderer.clearShadow(), this.renderer.clip(t.parent.clip, function () {
n.map(this.parseTextBounds(t), this).forEach(function (e, r) {
e && (this.renderer.text(n[r], e.left, e.bottom), this.renderTextDecoration(t.parent, e, this.fontMetrics.getMetrics(o, i)));
}, this);
}, this);
}, NodeParser.prototype.renderTextDecoration = function (t, e, n) {
switch (t.css('textDecoration').split(' ')[0]) {
case 'underline':
this.renderer.rectangle(e.left, Math.round(e.top + n.baseline + n.lineWidth), e.width, 1, t.css('color'));
break;
case 'overline':
this.renderer.rectangle(e.left, Math.round(e.top), e.width, 1, t.css('color'));
break;
case 'line-through':
this.renderer.rectangle(e.left, Math.ceil(e.top + n.middle + n.lineWidth), e.width, 1, t.css('color'));
}
}, NodeParser.prototype.parseBorders = function (t) {
var e = t.parseBounds(), n = getBorderRadiusData(t), r = [
'Top',
'Right',
'Bottom',
'Left'
].map(function (e) {
return {
width: t.cssInt('border' + e + 'Width'),
color: t.css('border' + e + 'Color'),
args: null
};
}), i = calculateCurvePoints(e, n, r);
return {
clip: this.parseBackgroundClip(t, i, r, n, e),
borders: calculateBorders(r, e, i, n)
};
}, NodeParser.prototype.parseBackgroundClip = function (t, e, n, r, i) {
var o = t.css('backgroundClip'), s = [];
switch (o) {
case 'content-box':
case 'padding-box':
parseCorner(s, r[0], r[1], e.topLeftInner, e.topRightInner, i.left + n[3].width, i.top + n[0].width), parseCorner(s, r[1], r[2], e.topRightInner, e.bottomRightInner, i.left + i.width - n[1].width, i.top + n[0].width), parseCorner(s, r[2], r[3], e.bottomRightInner, e.bottomLeftInner, i.left + i.width - n[1].width, i.top + i.height - n[2].width), parseCorner(s, r[3], r[0], e.bottomLeftInner, e.topLeftInner, i.left + n[3].width, i.top + i.height - n[2].width);
break;
default:
parseCorner(s, r[0], r[1], e.topLeftOuter, e.topRightOuter, i.left, i.top), parseCorner(s, r[1], r[2], e.topRightOuter, e.bottomRightOuter, i.left + i.width, i.top), parseCorner(s, r[2], r[3], e.bottomRightOuter, e.bottomLeftOuter, i.left + i.width, i.top + i.height), parseCorner(s, r[3], r[0], e.bottomLeftOuter, e.topLeftOuter, i.left, i.top + i.height);
}
return s;
}, !function () {
var t, e, n, r;
!function () {
var i = {}, o = {};
t = function (t, e, n) {
i[t] = {
deps: e,
callback: n
};
}, r = n = e = function (t) {
function n(e) {
if ('.' !== e.charAt(0))
return e;
for (var n = e.split('/'), r = t.split('/').slice(0, -1), i = 0, o = n.length; o > i; i++) {
var s = n[i];
if ('..' === s)
r.pop();
else {
if ('.' === s)
continue;
r.push(s);
}
}
return r.join('/');
}
if (r._eak_seen = i, o[t])
return o[t];
if (o[t] = {}, !i[t])
throw new Error('Could not find module ' + t);
for (var s, a = i[t], c = a.deps, u = a.callback, l = [], h = 0, d = c.length; d > h; h++)
'exports' === c[h] ? l.push(s = {}) : l.push(e(n(c[h])));
var f = u.apply(this, l);
return o[t] = s || f;
};
}(), t('promise/all', [
'./utils',
'exports'
], function (t, e) {
'use strict';
function n(t) {
var e = this;
if (!r(t))
throw new TypeError('You must pass an array to all.');
return new e(function (e, n) {
function r(t) {
return function (e) {
o(t, e);
};
}
function o(t, n) {
a[t] = n, 0 === --c && e(a);
}
var s, a = [], c = t.length;
0 === c && e([]);
for (var u = 0; u < t.length; u++)
s = t[u], s && i(s.then) ? s.then(r(u), n) : o(u, s);
});
}
var r = t.isArray, i = t.isFunction;
e.all = n;
}), t('promise/asap', ['exports'], function (t) {
'use strict';
function e() {
return function () {
process.nextTick(i);
};
}
function n() {
var t = 0, e = new c(i), n = document.createTextNode('');
return e.observe(n, { characterData: !0 }), function () {
n.data = t = ++t % 2;
};
}
function r() {
return function () {
u.setTimeout(i, 1);
};
}
function i() {
for (var t = 0; t < l.length; t++) {
var e = l[t], n = e[0], r = e[1];
n(r);
}
l = [];
}
function o(t, e) {
var n = l.push([
t,
e
]);
1 === n && s();
}
var s, a = 'undefined' != typeof window ? window : {}, c = a.MutationObserver || a.WebKitMutationObserver, u = 'undefined' != typeof global ? global : this, l = [];
s = 'undefined' != typeof process && '[object process]' === {}.toString.call(process) ? e() : c ? n() : r(), t.asap = o;
}), t('promise/cast', ['exports'], function (t) {
'use strict';
function e(t) {
if (t && 'object' == typeof t && t.constructor === this)
return t;
var e = this;
return new e(function (e) {
e(t);
});
}
t.cast = e;
}), t('promise/config', ['exports'], function (t) {
'use strict';
function e(t, e) {
return 2 !== arguments.length ? n[t] : void (n[t] = e);
}
var n = { instrument: !1 };
t.config = n, t.configure = e;
}), t('promise/polyfill', [
'./promise',
'./utils',
'exports'
], function (t, e, n) {
'use strict';
function r() {
var t = 'Promise' in window && 'cast' in window.Promise && 'resolve' in window.Promise && 'reject' in window.Promise && 'all' in window.Promise && 'race' in window.Promise && function () {
var t;
return new window.Promise(function (e) {
t = e;
}), o(t);
}();
t || (window.Promise = i);
}
var i = t.Promise, o = e.isFunction;
n.polyfill = r;
}), t('promise/promise', [
'./config',
'./utils',
'./cast',
'./all',
'./race',
'./resolve',
'./reject',
'./asap',
'exports'
], function (t, e, n, r, i, o, s, a, c) {
'use strict';
function u(t) {
if (!k(t))
throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
if (!(this instanceof u))
throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
this._subscribers = [], l(t, this);
}
function l(t, e) {
function n(t) {
m(e, t);
}
function r(t) {
w(e, t);
}
try {
t(n, r);
} catch (i) {
r(i);
}
}
function h(t, e, n, r) {
var i, o, s, a, c = k(n);
if (c)
try {
i = n(r), s = !0;
} catch (u) {
a = !0, o = u;
}
else
i = r, s = !0;
p(e, i) || (c && s ? m(e, i) : a ? w(e, o) : t === I ? m(e, i) : t === q && w(e, i));
}
function d(t, e, n, r) {
var i = t._subscribers, o = i.length;
i[o] = e, i[o + I] = n, i[o + q] = r;
}
function f(t, e) {
for (var n, r, i = t._subscribers, o = t._detail, s = 0; s < i.length; s += 3)
n = i[s], r = i[s + e], h(e, n, r, o);
t._subscribers = null;
}
function p(t, e) {
var n, r = null;
try {
if (t === e)
throw new TypeError('A promises callback cannot return that same promise.');
if (x(e) && (r = e.then, k(r)))
return r.call(e, function (r) {
return n ? !0 : (n = !0, void (e !== r ? m(t, r) : g(t, r)));
}, function (e) {
return n ? !0 : (n = !0, void w(t, e));
}), !0;
} catch (i) {
return n ? !0 : (w(t, i), !0);
}
return !1;
}
function m(t, e) {
t === e ? g(t, e) : p(t, e) || g(t, e);
}
function g(t, e) {
t._state === P && (t._state = _, t._detail = e, b.async(y, t));
}
function w(t, e) {
t._state === P && (t._state = _, t._detail = e, b.async(v, t));
}
function y(t) {
f(t, t._state = I);
}
function v(t) {
f(t, t._state = q);
}
var b = t.config, x = (t.configure, e.objectOrFunction), k = e.isFunction, A = (e.now, n.cast), C = r.all, E = i.race, S = o.resolve, F = s.reject, T = a.asap;
b.async = T;
var P = void 0, _ = 0, I = 1, q = 2;
u.prototype = {
constructor: u,
_state: void 0,
_detail: void 0,
_subscribers: void 0,
then: function (t, e) {
var n = this, r = new this.constructor(function () {
});
if (this._state) {
var i = arguments;
b.async(function () {
h(n._state, r, i[n._state - 1], n._detail);
});
} else
d(this, r, t, e);
return r;
},
'catch': function (t) {
return this.then(null, t);
}
}, u.all = C, u.cast = A, u.race = E, u.resolve = S, u.reject = F, c.Promise = u;
}), t('promise/race', [
'./utils',
'exports'
], function (t, e) {
'use strict';
function n(t) {
var e = this;
if (!r(t))
throw new TypeError('You must pass an array to race.');
return new e(function (e, n) {
for (var r, i = 0; i < t.length; i++)
r = t[i], r && 'function' == typeof r.then ? r.then(e, n) : e(r);
});
}
var r = t.isArray;
e.race = n;
}), t('promise/reject', ['exports'], function (t) {
'use strict';
function e(t) {
var e = this;
return new e(function (e, n) {
n(t);
});
}
t.reject = e;
}), t('promise/resolve', ['exports'], function (t) {
'use strict';
function e(t) {
var e = this;
return new e(function (e) {
e(t);
});
}
t.resolve = e;
}), t('promise/utils', ['exports'], function (t) {
'use strict';
function e(t) {
return n(t) || 'object' == typeof t && null !== t;
}
function n(t) {
return 'function' == typeof t;
}
function r(t) {
return '[object Array]' === Object.prototype.toString.call(t);
}
var i = Date.now || function () {
return new Date().getTime();
};
t.objectOrFunction = e, t.isFunction = n, t.isArray = r, t.now = i;
}), e('promise/polyfill').polyfill();
}();
var proxyCount = 0, supportsCORS = 'withCredentials' in new XMLHttpRequest(), supportsCORSImage = 'crossOrigin' in new Image();
PseudoElementContainer.prototype.cloneTo = function (t) {
PseudoElementContainer.prototype.cloneTo.call(this, t), t.isPseudoElement = !0, t.before = this.before;
}, PseudoElementContainer.prototype = Object.create(NodeContainer.prototype), PseudoElementContainer.prototype.appendToDOM = function () {
this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += ' ' + this.getHideClass();
}, PseudoElementContainer.prototype.cleanDOM = function () {
this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), '');
}, PseudoElementContainer.prototype.getHideClass = function () {
return this['PSEUDO_HIDE_ELEMENT_CLASS_' + (this.before ? 'BEFORE' : 'AFTER')];
}, PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before', PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after', Renderer.prototype.renderImage = function (t, e, n, r) {
var i = t.cssInt('paddingLeft'), o = t.cssInt('paddingTop'), s = t.cssInt('paddingRight'), a = t.cssInt('paddingBottom'), c = n.borders, u = e.width - (c[1].width + c[3].width + i + s), l = e.height - (c[0].width + c[2].width + o + a);
this.drawImage(r, 0, 0, r.image.width || u, r.image.height || l, e.left + i + c[3].width, e.top + o + c[0].width, u, l);
}, Renderer.prototype.renderBackground = function (t, e, n) {
e.height > 0 && e.width > 0 && (this.renderBackgroundColor(t, e), this.renderBackgroundImage(t, e, n));
}, Renderer.prototype.renderBackgroundColor = function (t, e) {
var n = t.css('backgroundColor');
this.isTransparent(n) || this.rectangle(e.left, e.top, e.width, e.height, t.css('backgroundColor'));
}, Renderer.prototype.renderBorders = function (t) {
t.forEach(this.renderBorder, this);
}, Renderer.prototype.renderBorder = function (t) {
this.isTransparent(t.color) || null === t.args || this.drawShape(t.args, t.color);
}, Renderer.prototype.renderBackgroundImage = function (t, e, n) {
var r = t.parseBackgroundImages();
r.reverse().forEach(function (r, i, o) {
switch (r.method) {
case 'url':
var s = this.images.get(r.args[0]);
s ? this.renderBackgroundRepeating(t, e, s, o.length - (i + 1), n) : log('Error loading background-image', r.args[0]);
break;
case 'linear-gradient':
case 'gradient':
var a = this.images.get(r.value);
a ? this.renderBackgroundGradient(a, e, n) : log('Error loading background-image', r.args[0]);
break;
case 'none':
break;
default:
log('Unknown background-image type', r.args[0]);
}
}, this);
}, Renderer.prototype.renderBackgroundRepeating = function (t, e, n, r, i) {
var o = t.parseBackgroundSize(e, n.image, r), s = t.parseBackgroundPosition(e, n.image, r, o), a = t.parseBackgroundRepeat(r);
switch (a) {
case 'repeat-x':
case 'repeat no-repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + i[3], e.top + s.top + i[0], 99999, o.height, i);
break;
case 'repeat-y':
case 'no-repeat repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + s.left + i[3], e.top + i[0], o.width, 99999, i);
break;
case 'no-repeat':
this.backgroundRepeatShape(n, s, o, e, e.left + s.left + i[3], e.top + s.top + i[0], o.width, o.height, i);
break;
default:
this.renderBackgroundRepeat(n, s, o, {
top: e.top,
left: e.left
}, i[3], i[0]);
}
}, Renderer.prototype.isTransparent = function (t) {
return !t || 'transparent' === t || 'rgba(0, 0, 0, 0)' === t;
}, StackingContext.prototype = Object.create(NodeContainer.prototype), StackingContext.prototype.getParentStack = function (t) {
var e = this.parent ? this.parent.stack : null;
return e ? e.ownStacking ? e : e.getParentStack(t) : t.stack;
}, Support.prototype.testRangeBounds = function (t) {
var e, n, r, i, o = !1;
return t.createRange && (e = t.createRange(), e.getBoundingClientRect && (n = t.createElement('boundtest'), n.style.height = '123px', n.style.display = 'block', t.body.appendChild(n), e.selectNode(n), r = e.getBoundingClientRect(), i = r.height, 123 === i && (o = !0), t.body.removeChild(n))), o;
}, Support.prototype.testCORS = function () {
return 'undefined' != typeof new Image().crossOrigin;
}, Support.prototype.testSVG = function () {
var t = new Image(), e = document.createElement('canvas'), n = e.getContext('2d');
t.src = 'data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\'></svg>';
try {
n.drawImage(t, 0, 0), e.toDataURL();
} catch (r) {
return !1;
}
return !0;
}, SVGContainer.prototype.hasFabric = function () {
return html2canvas.fabric ? Promise.resolve() : Promise.reject(new Error('html2canvas.svg.js is not loaded, cannot render svg'));
}, SVGContainer.prototype.inlineFormatting = function (t) {
return /^data:image\/svg\+xml;base64,/.test(t) ? this.decode64(this.removeContentType(t)) : this.removeContentType(t);
}, SVGContainer.prototype.removeContentType = function (t) {
return t.replace(/^data:image\/svg\+xml(;base64)?,/, '');
}, SVGContainer.prototype.isInline = function (t) {
return /^data:image\/svg\+xml/i.test(t);
}, SVGContainer.prototype.createCanvas = function (t) {
var e = this;
return function (n, r) {
var i = new html2canvas.fabric.StaticCanvas('c');
e.image = i.lowerCanvasEl, i.setWidth(r.width).setHeight(r.height).add(html2canvas.fabric.util.groupSVGElements(n, r)).renderAll(), t(i.lowerCanvasEl);
};
}, SVGContainer.prototype.decode64 = function (t) {
return 'function' == typeof window.atob ? window.atob(t) : decode64(t);
}, SVGNodeContainer.prototype = Object.create(SVGContainer.prototype), TextContainer.prototype = Object.create(NodeContainer.prototype), TextContainer.prototype.applyTextTransform = function () {
this.node.data = this.transform(this.parent.css('textTransform'));
}, TextContainer.prototype.transform = function (t) {
var e = this.node.data;
switch (t) {
case 'lowercase':
return e.toLowerCase();
case 'capitalize':
return e.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
case 'uppercase':
return e.toUpperCase();
default:
return e;
}
}, WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype), function (t) {
var e;
e = function () {
function e(t) {
var e, n, r, i, o, s, a, c, u, l, h, d, f, p, m;
for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, s = null;;) {
switch (e = this.readUInt32(), l = function () {
var t, e;
for (e = [], a = t = 0; 4 > t; a = ++t)
e.push(String.fromCharCode(this.data[this.pos++]));
return e;
}.call(this).join('')) {
case 'IHDR':
this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
break;
case 'acTL':
this.animation = {
numFrames: this.readUInt32(),
numPlays: this.readUInt32() || 1 / 0,
frames: []
};
break;
case 'PLTE':
this.palette = this.read(e);
break;
case 'fcTL':
s && this.animation.frames.push(s), this.pos += 4, s = {
width: this.readUInt32(),
height: this.readUInt32(),
xOffset: this.readUInt32(),
yOffset: this.readUInt32()
}, o = this.readUInt16(), i = this.readUInt16() || 100, s.delay = 1000 * o / i, s.disposeOp = this.data[this.pos++], s.blendOp = this.data[this.pos++], s.data = [];
break;
case 'IDAT':
case 'fdAT':
for ('fdAT' === l && (this.pos += 4, e -= 4), t = (null != s ? s.data : void 0) || this.imgData, a = f = 0; e >= 0 ? e > f : f > e; a = e >= 0 ? ++f : --f)
t.push(this.data[this.pos++]);
break;
case 'tRNS':
switch (this.transparency = {}, this.colorType) {
case 3:
if (r = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > r)
throw new Error('More transparent colors than palette size');
if (h = r - this.transparency.indexed.length, h > 0)
for (a = p = 0; h >= 0 ? h > p : p > h; a = h >= 0 ? ++p : --p)
this.transparency.indexed.push(255);
break;
case 0:
this.transparency.grayscale = this.read(e)[0];
break;
case 2:
this.transparency.rgb = this.read(e);
}
break;
case 'tEXt':
d = this.read(e), c = d.indexOf(0), u = String.fromCharCode.apply(String, d.slice(0, c)), this.text[u] = String.fromCharCode.apply(String, d.slice(c + 1));
break;
case 'IEND':
return s && this.animation.frames.push(s), this.colors = function () {
switch (this.colorType) {
case 0:
case 3:
case 4:
return 1;
case 2:
case 6:
return 3;
}
}.call(this), this.hasAlphaChannel = 4 === (m = this.colorType) || 6 === m, n = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * n, this.colorSpace = function () {
switch (this.colors) {
case 1:
return 'DeviceGray';
case 3:
return 'DeviceRGB';
}
}.call(this), void (this.imgData = new Uint8Array(this.imgData));
default:
this.pos += e;
}
if (this.pos += 4, this.pos > this.data.length)
throw new Error('Incomplete or corrupt PNG file');
}
}
var n, r, i, o, s, a, c, u;
e.load = function (t, n, r) {
var i;
return 'function' == typeof n && (r = n), i = new XMLHttpRequest(), i.open('GET', t, !0), i.responseType = 'arraybuffer', i.onload = function () {
var t, o;
return t = new Uint8Array(i.response || i.mozResponseArrayBuffer), o = new e(t), 'function' == typeof (null != n ? n.getContext : void 0) && o.render(n), 'function' == typeof r ? r(o) : void 0;
}, i.send(null);
}, o = 0, i = 1, s = 2, r = 0, n = 1, e.prototype.read = function (t) {
var e, n, r;
for (r = [], e = n = 0; t >= 0 ? t > n : n > t; e = t >= 0 ? ++n : --n)
r.push(this.data[this.pos++]);
return r;
}, e.prototype.readUInt32 = function () {
var t, e, n, r;
return t = this.data[this.pos++] << 24, e = this.data[this.pos++] << 16, n = this.data[this.pos++] << 8, r = this.data[this.pos++], t | e | n | r;
}, e.prototype.readUInt16 = function () {
var t, e;
return t = this.data[this.pos++] << 8, e = this.data[this.pos++], t | e;
}, e.prototype.decodePixels = function (t) {
var e, n, r, i, o, s, a, c, u, l, h, d, f, p, m, g, w, y, v, b, x, k, A;
if (null == t && (t = this.imgData), 0 === t.length)
return new Uint8Array(0);
for (t = new FlateStream(t), t = t.getBytes(), d = this.pixelBitlength / 8, g = d * this.width, f = new Uint8Array(g * this.height), s = t.length, m = 0, p = 0, n = 0; s > p;) {
switch (t[p++]) {
case 0:
for (i = v = 0; g > v; i = v += 1)
f[n++] = t[p++];
break;
case 1:
for (i = b = 0; g > b; i = b += 1)
e = t[p++], o = d > i ? 0 : f[n - d], f[n++] = (e + o) % 256;
break;
case 2:
for (i = x = 0; g > x; i = x += 1)
e = t[p++], r = (i - i % d) / d, w = m && f[(m - 1) * g + r * d + i % d], f[n++] = (w + e) % 256;
break;
case 3:
for (i = k = 0; g > k; i = k += 1)
e = t[p++], r = (i - i % d) / d, o = d > i ? 0 : f[n - d], w = m && f[(m - 1) * g + r * d + i % d], f[n++] = (e + Math.floor((o + w) / 2)) % 256;
break;
case 4:
for (i = A = 0; g > A; i = A += 1)
e = t[p++], r = (i - i % d) / d, o = d > i ? 0 : f[n - d], 0 === m ? w = y = 0 : (w = f[(m - 1) * g + r * d + i % d], y = r && f[(m - 1) * g + (r - 1) * d + i % d]), a = o + w - y, c = Math.abs(a - o), l = Math.abs(a - w), h = Math.abs(a - y), u = l >= c && h >= c ? o : h >= l ? w : y, f[n++] = (e + u) % 256;
break;
default:
throw new Error('Invalid filter algorithm: ' + t[p - 1]);
}
m++;
}
return f;
}, e.prototype.decodePalette = function () {
var t, e, n, r, i, o, s, a, c, u;
for (r = this.palette, s = this.transparency.indexed || [], o = new Uint8Array((s.length || 0) + r.length), i = 0, n = r.length, t = 0, e = a = 0, c = r.length; c > a; e = a += 3)
o[i++] = r[e], o[i++] = r[e + 1], o[i++] = r[e + 2], o[i++] = null != (u = s[t++]) ? u : 255;
return o;
}, e.prototype.copyToImageData = function (t, e) {
var n, r, i, o, s, a, c, u, l, h, d;
if (r = this.colors, l = null, n = this.hasAlphaChannel, this.palette.length && (l = null != (d = this._decodedPalette) ? d : this._decodedPalette = this.decodePalette(), r = 4, n = !0), i = t.data || t, u = i.length, s = l || e, o = a = 0, 1 === r)
for (; u > o;)
c = l ? 4 * e[o / 4] : a, h = s[c++], i[o++] = h, i[o++] = h, i[o++] = h, i[o++] = n ? s[c++] : 255, a = c;
else
for (; u > o;)
c = l ? 4 * e[o / 4] : a, i[o++] = s[c++], i[o++] = s[c++], i[o++] = s[c++], i[o++] = n ? s[c++] : 255, a = c;
}, e.prototype.decode = function () {
var t;
return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t;
};
try {
c = t.document.createElement('canvas'), u = c.getContext('2d');
} catch (l) {
return -1;
}
return a = function (t) {
var e;
return u.width = t.width, u.height = t.height, u.clearRect(0, 0, t.width, t.height), u.putImageData(t, 0, 0), e = new Image(), e.src = c.toDataURL(), e;
}, e.prototype.decodeFrames = function (t) {
var e, n, r, i, o, s, c, u;
if (this.animation) {
for (c = this.animation.frames, u = [], n = o = 0, s = c.length; s > o; n = ++o)
e = c[n], r = t.createImageData(e.width, e.height), i = this.decodePixels(new Uint8Array(e.data)), this.copyToImageData(r, i), e.imageData = r, u.push(e.image = a(r));
return u;
}
}, e.prototype.renderFrame = function (t, e) {
var n, o, a;
return o = this.animation.frames, n = o[e], a = o[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), (null != a ? a.disposeOp : void 0) === i ? t.clearRect(a.xOffset, a.yOffset, a.width, a.height) : (null != a ? a.disposeOp : void 0) === s && t.putImageData(a.imageData, a.xOffset, a.yOffset), n.blendOp === r && t.clearRect(n.xOffset, n.yOffset, n.width, n.height), t.drawImage(n.image, n.xOffset, n.yOffset);
}, e.prototype.animate = function (t) {
var e, n, r, i, o, s, a = this;
return n = 0, s = this.animation, i = s.numFrames, r = s.frames, o = s.numPlays, (e = function () {
var s, c;
return s = n++ % i, c = r[s], a.renderFrame(t, s), i > 1 && o > n / i ? a.animation._timeout = setTimeout(e, c.delay) : void 0;
})();
}, e.prototype.stopAnimation = function () {
var t;
return clearTimeout(null != (t = this.animation) ? t._timeout : void 0);
}, e.prototype.render = function (t) {
var e, n;
return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext('2d'), this.animation ? (this.decodeFrames(e), this.animate(e)) : (n = e.createImageData(this.width, this.height), this.copyToImageData(n, this.decodePixels()), e.putImageData(n, 0, 0));
}, e;
}(), t.PNG = e;
}('undefined' != typeof window && window || this);
var DecodeStream = function () {
function t() {
this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = null;
}
return t.prototype = {
ensureBuffer: function (t) {
var e = this.buffer, n = e ? e.byteLength : 0;
if (n > t)
return e;
for (var r = 512; t > r;)
r <<= 1;
for (var i = new Uint8Array(r), o = 0; n > o; ++o)
i[o] = e[o];
return this.buffer = i;
},
getByte: function () {
for (var t = this.pos; this.bufferLength <= t;) {
if (this.eof)
return null;
this.readBlock();
}
return this.buffer[this.pos++];
},
getBytes: function (t) {
var e = this.pos;
if (t) {
this.ensureBuffer(e + t);
for (var n = e + t; !this.eof && this.bufferLength < n;)
this.readBlock();
var r = this.bufferLength;
n > r && (n = r);
} else {
for (; !this.eof;)
this.readBlock();
var n = this.bufferLength;
}
return this.pos = n, this.buffer.subarray(e, n);
},
lookChar: function () {
for (var t = this.pos; this.bufferLength <= t;) {
if (this.eof)
return null;
this.readBlock();
}
return String.fromCharCode(this.buffer[this.pos]);
},
getChar: function () {
for (var t = this.pos; this.bufferLength <= t;) {
if (this.eof)
return null;
this.readBlock();
}
return String.fromCharCode(this.buffer[this.pos++]);
},
makeSubStream: function (t, e, n) {
for (var r = t + e; this.bufferLength <= r && !this.eof;)
this.readBlock();
return new Stream(this.buffer, t, e, n);
},
skip: function (t) {
t || (t = 1), this.pos += t;
},
reset: function () {
this.pos = 0;
}
}, t;
}(), FlateStream = function () {
function t(t) {
throw new Error(t);
}
function e(e) {
var n = 0, r = e[n++], i = e[n++];
-1 != r && -1 != i || t('Invalid header in flate stream'), 8 != (15 & r) && t('Unknown compression method in flate stream'), ((r << 8) + i) % 31 != 0 && t('Bad FCHECK in flate stream'), 32 & i && t('FDICT bit set in flate stream'), this.bytes = e, this.bytesPos = n, this.codeSize = 0, this.codeBuf = 0, DecodeStream.call(this);
}
if ('undefined' != typeof Uint32Array) {
var n = new Uint32Array([
16,
17,
18,
0,
8,
7,
9,
6,
10,
5,
11,
4,
12,
3,
13,
2,
14,
1,
15
]), r = new Uint32Array([
3,
4,
5,
6,
7,
8,
9,
10,
65547,
65549,
65551,
65553,
131091,
131095,
131099,
131103,
196643,
196651,
196659,
196667,
262211,
262227,
262243,
262259,
327811,
327843,
327875,
327907,
258,
258,
258
]), i = new Uint32Array([
1,
2,
3,
4,
65541,
65543,
131081,
131085,
196625,
196633,
262177,
262193,
327745,
327777,
393345,
393409,
459009,
459137,
524801,
525057,
590849,
591361,
657409,
658433,
724993,
727041,
794625,
798721,
868353,
876545
]), o = [
new Uint32Array([
459008,
524368,
524304,
524568,
459024,
524400,
524336,
590016,
459016,
524384,
524320,
589984,
524288,
524416,
524352,
590048,
459012,
524376,
524312,
589968,
459028,
524408,
524344,
590032,
459020,
524392,
524328,
590000,
524296,
524424,
524360,
590064,
459010,
524372,
524308,
524572,
459026,
524404,
524340,
590024,
459018,
524388,
524324,
589992,
524292,
524420,
524356,
590056,
459014,
524380,
524316,
589976,
459030,
524412,
524348,
590040,
459022,
524396,
524332,
590008,
524300,
524428,
524364,
590072,
459009,
524370,
524306,
524570,
459025,
524402,
524338,
590020,
459017,
524386,
524322,
589988,
524290,
524418,
524354,
590052,
459013,
524378,
524314,
589972,
459029,
524410,
524346,
590036,
459021,
524394,
524330,
590004,
524298,
524426,
524362,
590068,
459011,
524374,
524310,
524574,
459027,
524406,
524342,
590028,
459019,
524390,
524326,
589996,
524294,
524422,
524358,
590060,
459015,
524382,
524318,
589980,
459031,
524414,
524350,
590044,
459023,
524398,
524334,
590012,
524302,
524430,
524366,
590076,
459008,
524369,
524305,
524569,
459024,
524401,
524337,
590018,
459016,
524385,
524321,
589986,
524289,
524417,
524353,
590050,
459012,
524377,
524313,
589970,
459028,
524409,
524345,
590034,
459020,
524393,
524329,
590002,
524297,
524425,
524361,
590066,
459010,
524373,
524309,
524573,
459026,
524405,
524341,
590026,
459018,
524389,
524325,
589994,
524293,
524421,
524357,
590058,
459014,
524381,
524317,
589978,
459030,
524413,
524349,
590042,
459022,
524397,
524333,
590010,
524301,
524429,
524365,
590074,
459009,
524371,
524307,
524571,
459025,
524403,
524339,
590022,
459017,
524387,
524323,
589990,
524291,
524419,
524355,
590054,
459013,
524379,
524315,
589974,
459029,
524411,
524347,
590038,
459021,
524395,
524331,
590006,
524299,
524427,
524363,
590070,
459011,
524375,
524311,
524575,
459027,
524407,
524343,
590030,
459019,
524391,
524327,
589998,
524295,
524423,
524359,
590062,
459015,
524383,
524319,
589982,
459031,
524415,
524351,
590046,
459023,
524399,
524335,
590014,
524303,
524431,
524367,
590078,
459008,
524368,
524304,
524568,
459024,
524400,
524336,
590017,
459016,
524384,
524320,
589985,
524288,
524416,
524352,
590049,
459012,
524376,
524312,
589969,
459028,
524408,
524344,
590033,
459020,
524392,
524328,
590001,
524296,
524424,
524360,
590065,
459010,
524372,
524308,
524572,
459026,
524404,
524340,
590025,
459018,
524388,
524324,
589993,
524292,
524420,
524356,
590057,
459014,
524380,
524316,
589977,
459030,
524412,
524348,
590041,
459022,
524396,
524332,
590009,
524300,
524428,
524364,
590073,
459009,
524370,
524306,
524570,
459025,
524402,
524338,
590021,
459017,
524386,
524322,
589989,
524290,
524418,
524354,
590053,
459013,
524378,
524314,
589973,
459029,
524410,
524346,
590037,
459021,
524394,
524330,
590005,
524298,
524426,
524362,
590069,
459011,
524374,
524310,
524574,
459027,
524406,
524342,
590029,
459019,
524390,
524326,
589997,
524294,
524422,
524358,
590061,
459015,
524382,
524318,
589981,
459031,
524414,
524350,
590045,
459023,
524398,
524334,
590013,
524302,
524430,
524366,
590077,
459008,
524369,
524305,
524569,
459024,
524401,
524337,
590019,
459016,
524385,
524321,
589987,
524289,
524417,
524353,
590051,
459012,
524377,
524313,
589971,
459028,
524409,
524345,
590035,
459020,
524393,
524329,
590003,
524297,
524425,
524361,
590067,
459010,
524373,
524309,
524573,
459026,
524405,
524341,
590027,
459018,
524389,
524325,
589995,
524293,
524421,
524357,
590059,
459014,
524381,
524317,
589979,
459030,
524413,
524349,
590043,
459022,
524397,
524333,
590011,
524301,
524429,
524365,
590075,
459009,
524371,
524307,
524571,
459025,
524403,
524339,
590023,
459017,
524387,
524323,
589991,
524291,
524419,
524355,
590055,
459013,
524379,
524315,
589975,
459029,
524411,
524347,
590039,
459021,
524395,
524331,
590007,
524299,
524427,
524363,
590071,
459011,
524375,
524311,
524575,
459027,
524407,
524343,
590031,
459019,
524391,
524327,
589999,
524295,
524423,
524359,
590063,
459015,
524383,
524319,
589983,
459031,
524415,
524351,
590047,
459023,
524399,
524335,
590015,
524303,
524431,
524367,
590079
]),
9
], s = [
new Uint32Array([
327680,
327696,
327688,
327704,
327684,
327700,
327692,
327708,
327682,
327698,
327690,
327706,
327686,
327702,
327694,
0,
327681,
327697,
327689,
327705,
327685,
327701,
327693,
327709,
327683,
327699,
327691,
327707,
327687,
327703,
327695,
0
]),
5
];
return e.prototype = Object.create(DecodeStream.prototype), e.prototype.getBits = function (e) {
for (var n, r = this.codeSize, i = this.codeBuf, o = this.bytes, s = this.bytesPos; e > r;)
'undefined' == typeof (n = o[s++]) && t('Bad encoding in flate stream'), i |= n << r, r += 8;
return n = i & (1 << e) - 1, this.codeBuf = i >> e, this.codeSize = r -= e, this.bytesPos = s, n;
}, e.prototype.getCode = function (e) {
for (var n = e[0], r = e[1], i = this.codeSize, o = this.codeBuf, s = this.bytes, a = this.bytesPos; r > i;) {
var c;
'undefined' == typeof (c = s[a++]) && t('Bad encoding in flate stream'), o |= c << i, i += 8;
}
var u = n[o & (1 << r) - 1], l = u >> 16, h = 65535 & u;
return (0 == i || l > i || 0 == l) && t('Bad encoding in flate stream'), this.codeBuf = o >> l, this.codeSize = i - l, this.bytesPos = a, h;
}, e.prototype.generateHuffmanTable = function (t) {
for (var e = t.length, n = 0, r = 0; e > r; ++r)
t[r] > n && (n = t[r]);
for (var i = 1 << n, o = new Uint32Array(i), s = 1, a = 0, c = 2; n >= s; ++s, a <<= 1, c <<= 1)
for (var u = 0; e > u; ++u)
if (t[u] == s) {
for (var l = 0, h = a, r = 0; s > r; ++r)
l = l << 1 | 1 & h, h >>= 1;
for (var r = l; i > r; r += c)
o[r] = s << 16 | u;
++a;
}
return [
o,
n
];
}, e.prototype.readBlock = function () {
function e(t, e, n, r, i) {
for (var o = t.getBits(n) + r; o-- > 0;)
e[A++] = i;
}
var a = this.getBits(3);
if (1 & a && (this.eof = !0), a >>= 1, 0 == a) {
var c, u = this.bytes, l = this.bytesPos;
'undefined' == typeof (c = u[l++]) && t('Bad block header in flate stream');
var h = c;
'undefined' == typeof (c = u[l++]) && t('Bad block header in flate stream'), h |= c << 8, 'undefined' == typeof (c = u[l++]) && t('Bad block header in flate stream');
var d = c;
'undefined' == typeof (c = u[l++]) && t('Bad block header in flate stream'), d |= c << 8, d != (65535 & ~h) && t('Bad uncompressed block length in flate stream'), this.codeBuf = 0, this.codeSize = 0;
var f = this.bufferLength, p = this.ensureBuffer(f + h), m = f + h;
this.bufferLength = m;
for (var g = f; m > g; ++g) {
if ('undefined' == typeof (c = u[l++])) {
this.eof = !0;
break;
}
p[g] = c;
}
return void (this.bytesPos = l);
}
var w, y;
if (1 == a)
w = o, y = s;
else if (2 == a) {
for (var v = this.getBits(5) + 257, b = this.getBits(5) + 1, x = this.getBits(4) + 4, k = Array(n.length), A = 0; x > A;)
k[n[A++]] = this.getBits(3);
for (var C = this.generateHuffmanTable(k), E = 0, A = 0, S = v + b, F = new Array(S); S > A;) {
var T = this.getCode(C);
16 == T ? e(this, F, 2, 3, E) : 17 == T ? e(this, F, 3, 3, E = 0) : 18 == T ? e(this, F, 7, 11, E = 0) : F[A++] = E = T;
}
w = this.generateHuffmanTable(F.slice(0, v)), y = this.generateHuffmanTable(F.slice(v, S));
} else
t('Unknown block type in flate stream');
for (var p = this.buffer, P = p ? p.length : 0, _ = this.bufferLength;;) {
var I = this.getCode(w);
if (256 > I)
_ + 1 >= P && (p = this.ensureBuffer(_ + 1), P = p.length), p[_++] = I;
else {
if (256 == I)
return void (this.bufferLength = _);
I -= 257, I = r[I];
var q = I >> 16;
q > 0 && (q = this.getBits(q));
var E = (65535 & I) + q;
I = this.getCode(y), I = i[I], q = I >> 16, q > 0 && (q = this.getBits(q));
var O = (65535 & I) + q;
_ + E >= P && (p = this.ensureBuffer(_ + E), P = p.length);
for (var R = 0; E > R; ++R, ++_)
p[_] = p[_ - O];
}
}
}, e;
}
}();
!function (t) {
var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
'undefined' == typeof t.btoa && (t.btoa = function (t) {
var n, r, i, o, s, a, c, u, l = 0, h = 0, d = '', f = [];
if (!t)
return t;
do
n = t.charCodeAt(l++), r = t.charCodeAt(l++), i = t.charCodeAt(l++), u = n << 16 | r << 8 | i, o = u >> 18 & 63, s = u >> 12 & 63, a = u >> 6 & 63, c = 63 & u, f[h++] = e.charAt(o) + e.charAt(s) + e.charAt(a) + e.charAt(c);
while (l < t.length);
d = f.join('');
var p = t.length % 3;
return (p ? d.slice(0, p - 3) : d) + '==='.slice(p || 3);
}), 'undefined' == typeof t.atob && (t.atob = function (t) {
var n, r, i, o, s, a, c, u, l = 0, h = 0, d = '', f = [];
if (!t)
return t;
t += '';
do
o = e.indexOf(t.charAt(l++)), s = e.indexOf(t.charAt(l++)), a = e.indexOf(t.charAt(l++)), c = e.indexOf(t.charAt(l++)), u = o << 18 | s << 12 | a << 6 | c, n = u >> 16 & 255, r = u >> 8 & 255, i = 255 & u, 64 == a ? f[h++] = String.fromCharCode(n) : 64 == c ? f[h++] = String.fromCharCode(n, r) : f[h++] = String.fromCharCode(n, r, i);
while (l < t.length);
return d = f.join('');
}), Array.prototype.map || (Array.prototype.map = function (t) {
if (void 0 === this || null === this || 'function' != typeof t)
throw new TypeError();
for (var e = Object(this), n = e.length >>> 0, r = new Array(n), i = arguments.length > 1 ? arguments[1] : void 0, o = 0; n > o; o++)
o in e && (r[o] = t.call(i, e[o], o, e));
return r;
}), Array.isArray || (Array.isArray = function (t) {
return '[object Array]' === Object.prototype.toString.call(t);
}), Array.prototype.forEach || (Array.prototype.forEach = function (t, e) {
'use strict';
if (void 0 === this || null === this || 'function' != typeof t)
throw new TypeError();
for (var n = Object(this), r = n.length >>> 0, i = 0; r > i; i++)
i in n && t.call(e, n[i], i, n);
}), Object.keys || (Object.keys = function () {
'use strict';
var t = Object.prototype.hasOwnProperty, e = !{ toString: null }.propertyIsEnumerable('toString'), n = [
'toString',
'toLocaleString',
'valueOf',
'hasOwnProperty',
'isPrototypeOf',
'propertyIsEnumerable',
'constructor'
], r = n.length;
return function (i) {
if ('object' != typeof i && ('function' != typeof i || null === i))
throw new TypeError();
var o, s, a = [];
for (o in i)
t.call(i, o) && a.push(o);
if (e)
for (s = 0; r > s; s++)
t.call(i, n[s]) && a.push(n[s]);
return a;
};
}()), String.prototype.trim || (String.prototype.trim = function () {
return this.replace(/^\s+|\s+$/g, '');
}), String.prototype.trimLeft || (String.prototype.trimLeft = function () {
return this.replace(/^\s+/g, '');
}), String.prototype.trimRight || (String.prototype.trimRight = function () {
return this.replace(/\s+$/g, '');
});
}('undefined' != typeof self && self || 'undefined' != typeof window && window || this), 'object' == typeof require && ('undefined' == typeof require_baseUrl_override && (require_baseUrl_override = '../'), require.config({
baseUrl: require_baseUrl_override,
shim: {
'plugins/standard_fonts_metrics': { deps: ['jspdf'] },
'plugins/split_text_to_size': { deps: ['jspdf'] },
'plugins/annotations': {
deps: [
'jspdf',
'plugins/standard_fonts_metrics',
'plugins/split_text_to_size'
]
},
'plugins/outline': { deps: ['jspdf'] },
'plugins/addimage': { deps: ['jspdf'] },
'plugins/png_support': {
deps: [
'jspdf',
'libs/png_support/png',
'libs/png_support/zlib'
]
},
'plugins/from_html': { deps: ['jspdf'] },
'plugins/context2d': {
deps: [
'jspdf',
'plugins/png_support',
'plugins/addimage',
'libs/css_colors'
]
},
'libs/html2canvas/dist/html2canvas': { deps: ['jspdf'] },
'plugins/canvas': { deps: ['jspdf'] },
'plugins/acroform': {
deps: [
'jspdf',
'plugins/annotations'
]
},
html2pdf: {
deps: [
'jspdf',
'plugins/standard_fonts_metrics',
'plugins/split_text_to_size',
'plugins/png_support',
'plugins/context2d',
'plugins/canvas',
'plugins/annotations',
'libs/html2canvas/dist/html2canvas'
]
},
'test/test_harness': {
deps: [
'jspdf',
'jspdf.plugin.standard_fonts_metrics',
'jspdf.plugin.split_text_to_size'
]
}
},
paths: { html2pdf: 'libs/html2pdf' }
}));
var requirejs, require, define;
!function (global) {
function isFunction(t) {
return '[object Function]' === ostring.call(t);
}
function isArray(t) {
return '[object Array]' === ostring.call(t);
}
function each(t, e) {
if (t) {
var n;
for (n = 0; n < t.length && (!t[n] || !e(t[n], n, t)); n += 1);
}
}
function eachReverse(t, e) {
if (t) {
var n;
for (n = t.length - 1; n > -1 && (!t[n] || !e(t[n], n, t)); n -= 1);
}
}
function hasProp(t, e) {
return hasOwn.call(t, e);
}
function getOwn(t, e) {
return hasProp(t, e) && t[e];
}
function eachProp(t, e) {
var n;
for (n in t)
if (hasProp(t, n) && e(t[n], n))
break;
}
function mixin(t, e, n, r) {
return e && eachProp(e, function (e, i) {
!n && hasProp(t, i) || (!r || 'object' != typeof e || !e || isArray(e) || isFunction(e) || e instanceof RegExp ? t[i] = e : (t[i] || (t[i] = {}), mixin(t[i], e, n, r)));
}), t;
}
function bind(t, e) {
return function () {
return e.apply(t, arguments);
};
}
function scripts() {
return document.getElementsByTagName('script');
}
function defaultOnError(t) {
throw t;
}
function getGlobal(t) {
if (!t)
return t;
var e = global;
return each(t.split('.'), function (t) {
e = e[t];
}), e;
}
function makeError(t, e, n, r) {
var i = new Error(e + '\nhttp://requirejs.org/docs/errors.html#' + t);
return i.requireType = t, i.requireModules = r, n && (i.originalError = n), i;
}
function newContext(t) {
function e(t) {
var e, n;
for (e = 0; e < t.length; e++)
if (n = t[e], '.' === n)
t.splice(e, 1), e -= 1;
else if ('..' === n) {
if (0 === e || 1 == e && '..' === t[2] || '..' === t[e - 1])
continue;
e > 0 && (t.splice(e - 1, 2), e -= 2);
}
}
function n(t, n, r) {
var i, o, s, a, c, u, l, h, d, f, p, m, g = n && n.split('/'), w = A.map, y = w && w['*'];
if (t && (t = t.split('/'), l = t.length - 1, A.nodeIdCompat && jsSuffixRegExp.test(t[l]) && (t[l] = t[l].replace(jsSuffixRegExp, '')), '.' === t[0].charAt(0) && g && (m = g.slice(0, g.length - 1), t = m.concat(t)), e(t), t = t.join('/')), r && w && (g || y)) {
s = t.split('/');
t:
for (a = s.length; a > 0; a -= 1) {
if (u = s.slice(0, a).join('/'), g)
for (c = g.length; c > 0; c -= 1)
if (o = getOwn(w, g.slice(0, c).join('/')), o && (o = getOwn(o, u))) {
h = o, d = a;
break t;
}
!f && y && getOwn(y, u) && (f = getOwn(y, u), p = a);
}
!h && f && (h = f, d = p), h && (s.splice(0, d, h), t = s.join('/'));
}
return i = getOwn(A.pkgs, t), i ? i : t;
}
function r(t) {
isBrowser && each(scripts(), function (e) {
return e.getAttribute('data-requiremodule') === t && e.getAttribute('data-requirecontext') === b.contextName ? (e.parentNode.removeChild(e), !0) : void 0;
});
}
function i(t) {
var e = getOwn(A.paths, t);
return e && isArray(e) && e.length > 1 ? (e.shift(), b.require.undef(t), b.makeRequire(null, { skipMap: !0 })([t]), !0) : void 0;
}
function o(t) {
var e, n = t ? t.indexOf('!') : -1;
return n > -1 && (e = t.substring(0, n), t = t.substring(n + 1, t.length)), [
e,
t
];
}
function s(t, e, r, i) {
var s, a, c, u, l = null, h = e ? e.name : null, d = t, f = !0, p = '';
return t || (f = !1, t = '_@r' + (I += 1)), u = o(t), l = u[0], t = u[1], l && (l = n(l, h, i), a = getOwn(T, l)), t && (l ? p = a && a.normalize ? a.normalize(t, function (t) {
return n(t, h, i);
}) : -1 === t.indexOf('!') ? n(t, h, i) : t : (p = n(t, h, i), u = o(p), l = u[0], p = u[1], r = !0, s = b.nameToUrl(p))), c = !l || a || r ? '' : '_unnormalized' + (q += 1), {
prefix: l,
name: p,
parentMap: e,
unnormalized: !!c,
url: s,
originalName: d,
isDefine: f,
id: (l ? l + '!' + p : p) + c
};
}
function a(t) {
var e = t.id, n = getOwn(C, e);
return n || (n = C[e] = new b.Module(t)), n;
}
function c(t, e, n) {
var r = t.id, i = getOwn(C, r);
!hasProp(T, r) || i && !i.defineEmitComplete ? (i = a(t), i.error && 'error' === e ? n(i.error) : i.on(e, n)) : 'defined' === e && n(T[r]);
}
function u(t, e) {
var n = t.requireModules, r = !1;
e ? e(t) : (each(n, function (e) {
var n = getOwn(C, e);
n && (n.error = t, n.events.error && (r = !0, n.emit('error', t)));
}), r || req.onError(t));
}
function l() {
globalDefQueue.length && (apsp.apply(F, [
F.length,
0
].concat(globalDefQueue)), globalDefQueue = []);
}
function h(t) {
delete C[t], delete E[t];
}
function d(t, e, n) {
var r = t.map.id;
t.error ? t.emit('error', t.error) : (e[r] = !0, each(t.depMaps, function (r, i) {
var o = r.id, s = getOwn(C, o);
!s || t.depMatched[i] || n[o] || (getOwn(e, o) ? (t.defineDep(i, T[o]), t.check()) : d(s, e, n));
}), n[r] = !0);
}
function f() {
var t, e, n = 1000 * A.waitSeconds, o = n && b.startTime + n < new Date().getTime(), s = [], a = [], c = !1, l = !0;
if (!y) {
if (y = !0, eachProp(E, function (t) {
var n = t.map, u = n.id;
if (t.enabled && (n.isDefine || a.push(t), !t.error))
if (!t.inited && o)
i(u) ? (e = !0, c = !0) : (s.push(u), r(u));
else if (!t.inited && t.fetched && n.isDefine && (c = !0, !n.prefix))
return l = !1;
}), o && s.length)
return t = makeError('timeout', 'Load timeout for modules: ' + s, null, s), t.contextName = b.contextName, u(t);
l && each(a, function (t) {
d(t, {}, {});
}), o && !e || !c || !isBrowser && !isWebWorker || k || (k = setTimeout(function () {
k = 0, f();
}, 50)), y = !1;
}
}
function p(t) {
hasProp(T, t[0]) || a(s(t[0], null, !0)).init(t[1], t[2]);
}
function m(t, e, n, r) {
t.detachEvent && !isOpera ? r && t.detachEvent(r, e) : t.removeEventListener(n, e, !1);
}
function g(t) {
var e = t.currentTarget || t.srcElement;
return m(e, b.onScriptLoad, 'load', 'onreadystatechange'), m(e, b.onScriptError, 'error'), {
node: e,
id: e && e.getAttribute('data-requiremodule')
};
}
function w() {
var t;
for (l(); F.length;) {
if (t = F.shift(), null === t[0])
return u(makeError('mismatch', 'Mismatched anonymous define() module: ' + t[t.length - 1]));
p(t);
}
}
var y, v, b, x, k, A = {
waitSeconds: 7,
baseUrl: './',
paths: {},
bundles: {},
pkgs: {},
shim: {},
config: {}
}, C = {}, E = {}, S = {}, F = [], T = {}, P = {}, _ = {}, I = 1, q = 1;
return x = {
require: function (t) {
return t.require ? t.require : t.require = b.makeRequire(t.map);
},
exports: function (t) {
return t.usingExports = !0, t.map.isDefine ? t.exports ? T[t.map.id] = t.exports : t.exports = T[t.map.id] = {} : void 0;
},
module: function (t) {
return t.module ? t.module : t.module = {
id: t.map.id,
uri: t.map.url,
config: function () {
return getOwn(A.config, t.map.id) || {};
},
exports: t.exports || (t.exports = {})
};
}
}, v = function (t) {
this.events = getOwn(S, t.id) || {}, this.map = t, this.shim = getOwn(A.shim, t.id), this.depExports = [], this.depMaps = [], this.depMatched = [], this.pluginMaps = {}, this.depCount = 0;
}, v.prototype = {
init: function (t, e, n, r) {
r = r || {}, this.inited || (this.factory = e, n ? this.on('error', n) : this.events.error && (n = bind(this, function (t) {
this.emit('error', t);
})), this.depMaps = t && t.slice(0), this.errback = n, this.inited = !0, this.ignore = r.ignore, r.enabled || this.enabled ? this.enable() : this.check());
},
defineDep: function (t, e) {
this.depMatched[t] || (this.depMatched[t] = !0, this.depCount -= 1, this.depExports[t] = e);
},
fetch: function () {
if (!this.fetched) {
this.fetched = !0, b.startTime = new Date().getTime();
var t = this.map;
return this.shim ? void b.makeRequire(this.map, { enableBuildCallback: !0 })(this.shim.deps || [], bind(this, function () {
return t.prefix ? this.callPlugin() : this.load();
})) : t.prefix ? this.callPlugin() : this.load();
}
},
load: function () {
var t = this.map.url;
P[t] || (P[t] = !0, b.load(this.map.id, t));
},
check: function () {
if (this.enabled && !this.enabling) {
var t, e, n = this.map.id, r = this.depExports, i = this.exports, o = this.factory;
if (this.inited) {
if (this.error)
this.emit('error', this.error);
else if (!this.defining) {
if (this.defining = !0, this.depCount < 1 && !this.defined) {
if (isFunction(o)) {
if (this.events.error && this.map.isDefine || req.onError !== defaultOnError)
try {
i = b.execCb(n, o, r, i);
} catch (s) {
t = s;
}
else
i = b.execCb(n, o, r, i);
if (this.map.isDefine && void 0 === i && (e = this.module, e ? i = e.exports : this.usingExports && (i = this.exports)), t)
return t.requireMap = this.map, t.requireModules = this.map.isDefine ? [this.map.id] : null, t.requireType = this.map.isDefine ? 'define' : 'require', u(this.error = t);
} else
i = o;
this.exports = i, this.map.isDefine && !this.ignore && (T[n] = i, req.onResourceLoad && req.onResourceLoad(b, this.map, this.depMaps)), h(n), this.defined = !0;
}
this.defining = !1, this.defined && !this.defineEmitted && (this.defineEmitted = !0, this.emit('defined', this.exports), this.defineEmitComplete = !0);
}
} else
this.fetch();
}
},
callPlugin: function () {
var t = this.map, e = t.id, r = s(t.prefix);
this.depMaps.push(r), c(r, 'defined', bind(this, function (r) {
var i, o, l, d = getOwn(_, this.map.id), f = this.map.name, p = this.map.parentMap ? this.map.parentMap.name : null, m = b.makeRequire(t.parentMap, { enableBuildCallback: !0 });
return this.map.unnormalized ? (r.normalize && (f = r.normalize(f, function (t) {
return n(t, p, !0);
}) || ''), o = s(t.prefix + '!' + f, this.map.parentMap), c(o, 'defined', bind(this, function (t) {
this.init([], function () {
return t;
}, null, {
enabled: !0,
ignore: !0
});
})), l = getOwn(C, o.id), void (l && (this.depMaps.push(o), this.events.error && l.on('error', bind(this, function (t) {
this.emit('error', t);
})), l.enable()))) : d ? (this.map.url = b.nameToUrl(d), void this.load()) : (i = bind(this, function (t) {
this.init([], function () {
return t;
}, null, { enabled: !0 });
}), i.error = bind(this, function (t) {
this.inited = !0, this.error = t, t.requireModules = [e], eachProp(C, function (t) {
0 === t.map.id.indexOf(e + '_unnormalized') && h(t.map.id);
}), u(t);
}), i.fromText = bind(this, function (n, r) {
var o = t.name, c = s(o), l = useInteractive;
r && (n = r), l && (useInteractive = !1), a(c), hasProp(A.config, e) && (A.config[o] = A.config[e]);
try {
req.exec(n);
} catch (h) {
return u(makeError('fromtexteval', 'fromText eval for ' + e + ' failed: ' + h, h, [e]));
}
l && (useInteractive = !0), this.depMaps.push(c), b.completeLoad(o), m([o], i);
}), void r.load(t.name, m, i, A));
})), b.enable(r, this), this.pluginMaps[r.id] = r;
},
enable: function () {
E[this.map.id] = this, this.enabled = !0, this.enabling = !0, each(this.depMaps, bind(this, function (t, e) {
var n, r, i;
if ('string' == typeof t) {
if (t = s(t, this.map.isDefine ? this.map : this.map.parentMap, !1, !this.skipMap), this.depMaps[e] = t, i = getOwn(x, t.id))
return void (this.depExports[e] = i(this));
this.depCount += 1, c(t, 'defined', bind(this, function (t) {
this.defineDep(e, t), this.check();
})), this.errback && c(t, 'error', bind(this, this.errback));
}
n = t.id, r = C[n], hasProp(x, n) || !r || r.enabled || b.enable(t, this);
})), eachProp(this.pluginMaps, bind(this, function (t) {
var e = getOwn(C, t.id);
e && !e.enabled && b.enable(t, this);
})), this.enabling = !1, this.check();
},
on: function (t, e) {
var n = this.events[t];
n || (n = this.events[t] = []), n.push(e);
},
emit: function (t, e) {
each(this.events[t], function (t) {
t(e);
}), 'error' === t && delete this.events[t];
}
}, b = {
config: A,
contextName: t,
registry: C,
defined: T,
urlFetched: P,
defQueue: F,
Module: v,
makeModuleMap: s,
nextTick: req.nextTick,
onError: u,
configure: function (t) {
t.baseUrl && '/' !== t.baseUrl.charAt(t.baseUrl.length - 1) && (t.baseUrl += '/');
var e = A.shim, n = {
paths: !0,
bundles: !0,
config: !0,
map: !0
};
eachProp(t, function (t, e) {
n[e] ? (A[e] || (A[e] = {}), mixin(A[e], t, !0, !0)) : A[e] = t;
}), t.bundles && eachProp(t.bundles, function (t, e) {
each(t, function (t) {
t !== e && (_[t] = e);
});
}), t.shim && (eachProp(t.shim, function (t, n) {
isArray(t) && (t = { deps: t }), !t.exports && !t.init || t.exportsFn || (t.exportsFn = b.makeShimExports(t)), e[n] = t;
}), A.shim = e), t.packages && each(t.packages, function (t) {
var e, n;
t = 'string' == typeof t ? { name: t } : t, n = t.name, e = t.location, e && (A.paths[n] = t.location), A.pkgs[n] = t.name + '/' + (t.main || 'main').replace(currDirRegExp, '').replace(jsSuffixRegExp, '');
}), eachProp(C, function (t, e) {
t.inited || t.map.unnormalized || (t.map = s(e));
}), (t.deps || t.callback) && b.require(t.deps || [], t.callback);
},
makeShimExports: function (t) {
function e() {
var e;
return t.init && (e = t.init.apply(global, arguments)), e || t.exports && getGlobal(t.exports);
}
return e;
},
makeRequire: function (e, i) {
function o(n, r, c) {
var l, h, d;
return i.enableBuildCallback && r && isFunction(r) && (r.__requireJsBuild = !0), 'string' == typeof n ? isFunction(r) ? u(makeError('requireargs', 'Invalid require call'), c) : e && hasProp(x, n) ? x[n](C[e.id]) : req.get ? req.get(b, n, e, o) : (h = s(n, e, !1, !0), l = h.id, hasProp(T, l) ? T[l] : u(makeError('notloaded', 'Module name "' + l + '" has not been loaded yet for context: ' + t + (e ? '' : '. Use require([])')))) : (w(), b.nextTick(function () {
w(), d = a(s(null, e)), d.skipMap = i.skipMap, d.init(n, r, c, { enabled: !0 }), f();
}), o);
}
return i = i || {}, mixin(o, {
isBrowser: isBrowser,
toUrl: function (t) {
var r, i = t.lastIndexOf('.'), o = t.split('/')[0], s = '.' === o || '..' === o;
return -1 !== i && (!s || i > 1) && (r = t.substring(i, t.length), t = t.substring(0, i)), b.nameToUrl(n(t, e && e.id, !0), r, !0);
},
defined: function (t) {
return hasProp(T, s(t, e, !1, !0).id);
},
specified: function (t) {
return t = s(t, e, !1, !0).id, hasProp(T, t) || hasProp(C, t);
}
}), e || (o.undef = function (t) {
l();
var n = s(t, e, !0), i = getOwn(C, t);
r(t), delete T[t], delete P[n.url], delete S[t], eachReverse(F, function (e, n) {
e[0] === t && F.splice(n, 1);
}), i && (i.events.defined && (S[t] = i.events), h(t));
}), o;
},
enable: function (t) {
var e = getOwn(C, t.id);
e && a(t).enable();
},
completeLoad: function (t) {
var e, n, r, o = getOwn(A.shim, t) || {}, s = o.exports;
for (l(); F.length;) {
if (n = F.shift(), null === n[0]) {
if (n[0] = t, e)
break;
e = !0;
} else
n[0] === t && (e = !0);
p(n);
}
if (r = getOwn(C, t), !e && !hasProp(T, t) && r && !r.inited) {
if (!(!A.enforceDefine || s && getGlobal(s)))
return i(t) ? void 0 : u(makeError('nodefine', 'No define call for ' + t, null, [t]));
p([
t,
o.deps || [],
o.exportsFn
]);
}
f();
},
nameToUrl: function (t, e, n) {
var r, i, o, s, a, c, u, l = getOwn(A.pkgs, t);
if (l && (t = l), u = getOwn(_, t))
return b.nameToUrl(u, e, n);
if (req.jsExtRegExp.test(t))
a = t + (e || '');
else {
for (r = A.paths, i = t.split('/'), o = i.length; o > 0; o -= 1)
if (s = i.slice(0, o).join('/'), c = getOwn(r, s)) {
isArray(c) && (c = c[0]), i.splice(0, o, c);
break;
}
a = i.join('/'), a += e || (/^data\:|\?/.test(a) || n ? '' : '.js'), a = ('/' === a.charAt(0) || a.match(/^[\w\+\.\-]+:/) ? '' : A.baseUrl) + a;
}
return A.urlArgs ? a + ((-1 === a.indexOf('?') ? '?' : '&') + A.urlArgs) : a;
},
load: function (t, e) {
req.load(b, t, e);
},
execCb: function (t, e, n, r) {
return e.apply(r, n);
},
onScriptLoad: function (t) {
if ('load' === t.type || readyRegExp.test((t.currentTarget || t.srcElement).readyState)) {
interactiveScript = null;
var e = g(t);
b.completeLoad(e.id);
}
},
onScriptError: function (t) {
var e = g(t);
return i(e.id) ? void 0 : u(makeError('scripterror', 'Script error for: ' + e.id, t, [e.id]));
}
}, b.require = b.makeRequire(), b;
}
function getInteractiveScript() {
return interactiveScript && 'interactive' === interactiveScript.readyState ? interactiveScript : (eachReverse(scripts(), function (t) {
return 'interactive' === t.readyState ? interactiveScript = t : void 0;
}), interactiveScript);
}
var req, s, head, baseElement, dataMain, src, interactiveScript, currentlyAddingScript, mainScript, subPath, version = '2.1.15', commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm, cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, jsSuffixRegExp = /\.js$/, currDirRegExp = /^\.\//, op = Object.prototype, ostring = op.toString, hasOwn = op.hasOwnProperty, ap = Array.prototype, apsp = ap.splice, isBrowser = !('undefined' == typeof window || 'undefined' == typeof navigator || !window.document), isWebWorker = !isBrowser && 'undefined' != typeof importScripts, readyRegExp = isBrowser && 'PLAYSTATION 3' === navigator.platform ? /^complete$/ : /^(complete|loaded)$/, defContextName = '_', isOpera = 'undefined' != typeof opera && '[object Opera]' === opera.toString(), contexts = {}, cfg = {}, globalDefQueue = [], useInteractive = !1;
if ('undefined' == typeof define) {
if ('undefined' != typeof requirejs) {
if (isFunction(requirejs))
return;
cfg = requirejs, requirejs = void 0;
}
'undefined' == typeof require || isFunction(require) || (cfg = require, require = void 0), req = requirejs = function (t, e, n, r) {
var i, o, s = defContextName;
return isArray(t) || 'string' == typeof t || (o = t, isArray(e) ? (t = e, e = n, n = r) : t = []), o && o.context && (s = o.context), i = getOwn(contexts, s), i || (i = contexts[s] = req.s.newContext(s)), o && i.configure(o), i.require(t, e, n);
}, req.config = function (t) {
return req(t);
}, req.nextTick = 'undefined' != typeof setTimeout ? function (t) {
setTimeout(t, 4);
} : function (t) {
t();
}, require || (require = req), req.version = version, req.jsExtRegExp = /^\/|:|\?|\.js$/, req.isBrowser = isBrowser, s = req.s = {
contexts: contexts,
newContext: newContext
}, req({}), each([
'toUrl',
'undef',
'defined',
'specified'
], function (t) {
req[t] = function () {
var e = contexts[defContextName];
return e.require[t].apply(e, arguments);
};
}), isBrowser && (head = s.head = document.getElementsByTagName('head')[0], baseElement = document.getElementsByTagName('base')[0], baseElement && (head = s.head = baseElement.parentNode)), req.onError = defaultOnError, req.createNode = function (t, e, n) {
var r = t.xhtml ? document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') : document.createElement('script');
return r.type = t.scriptType || 'text/javascript', r.charset = 'utf-8', r.async = !0, r;
}, req.load = function (t, e, n) {
var r, i = t && t.config || {};
if (isBrowser)
return r = req.createNode(i, e, n), r.setAttribute('data-requirecontext', t.contextName), r.setAttribute('data-requiremodule', e), !r.attachEvent || r.attachEvent.toString && r.attachEvent.toString().indexOf('[native code') < 0 || isOpera ? (r.addEventListener('load', t.onScriptLoad, !1), r.addEventListener('error', t.onScriptError, !1)) : (useInteractive = !0, r.attachEvent('onreadystatechange', t.onScriptLoad)), r.src = n, currentlyAddingScript = r, baseElement ? head.insertBefore(r, baseElement) : head.appendChild(r), currentlyAddingScript = null, r;
if (isWebWorker)
try {
importScripts(n), t.completeLoad(e);
} catch (o) {
t.onError(makeError('importscripts', 'importScripts failed for ' + e + ' at ' + n, o, [e]));
}
}, isBrowser && !cfg.skipDataMain && eachReverse(scripts(), function (t) {
return head || (head = t.parentNode), dataMain = t.getAttribute('data-main'), dataMain ? (mainScript = dataMain, cfg.baseUrl || (src = mainScript.split('/'), mainScript = src.pop(), subPath = src.length ? src.join('/') + '/' : './', cfg.baseUrl = subPath), mainScript = mainScript.replace(jsSuffixRegExp, ''), req.jsExtRegExp.test(mainScript) && (mainScript = dataMain), cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript], !0) : void 0;
}), define = function (t, e, n) {
var r, i;
'string' != typeof t && (n = e, e = t, t = null), isArray(e) || (n = e, e = null), !e && isFunction(n) && (e = [], n.length && (n.toString().replace(commentRegExp, '').replace(cjsRequireRegExp, function (t, n) {
e.push(n);
}), e = (1 === n.length ? ['require'] : [
'require',
'exports',
'module'
]).concat(e))), useInteractive && (r = currentlyAddingScript || getInteractiveScript(), r && (t || (t = r.getAttribute('data-requiremodule')), i = contexts[r.getAttribute('data-requirecontext')])), (i ? i.defQueue : globalDefQueue).push([
t,
e,
n
]);
}, define.amd = { jQuery: !0 }, req.exec = function (text) {
return eval(text);
}, req(cfg);
}
}(this), global[''] = exports;
}({}, function () {
return this;
}());
(function (t, e, n) {
'use strict';
function r(t, e, n) {
var r, a = t.runtimeStyle && t.runtimeStyle[e], o = t.style;
return !/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test(n) && /^-?\d/.test(n) && (r = o.left, a && (t.runtimeStyle.left = t.currentStyle.left), o.left = 'fontSize' === e ? '1em' : n || 0, n = o.pixelLeft + 'px', o.left = r, a && (t.runtimeStyle.left = a)), /^(thin|medium|thick)$/i.test(n) ? n : Math.round(parseFloat(n)) + 'px';
}
function a(t) {
return parseInt(t, 10);
}
function o(t, e, a, o) {
if (t = (t || '').split(','), t = t[o || 0] || t[0] || 'auto', t = u.Util.trimText(t).split(' '), 'backgroundSize' !== a || t[0] && !t[0].match(/cover|contain|auto/)) {
if (t[0] = -1 === t[0].indexOf('%') ? r(e, a + 'X', t[0]) : t[0], t[1] === n) {
if ('backgroundSize' === a)
return t[1] = 'auto', t;
t[1] = t[0];
}
t[1] = -1 === t[1].indexOf('%') ? r(e, a + 'Y', t[1]) : t[1];
} else ;
return t;
}
function i(t, e, n, r, a, o) {
var i, l, s, c, d = u.Util.getCSS(e, t, a);
if (1 === d.length && (c = d[0], d = [], d[0] = c, d[1] = c), -1 !== ('' + d[0]).indexOf('%'))
s = parseFloat(d[0]) / 100, l = n.width * s, 'backgroundSize' !== t && (l -= (o || r).width * s);
else if ('backgroundSize' === t)
if ('auto' === d[0])
l = r.width;
else if (/contain|cover/.test(d[0])) {
var h = u.Util.resizeBounds(r.width, r.height, n.width, n.height, d[0]);
l = h.width, i = h.height;
} else
l = parseInt(d[0], 10);
else
l = parseInt(d[0], 10);
return 'auto' === d[1] ? i = l / r.width * r.height : -1 !== ('' + d[1]).indexOf('%') ? (s = parseFloat(d[1]) / 100, i = n.height * s, 'backgroundSize' !== t && (i -= (o || r).height * s)) : i = parseInt(d[1], 10), [
l,
i
];
}
function l(t, e) {
var n = [];
return {
storage: n,
width: t,
height: e,
clip: function () {
n.push({
type: 'function',
name: 'clip',
arguments: arguments
});
},
translate: function () {
n.push({
type: 'function',
name: 'translate',
arguments: arguments
});
},
fill: function () {
n.push({
type: 'function',
name: 'fill',
arguments: arguments
});
},
save: function () {
n.push({
type: 'function',
name: 'save',
arguments: arguments
});
},
restore: function () {
n.push({
type: 'function',
name: 'restore',
arguments: arguments
});
},
fillRect: function () {
n.push({
type: 'function',
name: 'fillRect',
arguments: arguments
});
},
createPattern: function () {
n.push({
type: 'function',
name: 'createPattern',
arguments: arguments
});
},
drawShape: function () {
var t = [];
return n.push({
type: 'function',
name: 'drawShape',
arguments: t
}), {
moveTo: function () {
t.push({
name: 'moveTo',
arguments: arguments
});
},
lineTo: function () {
t.push({
name: 'lineTo',
arguments: arguments
});
},
arcTo: function () {
t.push({
name: 'arcTo',
arguments: arguments
});
},
bezierCurveTo: function () {
t.push({
name: 'bezierCurveTo',
arguments: arguments
});
},
quadraticCurveTo: function () {
t.push({
name: 'quadraticCurveTo',
arguments: arguments
});
}
};
},
drawImage: function () {
n.push({
type: 'function',
name: 'drawImage',
arguments: arguments
});
},
fillText: function () {
n.push({
type: 'function',
name: 'fillText',
arguments: arguments
});
},
setVariable: function (t, e) {
return n.push({
type: 'variable',
name: t,
arguments: e
}), e;
}
};
}
function s(t) {
return {
zindex: t,
children: []
};
}
var c, d, u = {};
u.Util = {}, u.Util.log = function (e) {
u.logging && t.console && t.console.log && t.console.log(e);
}, u.Util.trimText = function (t) {
return function (e) {
return t ? t.apply(e) : ((e || '') + '').replace(/^\s+|\s+$/g, '');
};
}(String.prototype.trim), u.Util.asFloat = function (t) {
return parseFloat(t);
}, function () {
var t = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, e = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
u.Util.parseTextShadows = function (n) {
if (!n || 'none' === n)
return [];
for (var r = n.match(t), a = [], o = 0; r && r.length > o; o++) {
var i = r[o].match(e);
a.push({
color: i[0],
offsetX: i[1] ? i[1].replace('px', '') : 0,
offsetY: i[2] ? i[2].replace('px', '') : 0,
blur: i[3] ? i[3].replace('px', '') : 0
});
}
return a;
};
}(), u.Util.parseBackgroundImage = function (t) {
var e, n, r, a, o, i, l, s, c = ' \r\n\t', d = [], u = 0, h = 0, f = function () {
e && ('"' === n.substr(0, 1) && (n = n.substr(1, n.length - 2)), n && s.push(n), '-' === e.substr(0, 1) && (a = e.indexOf('-', 1) + 1) > 0 && (r = e.substr(0, a), e = e.substr(a)), d.push({
prefix: r,
method: e.toLowerCase(),
value: o,
args: s
})), s = [], e = r = n = o = '';
};
f();
for (var p = 0, g = t.length; g > p; p++)
if (i = t[p], !(0 === u && c.indexOf(i) > -1)) {
switch (i) {
case '"':
l ? l === i && (l = null) : l = i;
break;
case '(':
if (l)
break;
if (0 === u) {
u = 1, o += i;
continue;
}
h++;
break;
case ')':
if (l)
break;
if (1 === u) {
if (0 === h) {
u = 0, o += i, f();
continue;
}
h--;
}
break;
case ',':
if (l)
break;
if (0 === u) {
f();
continue;
}
if (1 === u && 0 === h && !e.match(/^url$/i)) {
s.push(n), n = '', o += i;
continue;
}
}
o += i, 0 === u ? e += i : n += i;
}
return f(), d;
}, u.Util.Bounds = function (t) {
var e, n = {};
return t.getBoundingClientRect && (e = t.getBoundingClientRect(), n.top = e.top, n.bottom = e.bottom || e.top + e.height, n.left = e.left, n.width = t.offsetWidth, n.height = t.offsetHeight), n;
}, u.Util.OffsetBounds = function (t) {
var e = t.offsetParent ? u.Util.OffsetBounds(t.offsetParent) : {
top: 0,
left: 0
};
return {
top: t.offsetTop + e.top,
bottom: t.offsetTop + t.offsetHeight + e.top,
left: t.offsetLeft + e.left,
width: t.offsetWidth,
height: t.offsetHeight
};
}, u.Util.getCSS = function (t, n, r) {
c !== t && (d = e.defaultView.getComputedStyle(t, null));
var i = d[n];
if (/^background(Size|Position)$/.test(n))
return o(i, t, n, r);
if (/border(Top|Bottom)(Left|Right)Radius/.test(n)) {
var l = i.split(' ');
return 1 >= l.length && (l[1] = l[0]), l.map(a);
}
return i;
}, u.Util.resizeBounds = function (t, e, n, r, a) {
var o, i, l = n / r, s = t / e;
return a && 'auto' !== a ? s > l ^ 'contain' === a ? (i = r, o = r * s) : (o = n, i = n / s) : (o = n, i = r), {
width: o,
height: i
};
}, u.Util.BackgroundPosition = function (t, e, n, r, a) {
var o = i('backgroundPosition', t, e, n, r, a);
return {
left: o[0],
top: o[1]
};
}, u.Util.BackgroundSize = function (t, e, n, r) {
var a = i('backgroundSize', t, e, n, r);
return {
width: a[0],
height: a[1]
};
}, u.Util.Extend = function (t, e) {
for (var n in t)
t.hasOwnProperty(n) && (e[n] = t[n]);
return e;
}, u.Util.Children = function (t) {
var e;
try {
e = t.nodeName && 'IFRAME' === t.nodeName.toUpperCase() ? t.contentDocument || t.contentWindow.document : function (t) {
var e = [];
return null !== t && function (t, e) {
var r = t.length, a = 0;
if ('number' == typeof e.length)
for (var o = e.length; o > a; a++)
t[r++] = e[a];
else
for (; e[a] !== n;)
t[r++] = e[a++];
return t.length = r, t;
}(e, t), e;
}(t.childNodes);
} catch (r) {
u.Util.log('html2canvas.Util.Children failed with exception: ' + r.message), e = [];
}
return e;
}, u.Util.isTransparent = function (t) {
return 'transparent' === t || 'rgba(0, 0, 0, 0)' === t;
}, u.Util.Font = function () {
var t = {};
return function (e, r, a) {
if (t[e + '-' + r] !== n)
return t[e + '-' + r];
var o, i, l, s = a.createElement('div'), c = a.createElement('img'), d = a.createElement('span'), u = 'Hidden Text';
return s.style.visibility = 'hidden', s.style.fontFamily = e, s.style.fontSize = r, s.style.margin = 0, s.style.padding = 0, a.body.appendChild(s), c.src = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=', c.width = 1, c.height = 1, c.style.margin = 0, c.style.padding = 0, c.style.verticalAlign = 'baseline', d.style.fontFamily = e, d.style.fontSize = r, d.style.margin = 0, d.style.padding = 0, d.appendChild(a.createTextNode(u)), s.appendChild(d), s.appendChild(c), o = c.offsetTop - d.offsetTop + 1, s.removeChild(d), s.appendChild(a.createTextNode(u)), s.style.lineHeight = 'normal', c.style.verticalAlign = 'super', i = c.offsetTop - s.offsetTop + 1, l = {
baseline: o,
lineWidth: 1,
middle: i
}, t[e + '-' + r] = l, a.body.removeChild(s), l;
};
}(), function () {
function t(t) {
return function (e) {
try {
t.addColorStop(e.stop, e.color);
} catch (r) {
n.log([
'failed to add color stop: ',
r,
'; tried to add: ',
e
]);
}
};
}
var n = u.Util, r = {};
u.Generate = r;
var a = [
/^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
/^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
/^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/,
/^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
/^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/,
/^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/,
/^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/
];
r.parseGradient = function (t, e) {
var n, r, o, i, l, s, c, d, u, h, f, p, g = a.length;
for (r = 0; g > r && !(o = t.match(a[r])); r += 1);
if (o)
switch (o[1]) {
case '-webkit-linear-gradient':
case '-o-linear-gradient':
if (n = {
type: 'linear',
x0: null,
y0: null,
x1: null,
y1: null,
colorStops: []
}, l = o[2].match(/\w+/g))
for (s = l.length, r = 0; s > r; r += 1)
switch (l[r]) {
case 'top':
n.y0 = 0, n.y1 = e.height;
break;
case 'right':
n.x0 = e.width, n.x1 = 0;
break;
case 'bottom':
n.y0 = e.height, n.y1 = 0;
break;
case 'left':
n.x0 = 0, n.x1 = e.width;
}
if (null === n.x0 && null === n.x1 && (n.x0 = n.x1 = e.width / 2), null === n.y0 && null === n.y1 && (n.y0 = n.y1 = e.height / 2), l = o[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g))
for (s = l.length, c = 1 / Math.max(s - 1, 1), r = 0; s > r; r += 1)
d = l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/), d[2] ? (i = parseFloat(d[2]), i /= '%' === d[3] ? 100 : e.width) : i = r * c, n.colorStops.push({
color: d[1],
stop: i
});
break;
case '-webkit-gradient':
if (n = {
type: 'radial' === o[2] ? 'circle' : o[2],
x0: 0,
y0: 0,
x1: 0,
y1: 0,
colorStops: []
}, l = o[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/), l && (n.x0 = l[1] * e.width / 100, n.y0 = l[2] * e.height / 100, n.x1 = l[3] * e.width / 100, n.y1 = l[4] * e.height / 100), l = o[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g))
for (s = l.length, r = 0; s > r; r += 1)
d = l[r].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/), i = parseFloat(d[2]), 'from' === d[1] && (i = 0), 'to' === d[1] && (i = 1), n.colorStops.push({
color: d[3],
stop: i
});
break;
case '-moz-linear-gradient':
if (n = {
type: 'linear',
x0: 0,
y0: 0,
x1: 0,
y1: 0,
colorStops: []
}, l = o[2].match(/(\d{1,3})%?\s(\d{1,3})%?/), l && (n.x0 = l[1] * e.width / 100, n.y0 = l[2] * e.height / 100, n.x1 = e.width - n.x0, n.y1 = e.height - n.y0), l = o[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g))
for (s = l.length, c = 1 / Math.max(s - 1, 1), r = 0; s > r; r += 1)
d = l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/), d[2] ? (i = parseFloat(d[2]), d[3] && (i /= 100)) : i = r * c, n.colorStops.push({
color: d[1],
stop: i
});
break;
case '-webkit-radial-gradient':
case '-moz-radial-gradient':
case '-o-radial-gradient':
if (n = {
type: 'circle',
x0: 0,
y0: 0,
x1: e.width,
y1: e.height,
cx: 0,
cy: 0,
rx: 0,
ry: 0,
colorStops: []
}, l = o[2].match(/(\d{1,3})%?\s(\d{1,3})%?/), l && (n.cx = l[1] * e.width / 100, n.cy = l[2] * e.height / 100), l = o[3].match(/\w+/), d = o[4].match(/[a-z\-]*/), l && d)
switch (d[0]) {
case 'farthest-corner':
case 'cover':
case '':
u = Math.sqrt(Math.pow(n.cx, 2) + Math.pow(n.cy, 2)), h = Math.sqrt(Math.pow(n.cx, 2) + Math.pow(n.y1 - n.cy, 2)), f = Math.sqrt(Math.pow(n.x1 - n.cx, 2) + Math.pow(n.y1 - n.cy, 2)), p = Math.sqrt(Math.pow(n.x1 - n.cx, 2) + Math.pow(n.cy, 2)), n.rx = n.ry = Math.max(u, h, f, p);
break;
case 'closest-corner':
u = Math.sqrt(Math.pow(n.cx, 2) + Math.pow(n.cy, 2)), h = Math.sqrt(Math.pow(n.cx, 2) + Math.pow(n.y1 - n.cy, 2)), f = Math.sqrt(Math.pow(n.x1 - n.cx, 2) + Math.pow(n.y1 - n.cy, 2)), p = Math.sqrt(Math.pow(n.x1 - n.cx, 2) + Math.pow(n.cy, 2)), n.rx = n.ry = Math.min(u, h, f, p);
break;
case 'farthest-side':
'circle' === l[0] ? n.rx = n.ry = Math.max(n.cx, n.cy, n.x1 - n.cx, n.y1 - n.cy) : (n.type = l[0], n.rx = Math.max(n.cx, n.x1 - n.cx), n.ry = Math.max(n.cy, n.y1 - n.cy));
break;
case 'closest-side':
case 'contain':
'circle' === l[0] ? n.rx = n.ry = Math.min(n.cx, n.cy, n.x1 - n.cx, n.y1 - n.cy) : (n.type = l[0], n.rx = Math.min(n.cx, n.x1 - n.cx), n.ry = Math.min(n.cy, n.y1 - n.cy));
}
if (l = o[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g))
for (s = l.length, c = 1 / Math.max(s - 1, 1), r = 0; s > r; r += 1)
d = l[r].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/), d[2] ? (i = parseFloat(d[2]), i /= '%' === d[3] ? 100 : e.width) : i = r * c, n.colorStops.push({
color: d[1],
stop: i
});
}
return n;
}, r.Gradient = function (n, r) {
if (0 !== r.width && 0 !== r.height) {
var a, o, i = e.createElement('canvas'), l = i.getContext('2d');
if (i.width = r.width, i.height = r.height, a = u.Generate.parseGradient(n, r))
switch (a.type) {
case 'linear':
o = l.createLinearGradient(a.x0, a.y0, a.x1, a.y1), a.colorStops.forEach(t(o)), l.fillStyle = o, l.fillRect(0, 0, r.width, r.height);
break;
case 'circle':
o = l.createRadialGradient(a.cx, a.cy, 0, a.cx, a.cy, a.rx), a.colorStops.forEach(t(o)), l.fillStyle = o, l.fillRect(0, 0, r.width, r.height);
break;
case 'ellipse':
var s = e.createElement('canvas'), c = s.getContext('2d'), d = Math.max(a.rx, a.ry), h = 2 * d;
s.width = s.height = h, o = c.createRadialGradient(a.rx, a.ry, 0, a.rx, a.ry, d), a.colorStops.forEach(t(o)), c.fillStyle = o, c.fillRect(0, 0, h, h), l.fillStyle = a.colorStops[a.colorStops.length - 1].color, l.fillRect(0, 0, i.width, i.height), l.drawImage(s, a.cx - a.rx, a.cy - a.ry, 2 * a.rx, 2 * a.ry);
}
return i;
}
}, r.ListAlpha = function (t) {
var e, n = '';
do
e = t % 26, n = String.fromCharCode(e + 64) + n, t /= 26;
while (26 * t > 26);
return n;
}, r.ListRoman = function (t) {
var e, n = [
'M',
'CM',
'D',
'CD',
'C',
'XC',
'L',
'XL',
'X',
'IX',
'V',
'IV',
'I'
], r = [
1000,
900,
500,
400,
100,
90,
50,
40,
10,
9,
5,
4,
1
], a = '', o = n.length;
if (0 >= t || t >= 4000)
return t;
for (e = 0; o > e; e += 1)
for (; t >= r[e];)
t -= r[e], a += n[e];
return a;
};
}(), u.Parse = function (r, a) {
function o() {
return Math.max(Math.max(de.body.scrollWidth, de.documentElement.scrollWidth), Math.max(de.body.offsetWidth, de.documentElement.offsetWidth), Math.max(de.body.clientWidth, de.documentElement.clientWidth));
}
function i() {
return Math.max(Math.max(de.body.scrollHeight, de.documentElement.scrollHeight), Math.max(de.body.offsetHeight, de.documentElement.offsetHeight), Math.max(de.body.clientHeight, de.documentElement.clientHeight));
}
function c(t, e) {
var n = parseInt(ge(t, e), 10);
return isNaN(n) ? 0 : n;
}
function d(t, e, n, r, a, o) {
'transparent' !== o && (t.setVariable('fillStyle', o), t.fillRect(e, n, r, a), ce += 1);
}
function h(t, e, r) {
return t.length > 0 ? e + r.toUpperCase() : n;
}
function f(t, e) {
switch (e) {
case 'lowercase':
return t.toLowerCase();
case 'capitalize':
return t.replace(/(^|\s|:|-|\(|\))([a-z])/g, h);
case 'uppercase':
return t.toUpperCase();
default:
return t;
}
}
function p(t) {
return /^(normal|none|0px)$/.test(t);
}
function g(t, e, n, r) {
null !== t && ue.trimText(t).length > 0 && (r.fillText(t, e, n), ce += 1);
}
function m(t, e, r, a) {
var o = !1, i = ge(e, 'fontWeight'), l = ge(e, 'fontFamily'), s = ge(e, 'fontSize'), c = ue.parseTextShadows(ge(e, 'textShadow'));
switch (parseInt(i, 10)) {
case 401:
i = 'bold';
break;
case 400:
i = 'normal';
}
return t.setVariable('fillStyle', a), t.setVariable('font', [
ge(e, 'fontStyle'),
ge(e, 'fontVariant'),
i,
s,
l
].join(' ')), t.setVariable('textAlign', o ? 'right' : 'left'), c.length && (t.setVariable('shadowColor', c[0].color), t.setVariable('shadowOffsetX', c[0].offsetX), t.setVariable('shadowOffsetY', c[0].offsetY), t.setVariable('shadowBlur', c[0].blur)), 'none' !== r ? ue.Font(l, s, de) : n;
}
function y(t, e, n, r, a) {
switch (e) {
case 'underline':
d(t, n.left, Math.round(n.top + r.baseline + r.lineWidth), n.width, 1, a);
break;
case 'overline':
d(t, n.left, Math.round(n.top), n.width, 1, a);
break;
case 'line-through':
d(t, n.left, Math.ceil(n.top + r.middle + r.lineWidth), n.width, 1, a);
}
}
function b(t, e, n, r, a) {
var o;
if (he.rangeBounds && !a)
('none' !== n || 0 !== ue.trimText(e).length) && (o = w(e, t.node, t.textOffset)), t.textOffset += e.length;
else if (t.node && 'string' == typeof t.node.nodeValue) {
var i = r ? t.node.splitText(e.length) : null;
o = x(t.node, a), t.node = i;
}
return o;
}
function w(t, e, n) {
var r = de.createRange();
return r.setStart(e, n), r.setEnd(e, n + t.length), r.getBoundingClientRect();
}
function x(t, e) {
var n = t.parentNode, r = de.createElement('wrapper'), a = t.cloneNode(!0);
r.appendChild(t.cloneNode(!0)), n.replaceChild(r, t);
var o = e ? ue.OffsetBounds(r) : ue.Bounds(r);
return n.replaceChild(a, r), o;
}
function v(t, e, n) {
var r, o, i = n.ctx, l = ge(t, 'color'), s = ge(t, 'textDecoration'), c = ge(t, 'textAlign'), d = {
node: e,
textOffset: 0
};
ue.trimText(e.nodeValue).length > 0 && (e.nodeValue = f(e.nodeValue, ge(t, 'textTransform')), c = c.replace(['-webkit-auto'], ['auto']), o = !a.letterRendering && /^(left|right|justify|auto)$/.test(c) && p(ge(t, 'letterSpacing')) ? e.nodeValue.split(/(\b| )/) : e.nodeValue.split(''), r = m(i, t, s, l), a.chinese && o.forEach(function (t, e) {
/.*[\u4E00-\u9FA5].*$/.test(t) && (t = t.split(''), t.unshift(e, 1), o.splice.apply(o, t));
}), o.forEach(function (t, e) {
var a = b(d, t, s, o.length - 1 > e, n.transform.matrix);
a && (g(t, a.left, a.bottom, i), y(i, s, a, r, l));
}));
}
function k(t, e) {
var n, r, a = de.createElement('boundelement');
return a.style.display = 'inline', n = t.style.listStyleType, t.style.listStyleType = 'none', a.appendChild(de.createTextNode(e)), t.insertBefore(a, t.firstChild), r = ue.Bounds(a), t.removeChild(a), t.style.listStyleType = n, r;
}
function C(t) {
var e = -1, n = 1, r = t.parentNode.childNodes;
if (t.parentNode) {
for (; r[++e] !== t;)
1 === r[e].nodeType && n++;
return n;
}
return -1;
}
function T(t, e) {
var n, r = C(t);
switch (e) {
case 'decimal':
n = r;
break;
case 'decimal-leading-zero':
n = 1 === ('' + r).length ? r = '0' + ('' + r) : '' + r;
break;
case 'upper-roman':
n = u.Generate.ListRoman(r);
break;
case 'lower-roman':
n = u.Generate.ListRoman(r).toLowerCase();
break;
case 'lower-alpha':
n = u.Generate.ListAlpha(r).toLowerCase();
break;
case 'upper-alpha':
n = u.Generate.ListAlpha(r);
}
return n + '. ';
}
function S(t, e, n) {
var r, a, o, i = e.ctx, l = ge(t, 'listStyleType');
if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(l)) {
if (a = T(t, l), o = k(t, a), m(i, t, 'none', ge(t, 'color')), 'inside' !== ge(t, 'listStylePosition'))
return;
i.setVariable('textAlign', 'left'), r = n.left, g(a, r, o.bottom, i);
}
}
function M(t) {
var e = r[t];
return e && e.succeeded === !0 ? e.img : !1;
}
function R(t, e) {
var n = Math.max(t.left, e.left), r = Math.max(t.top, e.top), a = Math.min(t.left + t.width, e.left + e.width), o = Math.min(t.top + t.height, e.top + e.height);
return {
left: n,
top: r,
width: a - n,
height: o - r
};
}
function E(t, e, n) {
var r, a = 'static' !== e.cssPosition, o = a ? ge(t, 'zIndex') : 'auto', i = ge(t, 'opacity'), l = 'none' !== ge(t, 'cssFloat');
e.zIndex = r = s(o), r.isPositioned = a, r.isFloated = l, r.opacity = i, r.ownStacking = 'auto' !== o || 1 > i, n && n.zIndex.children.push(e);
}
function I(t, e, n, r, a) {
var o = c(e, 'paddingLeft'), i = c(e, 'paddingTop'), l = c(e, 'paddingRight'), s = c(e, 'paddingBottom');
$(t, n, 0, 0, n.width, n.height, r.left + o + a[3].width, r.top + i + a[0].width, r.width - (a[1].width + a[3].width + o + l), r.height - (a[0].width + a[2].width + i + s));
}
function L(t) {
return [
'Top',
'Right',
'Bottom',
'Left'
].map(function (e) {
return {
width: c(t, 'border' + e + 'Width'),
color: ge(t, 'border' + e + 'Color')
};
});
}
function O(t) {
return [
'TopLeft',
'TopRight',
'BottomRight',
'BottomLeft'
].map(function (e) {
return ge(t, 'border' + e + 'Radius');
});
}
function z(t, e, n, r) {
var a = function (t, e, n) {
return {
x: t.x + (e.x - t.x) * n,
y: t.y + (e.y - t.y) * n
};
};
return {
start: t,
startControl: e,
endControl: n,
end: r,
subdivide: function (o) {
var i = a(t, e, o), l = a(e, n, o), s = a(n, r, o), c = a(i, l, o), d = a(l, s, o), u = a(c, d, o);
return [
z(t, i, c, u),
z(u, d, s, r)
];
},
curveTo: function (t) {
t.push([
'bezierCurve',
e.x,
e.y,
n.x,
n.y,
r.x,
r.y
]);
},
curveToReversed: function (r) {
r.push([
'bezierCurve',
n.x,
n.y,
e.x,
e.y,
t.x,
t.y
]);
}
};
}
function A(t, e, n, r, a, o, i) {
e[0] > 0 || e[1] > 0 ? (t.push([
'line',
r[0].start.x,
r[0].start.y
]), r[0].curveTo(t), r[1].curveTo(t)) : t.push([
'line',
o,
i
]), (n[0] > 0 || n[1] > 0) && t.push([
'line',
a[0].start.x,
a[0].start.y
]);
}
function B(t, e, n, r, a, o, i) {
var l = [];
return e[0] > 0 || e[1] > 0 ? (l.push([
'line',
r[1].start.x,
r[1].start.y
]), r[1].curveTo(l)) : l.push([
'line',
t.c1[0],
t.c1[1]
]), n[0] > 0 || n[1] > 0 ? (l.push([
'line',
o[0].start.x,
o[0].start.y
]), o[0].curveTo(l), l.push([
'line',
i[0].end.x,
i[0].end.y
]), i[0].curveToReversed(l)) : (l.push([
'line',
t.c2[0],
t.c2[1]
]), l.push([
'line',
t.c3[0],
t.c3[1]
])), e[0] > 0 || e[1] > 0 ? (l.push([
'line',
a[1].end.x,
a[1].end.y
]), a[1].curveToReversed(l)) : l.push([
'line',
t.c4[0],
t.c4[1]
]), l;
}
function U(t, e, n) {
var r = t.left, a = t.top, o = t.width, i = t.height, l = e[0][0], s = e[0][1], c = e[1][0], d = e[1][1], u = e[2][0], h = e[2][1], f = e[3][0], p = e[3][1], g = o - c, m = i - h, y = o - u, b = i - p;
return {
topLeftOuter: be(r, a, l, s).topLeft.subdivide(0.5),
topLeftInner: be(r + n[3].width, a + n[0].width, Math.max(0, l - n[3].width), Math.max(0, s - n[0].width)).topLeft.subdivide(0.5),
topRightOuter: be(r + g, a, c, d).topRight.subdivide(0.5),
topRightInner: be(r + Math.min(g, o + n[3].width), a + n[0].width, g > o + n[3].width ? 0 : c - n[3].width, d - n[0].width).topRight.subdivide(0.5),
bottomRightOuter: be(r + y, a + m, u, h).bottomRight.subdivide(0.5),
bottomRightInner: be(r + Math.min(y, o + n[3].width), a + Math.min(m, i + n[0].width), Math.max(0, u - n[1].width), Math.max(0, h - n[2].width)).bottomRight.subdivide(0.5),
bottomLeftOuter: be(r, a + b, f, p).bottomLeft.subdivide(0.5),
bottomLeftInner: be(r + n[3].width, a + b, Math.max(0, f - n[3].width), Math.max(0, p - n[2].width)).bottomLeft.subdivide(0.5)
};
}
function N(t, e, n, r, a) {
var o = ge(t, 'backgroundClip'), i = [];
switch (o) {
case 'content-box':
case 'padding-box':
A(i, r[0], r[1], e.topLeftInner, e.topRightInner, a.left + n[3].width, a.top + n[0].width), A(i, r[1], r[2], e.topRightInner, e.bottomRightInner, a.left + a.width - n[1].width, a.top + n[0].width), A(i, r[2], r[3], e.bottomRightInner, e.bottomLeftInner, a.left + a.width - n[1].width, a.top + a.height - n[2].width), A(i, r[3], r[0], e.bottomLeftInner, e.topLeftInner, a.left + n[3].width, a.top + a.height - n[2].width);
break;
default:
A(i, r[0], r[1], e.topLeftOuter, e.topRightOuter, a.left, a.top), A(i, r[1], r[2], e.topRightOuter, e.bottomRightOuter, a.left + a.width, a.top), A(i, r[2], r[3], e.bottomRightOuter, e.bottomLeftOuter, a.left + a.width, a.top + a.height), A(i, r[3], r[0], e.bottomLeftOuter, e.topLeftOuter, a.left, a.top + a.height);
}
return i;
}
function P(t, e, n) {
var r, a, o, i, l, s, c = e.left, d = e.top, u = e.width, h = e.height, f = O(t), p = U(e, f, n), g = {
clip: N(t, p, n, f, e),
borders: []
};
for (r = 0; 4 > r; r++)
if (n[r].width > 0) {
switch (a = c, o = d, i = u, l = h - n[2].width, r) {
case 0:
l = n[0].width, s = B({
c1: [
a,
o
],
c2: [
a + i,
o
],
c3: [
a + i - n[1].width,
o + l
],
c4: [
a + n[3].width,
o + l
]
}, f[0], f[1], p.topLeftOuter, p.topLeftInner, p.topRightOuter, p.topRightInner);
break;
case 1:
a = c + u - n[1].width, i = n[1].width, s = B({
c1: [
a + i,
o
],
c2: [
a + i,
o + l + n[2].width
],
c3: [
a,
o + l
],
c4: [
a,
o + n[0].width
]
}, f[1], f[2], p.topRightOuter, p.topRightInner, p.bottomRightOuter, p.bottomRightInner);
break;
case 2:
o = o + h - n[2].width, l = n[2].width, s = B({
c1: [
a + i,
o + l
],
c2: [
a,
o + l
],
c3: [
a + n[3].width,
o
],
c4: [
a + i - n[3].width,
o
]
}, f[2], f[3], p.bottomRightOuter, p.bottomRightInner, p.bottomLeftOuter, p.bottomLeftInner);
break;
case 3:
i = n[3].width, s = B({
c1: [
a,
o + l + n[2].width
],
c2: [
a,
o
],
c3: [
a + i,
o + n[0].width
],
c4: [
a + i,
o + l
]
}, f[3], f[0], p.bottomLeftOuter, p.bottomLeftInner, p.topLeftOuter, p.topLeftInner);
}
g.borders.push({
args: s,
color: n[r].color
});
}
return g;
}
function F(t, e) {
var n = t.drawShape();
return e.forEach(function (t, e) {
n[0 === e ? 'moveTo' : t[0] + 'To'].apply(null, t.slice(1));
}), n;
}
function V(t, e, n) {
'transparent' !== n && (t.setVariable('fillStyle', n), F(t, e), t.fill(), ce += 1);
}
function D(t, e, n) {
var r, a, o = de.createElement('valuewrap'), i = [
'lineHeight',
'textAlign',
'fontFamily',
'color',
'fontSize',
'paddingLeft',
'paddingTop',
'width',
'height',
'border',
'borderLeftWidth',
'borderTopWidth'
];
i.forEach(function (e) {
try {
o.style[e] = ge(t, e);
} catch (n) {
ue.log('html2canvas: Parse: Exception caught in renderFormValue: ' + n.message);
}
}), o.style.borderColor = 'black', o.style.borderStyle = 'solid', o.style.display = 'block', o.style.position = 'absolute', (/^(submit|reset|button|text|password)$/.test(t.type) || 'SELECT' === t.nodeName) && (o.style.lineHeight = ge(t, 'height')), o.style.top = e.top + 'px', o.style.left = e.left + 'px', r = 'SELECT' === t.nodeName ? (t.options[t.selectedIndex] || 0).text : t.value, r || (r = t.placeholder), a = de.createTextNode(r), o.appendChild(a), pe.appendChild(o), v(t, a, n), pe.removeChild(o);
}
function $(t) {
t.drawImage.apply(t, Array.prototype.slice.call(arguments, 1)), ce += 1;
}
function G(n, r) {
var a = t.getComputedStyle(n, r);
if (a && a.content && 'none' !== a.content && '-moz-alt-content' !== a.content && 'none' !== a.display) {
var o = a.content + '', i = o.substr(0, 1);
i === o.substr(o.length - 1) && i.match(/'|"/) && (o = o.substr(1, o.length - 2));
var l = 'url' === o.substr(0, 3), s = e.createElement(l ? 'img' : 'span');
return s.className = me + '-before ' + me + '-after', Object.keys(a).filter(W).forEach(function (t) {
try {
s.style[t] = a[t];
} catch (e) {
ue.log([
'Tried to assign readonly property ',
t,
'Error:',
e
]);
}
}), l ? s.src = ue.parseBackgroundImage(o)[0].args[0] : s.innerHTML = o, s;
}
}
function W(e) {
return isNaN(t.parseInt(e, 10));
}
function H(t, e) {
var n = G(t, ':before'), r = G(t, ':after');
(n || r) && (n && (t.className += ' ' + me + '-before', t.parentNode.insertBefore(n, t), oe(n, e, !0), t.parentNode.removeChild(n), t.className = t.className.replace(me + '-before', '').trim()), r && (t.className += ' ' + me + '-after', t.appendChild(r), oe(r, e, !0), t.removeChild(r), t.className = t.className.replace(me + '-after', '').trim()));
}
function j(t, e, n, r) {
var a = Math.round(r.left + n.left), o = Math.round(r.top + n.top);
t.createPattern(e), t.translate(a, o), t.fill(), t.translate(-a, -o);
}
function q(t, e, n, r, a, o, i, l) {
var s = [];
s.push([
'line',
Math.round(a),
Math.round(o)
]), s.push([
'line',
Math.round(a + i),
Math.round(o)
]), s.push([
'line',
Math.round(a + i),
Math.round(l + o)
]), s.push([
'line',
Math.round(a),
Math.round(l + o)
]), F(t, s), t.save(), t.clip(), j(t, e, n, r), t.restore();
}
function X(t, e, n) {
d(t, e.left, e.top, e.width, e.height, n);
}
function _(t, e, n, r, a) {
var o = ue.BackgroundSize(t, e, r, a), i = ue.BackgroundPosition(t, e, r, a, o), l = ge(t, 'backgroundRepeat').split(',').map(ue.trimText);
switch (r = Q(r, o), l = l[a] || l[0]) {
case 'repeat-x':
q(n, r, i, e, e.left, e.top + i.top, 99999, r.height);
break;
case 'repeat-y':
q(n, r, i, e, e.left + i.left, e.top, r.width, 99999);
break;
case 'no-repeat':
q(n, r, i, e, e.left + i.left, e.top + i.top, r.width, r.height);
break;
default:
j(n, r, i, {
top: e.top,
left: e.left,
width: r.width,
height: r.height
});
}
}
function Y(t, e, n) {
for (var r, a = ge(t, 'backgroundImage'), o = ue.parseBackgroundImage(a), i = o.length; i--;)
if (a = o[i], a.args && 0 !== a.args.length) {
var l = 'url' === a.method ? a.args[0] : a.value;
r = M(l), r ? _(t, e, n, r, i) : ue.log('html2canvas: Error loading background:', a);
}
}
function Q(t, e) {
if (t.width === e.width && t.height === e.height)
return t;
var n, r = de.createElement('canvas');
return r.width = e.width, r.height = e.height, n = r.getContext('2d'), $(n, t, 0, 0, t.width, t.height, 0, 0, e.width, e.height), r;
}
function J(t, e, n) {
return t.setVariable('globalAlpha', ge(e, 'opacity') * (n ? n.opacity : 1));
}
function K(t) {
return t.replace('px', '');
}
function Z(t) {
var e = ge(t, 'transform') || ge(t, '-webkit-transform') || ge(t, '-moz-transform') || ge(t, '-ms-transform') || ge(t, '-o-transform'), n = ge(t, 'transform-origin') || ge(t, '-webkit-transform-origin') || ge(t, '-moz-transform-origin') || ge(t, '-ms-transform-origin') || ge(t, '-o-transform-origin') || '0px 0px';
n = n.split(' ').map(K).map(ue.asFloat);
var r;
if (e && 'none' !== e) {
var a = e.match(we);
if (a)
switch (a[1]) {
case 'matrix':
r = a[2].split(',').map(ue.trimText).map(ue.asFloat);
}
}
return {
origin: n,
matrix: r
};
}
function te(t, e, n, r) {
var s = l(e ? n.width : o(), e ? n.height : i()), c = {
ctx: s,
opacity: J(s, t, e),
cssPosition: ge(t, 'position'),
borders: L(t),
transform: r,
clip: e && e.clip ? ue.Extend({}, e.clip) : null
};
return E(t, c, e), a.useOverflow === !0 && /(hidden|scroll|auto)/.test(ge(t, 'overflow')) === !0 && /(BODY)/i.test(t.nodeName) === !1 && (c.clip = c.clip ? R(c.clip, n) : n), c;
}
function ee(t, e, n) {
var r = {
left: e.left + t[3].width,
top: e.top + t[0].width,
width: e.width - (t[1].width + t[3].width),
height: e.height - (t[0].width + t[2].width)
};
return n && (r = R(r, n)), r;
}
function ne(t, e) {
var n = e.matrix ? ue.OffsetBounds(t) : ue.Bounds(t);
return e.origin[0] += n.left, e.origin[1] += n.top, n;
}
function re(t, e, n, r) {
var a, o = Z(t, e), i = ne(t, o), l = te(t, e, i, o), s = l.borders, c = l.ctx, d = ee(s, i, l.clip), u = P(t, i, s), h = fe.test(t.nodeName) ? '#efefef' : ge(t, 'backgroundColor');
switch (F(c, u.clip), c.save(), c.clip(), d.height > 0 && d.width > 0 && !r ? (X(c, i, h), Y(t, d, c)) : r && (l.backgroundColor = h), c.restore(), u.borders.forEach(function (t) {
V(c, t.args, t.color);
}), n || H(t, l), t.nodeName) {
case 'IMG':
(a = M(t.getAttribute('src'))) ? I(c, t, a, i, s) : ue.log('html2canvas: Error loading <img>:' + t.getAttribute('src'));
break;
case 'INPUT':
/^(text|url|email|submit|button|reset)$/.test(t.type) && (t.value || t.placeholder || '').length > 0 && D(t, i, l);
break;
case 'TEXTAREA':
(t.value || t.placeholder || '').length > 0 && D(t, i, l);
break;
case 'SELECT':
(t.options || t.placeholder || '').length > 0 && D(t, i, l);
break;
case 'LI':
S(t, l, d);
break;
case 'CANVAS':
I(c, t, t, i, s);
}
return l;
}
function ae(t) {
return 'none' !== ge(t, 'display') && 'hidden' !== ge(t, 'visibility') && !t.hasAttribute('data-html2canvas-ignore');
}
function oe(t, e, n) {
ae(t) && (e = re(t, e, n, !1) || e, fe.test(t.nodeName) || ie(t, e, n));
}
function ie(t, e, n) {
ue.Children(t).forEach(function (r) {
r.nodeType === r.ELEMENT_NODE ? oe(r, e, n) : r.nodeType === r.TEXT_NODE && v(t, r, e);
});
}
function le() {
var t = ge(e.documentElement, 'backgroundColor'), n = ue.isTransparent(t) && se === e.body, r = re(se, null, !1, n);
return ie(se, r), n && (t = r.backgroundColor), pe.removeChild(ye), {
backgroundColor: t,
stack: r
};
}
t.scroll(0, 0);
var se = a.elements === n ? e.body : a.elements[0], ce = 0, de = se.ownerDocument, ue = u.Util, he = ue.Support(a, de), fe = RegExp('(' + a.ignoreElements + ')'), pe = de.body, ge = ue.getCSS, me = '___html2canvas___pseudoelement', ye = de.createElement('style');
ye.innerHTML = '.' + me + '-before:before { content: "" !important; display: none !important; }' + '.' + me + '-after:after { content: "" !important; display: none !important; }', pe.appendChild(ye), r = r || {};
var be = function (t) {
return function (e, n, r, a) {
var o = r * t, i = a * t, l = e + r, s = n + a;
return {
topLeft: z({
x: e,
y: s
}, {
x: e,
y: s - i
}, {
x: l - o,
y: n
}, {
x: l,
y: n
}),
topRight: z({
x: e,
y: n
}, {
x: e + o,
y: n
}, {
x: l,
y: s - i
}, {
x: l,
y: s
}),
bottomRight: z({
x: l,
y: n
}, {
x: l,
y: n + i
}, {
x: e + o,
y: s
}, {
x: e,
y: s
}),
bottomLeft: z({
x: l,
y: s
}, {
x: l - o,
y: s
}, {
x: e,
y: n + i
}, {
x: e,
y: n
})
};
};
}(4 * ((Math.sqrt(2) - 1) / 3)), we = /(matrix)\((.+)\)/;
return le();
}, u.Preload = function (r) {
function a(t) {
M.href = t, M.href = M.href;
var e = M.protocol + M.host;
return e === g;
}
function o() {
x.log('html2canvas: start: images: ' + w.numLoaded + ' / ' + w.numTotal + ' (failed: ' + w.numFailed + ')'), !w.firstRun && w.numLoaded >= w.numTotal && (x.log('Finished loading images: # ' + w.numTotal + ' (failed: ' + w.numFailed + ')'), 'function' == typeof r.complete && r.complete(w));
}
function i(e, a, i) {
var l, s, c = r.proxy;
M.href = e, e = M.href, l = 'html2canvas_' + v++, i.callbackname = l, c += c.indexOf('?') > -1 ? '&' : '?', c += 'url=' + encodeURIComponent(e) + '&callback=' + l, s = C.createElement('script'), t[l] = function (e) {
'error:' === e.substring(0, 6) ? (i.succeeded = !1, w.numLoaded++, w.numFailed++, o()) : (p(a, i), a.src = e), t[l] = n;
try {
delete t[l];
} catch (r) {
}
s.parentNode.removeChild(s), s = null, delete i.script, delete i.callbackname;
}, s.setAttribute('type', 'text/javascript'), s.setAttribute('src', c), i.script = s, t.document.body.appendChild(s);
}
function l(e, n) {
var r = t.getComputedStyle(e, n), a = r.content;
'url' === a.substr(0, 3) && m.loadImage(u.Util.parseBackgroundImage(a)[0].args[0]), h(r.backgroundImage, e);
}
function s(t) {
l(t, ':before'), l(t, ':after');
}
function c(t, e) {
var r = u.Generate.Gradient(t, e);
r !== n && (w[t] = {
img: r,
succeeded: !0
}, w.numTotal++, w.numLoaded++, o());
}
function d(t) {
return t && t.method && t.args && t.args.length > 0;
}
function h(t, e) {
var r;
u.Util.parseBackgroundImage(t).filter(d).forEach(function (t) {
'url' === t.method ? m.loadImage(t.args[0]) : t.method.match(/\-?gradient$/) && (r === n && (r = u.Util.Bounds(e)), c(t.value, r));
});
}
function f(t) {
var e = !1;
try {
x.Children(t).forEach(f);
} catch (r) {
}
try {
e = t.nodeType;
} catch (a) {
e = !1, x.log('html2canvas: failed to access some element\'s nodeType - Exception: ' + a.message);
}
if (1 === e || e === n) {
s(t);
try {
h(x.getCSS(t, 'backgroundImage'), t);
} catch (r) {
x.log('html2canvas: failed to get background-image - Exception: ' + r.message);
}
h(t);
}
}
function p(e, a) {
e.onload = function () {
a.timer !== n && t.clearTimeout(a.timer), w.numLoaded++, a.succeeded = !0, e.onerror = e.onload = null, o();
}, e.onerror = function () {
if ('anonymous' === e.crossOrigin && (t.clearTimeout(a.timer), r.proxy)) {
var l = e.src;
return e = new Image(), a.img = e, e.src = l, i(e.src, e, a), n;
}
w.numLoaded++, w.numFailed++, a.succeeded = !1, e.onerror = e.onload = null, o();
};
}
var g, m, y, b, w = {
numLoaded: 0,
numFailed: 0,
numTotal: 0,
cleanupDone: !1
}, x = u.Util, v = 0, k = r.elements[0] || e.body, C = k.ownerDocument, T = k.getElementsByTagName('img'), S = T.length, M = C.createElement('a'), R = function (t) {
return t.crossOrigin !== n;
}(new Image());
for (M.href = t.location.href, g = M.protocol + M.host, m = {
loadImage: function (t) {
var e, o;
t && w[t] === n && (e = new Image(), t.match(/data:image\/.*;base64,/i) ? (e.src = t.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ''), o = w[t] = { img: e }, w.numTotal++, p(e, o)) : a(t) || r.allowTaint === !0 ? (o = w[t] = { img: e }, w.numTotal++, p(e, o), e.src = t) : R && !r.allowTaint && r.useCORS ? (e.crossOrigin = 'anonymous', o = w[t] = { img: e }, w.numTotal++, p(e, o), e.src = t) : r.proxy && (o = w[t] = { img: e }, w.numTotal++, i(t, e, o)));
},
cleanupDOM: function (a) {
var i, l;
if (!w.cleanupDone) {
a && 'string' == typeof a ? x.log('html2canvas: Cleanup because: ' + a) : x.log('html2canvas: Cleanup after timeout: ' + r.timeout + ' ms.');
for (l in w)
if (w.hasOwnProperty(l) && (i = w[l], 'object' == typeof i && i.callbackname && i.succeeded === n)) {
t[i.callbackname] = n;
try {
delete t[i.callbackname];
} catch (s) {
}
i.script && i.script.parentNode && (i.script.setAttribute('src', 'about:blank'), i.script.parentNode.removeChild(i.script)), w.numLoaded++, w.numFailed++, x.log('html2canvas: Cleaned up failed img: \'' + l + '\' Steps: ' + w.numLoaded + ' / ' + w.numTotal);
}
t.stop !== n ? t.stop() : e.execCommand !== n && e.execCommand('Stop', !1), e.close !== n && e.close(), w.cleanupDone = !0, a && 'string' == typeof a || o();
}
},
renderingDone: function () {
b && t.clearTimeout(b);
}
}, r.timeout > 0 && (b = t.setTimeout(m.cleanupDOM, r.timeout)), x.log('html2canvas: Preload starts: finding background-images'), w.firstRun = !0, f(k), x.log('html2canvas: Preload: Finding images'), y = 0; S > y; y += 1)
m.loadImage(T[y].getAttribute('src'));
return w.firstRun = !1, x.log('html2canvas: Preload: Done.'), w.numTotal === w.numLoaded && o(), m;
}, u.Renderer = function (t, r) {
function a(t) {
function e(t) {
Object.keys(t).sort().forEach(function (n) {
var r = [], o = [], i = [], l = [];
t[n].forEach(function (t) {
t.node.zIndex.isPositioned || 1 > t.node.zIndex.opacity ? i.push(t) : t.node.zIndex.isFloated ? o.push(t) : r.push(t);
}), function s(t) {
t.forEach(function (t) {
l.push(t), t.children && s(t.children);
});
}(r.concat(o, i)), l.forEach(function (t) {
t.context ? e(t.context) : a.push(t.node);
});
});
}
var r, a = [];
return r = function (t) {
function e(t, r, a) {
var o = 'auto' === r.zIndex.zindex ? 0 : Number(r.zIndex.zindex), i = t, l = r.zIndex.isPositioned, s = r.zIndex.isFloated, c = { node: r }, d = a;
r.zIndex.ownStacking ? (i = c.context = {
'!': [{
node: r,
children: []
}]
}, d = n) : (l || s) && (d = c.children = []), 0 === o && a ? a.push(c) : (t[o] || (t[o] = []), t[o].push(c)), r.zIndex.children.forEach(function (t) {
e(i, t, d);
});
}
var r = {};
return e(r, t), r;
}(t), e(r), a;
}
function o(t) {
var e;
if ('string' == typeof r.renderer && u.Renderer[t] !== n)
e = u.Renderer[t](r);
else {
if ('function' != typeof t)
throw Error('Unknown renderer');
e = t(r);
}
if ('function' != typeof e)
throw Error('Invalid renderer defined');
return e;
}
return o(r.renderer)(t, r, e, a(t.stack), u);
}, u.Util.Support = function (t, e) {
function r() {
var t = new Image(), r = e.createElement('canvas'), a = r.getContext === n ? !1 : r.getContext('2d');
if (a === !1)
return !1;
r.width = r.height = 10, t.src = [
'data:image/svg+xml,',
'<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'10\' height=\'10\'>',
'<foreignObject width=\'10\' height=\'10\'>',
'<div xmlns=\'http://www.w3.org/1999/xhtml\' style=\'width:10;height:10;\'>',
'sup',
'</div>',
'</foreignObject>',
'</svg>'
].join('');
try {
a.drawImage(t, 0, 0), r.toDataURL();
} catch (o) {
return !1;
}
return u.Util.log('html2canvas: Parse: SVG powered rendering available'), !0;
}
function a() {
var t, n, r, a, o = !1;
return e.createRange && (t = e.createRange(), t.getBoundingClientRect && (n = e.createElement('boundtest'), n.style.height = '123px', n.style.display = 'block', e.body.appendChild(n), t.selectNode(n), r = t.getBoundingClientRect(), a = r.height, 123 === a && (o = !0), e.body.removeChild(n))), o;
}
return {
rangeBounds: a(),
svgRendering: t.svgRendering && r()
};
}, t.html2canvas = function (e, n) {
e = e.length ? e : [e];
var r, a, o = {
logging: !1,
elements: e,
background: '#fff',
proxy: null,
timeout: 0,
useCORS: !1,
allowTaint: !1,
svgRendering: !1,
ignoreElements: 'IFRAME|OBJECT|PARAM',
useOverflow: !0,
letterRendering: !1,
chinese: !1,
width: null,
height: null,
taintTest: !0,
renderer: 'Canvas'
};
return o = u.Util.Extend(n, o), u.logging = o.logging, o.complete = function (t) {
('function' != typeof o.onpreloaded || o.onpreloaded(t) !== !1) && (r = u.Parse(t, o), ('function' != typeof o.onparsed || o.onparsed(r) !== !1) && (a = u.Renderer(r, o), 'function' == typeof o.onrendered && o.onrendered(a)));
}, t.setTimeout(function () {
u.Preload(o);
}, 0), {
render: function (t, e) {
return u.Renderer(t, u.Util.Extend(e, o));
},
parse: function (t, e) {
return u.Parse(t, u.Util.Extend(e, o));
},
preload: function (t) {
return u.Preload(u.Util.Extend(t, o));
},
log: u.Util.log
};
}, t.html2canvas.log = u.Util.log, t.html2canvas.Renderer = { Canvas: n }, u.Renderer.Canvas = function (t) {
function r(t, e) {
t.beginPath(), e.forEach(function (e) {
t[e.name].apply(t, e.arguments);
}), t.closePath();
}
function a(t) {
if (-1 === l.indexOf(t.arguments[0].src)) {
c.drawImage(t.arguments[0], 0, 0);
try {
c.getImageData(0, 0, 1, 1);
} catch (e) {
return s = i.createElement('canvas'), c = s.getContext('2d'), !1;
}
l.push(t.arguments[0].src);
}
return !0;
}
function o(e, n) {
switch (n.type) {
case 'variable':
e[n.name] = n.arguments;
break;
case 'function':
switch (n.name) {
case 'createPattern':
if (n.arguments[0].width > 0 && n.arguments[0].height > 0)
try {
e.fillStyle = e.createPattern(n.arguments[0], 'repeat');
} catch (o) {
d.log('html2canvas: Renderer: Error creating pattern', o.message);
}
break;
case 'drawShape':
r(e, n.arguments);
break;
case 'drawImage':
n.arguments[8] > 0 && n.arguments[7] > 0 && (!t.taintTest || t.taintTest && a(n)) && e.drawImage.apply(e, n.arguments);
break;
default:
e[n.name].apply(e, n.arguments);
}
}
}
t = t || {};
var i = e, l = [], s = e.createElement('canvas'), c = s.getContext('2d'), d = u.Util, h = t.canvas || i.createElement('canvas');
return function (t, e, r, a, i) {
var l, s, c, u = h.getContext('2d'), f = t.stack;
return h.width = h.style.width = e.width || f.ctx.width, h.height = h.style.height = e.height || f.ctx.height, c = u.fillStyle, u.fillStyle = d.isTransparent(f.backgroundColor) && e.background !== n ? e.background : t.backgroundColor, u.fillRect(0, 0, h.width, h.height), u.fillStyle = c, a.forEach(function (t) {
u.textBaseline = 'bottom', u.save(), t.transform.matrix && (u.translate(t.transform.origin[0], t.transform.origin[1]), u.transform.apply(u, t.transform.matrix), u.translate(-t.transform.origin[0], -t.transform.origin[1])), t.clip && (u.beginPath(), u.rect(t.clip.left, t.clip.top, t.clip.width, t.clip.height), u.clip()), t.ctx.storage && t.ctx.storage.forEach(function (t) {
o(u, t);
}), u.restore();
}), d.log('html2canvas: Renderer: Canvas renderer done - returning canvas obj'), 1 === e.elements.length && 'object' == typeof e.elements[0] && 'BODY' !== e.elements[0].nodeName ? (s = i.Util.Bounds(e.elements[0]), l = r.createElement('canvas'), l.width = Math.ceil(s.width), l.height = Math.ceil(s.height), u = l.getContext('2d'), u.drawImage(h, s.left, s.top, s.width, s.height, 0, 0, s.width, s.height), h = null, l) : h;
};
};
}(window, document));
!function (a, b) {
'use strict';
'object' == typeof module && 'object' == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) {
if (!a.document)
throw new Error('jQuery requires a window with a document');
return b(a);
} : b(a);
}('undefined' != typeof window ? window : this, function (a, b) {
'use strict';
var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c.indexOf, j = {}, k = j.toString, l = j.hasOwnProperty, m = l.toString, n = m.call(Object), o = {};
function p(a, b) {
b = b || d;
var c = b.createElement('script');
c.text = a, b.head.appendChild(c).parentNode.removeChild(c);
}
var q = '3.0.0', r = function (a, b) {
return new r.fn.init(a, b);
}, s = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, t = /^-ms-/, u = /-([a-z])/g, v = function (a, b) {
return b.toUpperCase();
};
r.fn = r.prototype = {
jquery: q,
constructor: r,
length: 0,
toArray: function () {
return f.call(this);
},
get: function (a) {
return null != a ? 0 > a ? this[a + this.length] : this[a] : f.call(this);
},
pushStack: function (a) {
var b = r.merge(this.constructor(), a);
return b.prevObject = this, b;
},
each: function (a) {
return r.each(this, a);
},
map: function (a) {
return this.pushStack(r.map(this, function (b, c) {
return a.call(b, c, b);
}));
},
slice: function () {
return this.pushStack(f.apply(this, arguments));
},
first: function () {
return this.eq(0);
},
last: function () {
return this.eq(-1);
},
eq: function (a) {
var b = this.length, c = +a + (0 > a ? b : 0);
return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
},
end: function () {
return this.prevObject || this.constructor();
},
push: h,
sort: c.sort,
splice: c.splice
}, r.extend = r.fn.extend = function () {
var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
for ('boolean' == typeof g && (j = g, g = arguments[h] || {}, h++), 'object' == typeof g || r.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
if (null != (a = arguments[h]))
for (b in a)
c = g[b], d = a[b], g !== d && (j && d && (r.isPlainObject(d) || (e = r.isArray(d))) ? (e ? (e = !1, f = c && r.isArray(c) ? c : []) : f = c && r.isPlainObject(c) ? c : {}, g[b] = r.extend(j, f, d)) : void 0 !== d && (g[b] = d));
return g;
}, r.extend({
expando: 'jQuery' + (q + Math.random()).replace(/\D/g, ''),
isReady: !0,
error: function (a) {
throw new Error(a);
},
noop: function () {
},
isFunction: function (a) {
return 'function' === r.type(a);
},
isArray: Array.isArray,
isWindow: function (a) {
return null != a && a === a.window;
},
isNumeric: function (a) {
var b = r.type(a);
return ('number' === b || 'string' === b) && !isNaN(a - parseFloat(a));
},
isPlainObject: function (a) {
var b, c;
return a && '[object Object]' === k.call(a) ? (b = e(a)) ? (c = l.call(b, 'constructor') && b.constructor, 'function' == typeof c && m.call(c) === n) : !0 : !1;
},
isEmptyObject: function (a) {
var b;
for (b in a)
return !1;
return !0;
},
type: function (a) {
return null == a ? a + '' : 'object' == typeof a || 'function' == typeof a ? j[k.call(a)] || 'object' : typeof a;
},
globalEval: function (a) {
p(a);
},
camelCase: function (a) {
return a.replace(t, 'ms-').replace(u, v);
},
nodeName: function (a, b) {
return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
},
each: function (a, b) {
var c, d = 0;
if (w(a)) {
for (c = a.length; c > d; d++)
if (b.call(a[d], d, a[d]) === !1)
break;
} else
for (d in a)
if (b.call(a[d], d, a[d]) === !1)
break;
return a;
},
trim: function (a) {
return null == a ? '' : (a + '').replace(s, '');
},
makeArray: function (a, b) {
var c = b || [];
return null != a && (w(Object(a)) ? r.merge(c, 'string' == typeof a ? [a] : a) : h.call(c, a)), c;
},
inArray: function (a, b, c) {
return null == b ? -1 : i.call(b, a, c);
},
merge: function (a, b) {
for (var c = +b.length, d = 0, e = a.length; c > d; d++)
a[e++] = b[d];
return a.length = e, a;
},
grep: function (a, b, c) {
for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)
d = !b(a[f], f), d !== h && e.push(a[f]);
return e;
},
map: function (a, b, c) {
var d, e, f = 0, h = [];
if (w(a))
for (d = a.length; d > f; f++)
e = b(a[f], f, c), null != e && h.push(e);
else
for (f in a)
e = b(a[f], f, c), null != e && h.push(e);
return g.apply([], h);
},
guid: 1,
proxy: function (a, b) {
var c, d, e;
return 'string' == typeof b && (c = a[b], b = a, a = c), r.isFunction(a) ? (d = f.call(arguments, 2), e = function () {
return a.apply(b || this, d.concat(f.call(arguments)));
}, e.guid = a.guid = a.guid || r.guid++, e) : void 0;
},
now: Date.now,
support: o
}), 'function' == typeof Symbol && (r.fn[Symbol.iterator] = c[Symbol.iterator]), r.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (a, b) {
j['[object ' + b + ']'] = b.toLowerCase();
});
function w(a) {
var b = !!a && 'length' in a && a.length, c = r.type(a);
return 'function' === c || r.isWindow(a) ? !1 : 'array' === c || 0 === b || 'number' == typeof b && b > 0 && b - 1 in a;
}
var x = function (a) {
var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = 'sizzle' + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function (a, b) {
return a === b && (l = !0), 0;
}, C = {}.hasOwnProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, I = function (a, b) {
for (var c = 0, d = a.length; d > c; c++)
if (a[c] === b)
return c;
return -1;
}, J = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', K = '[\\x20\\t\\r\\n\\f]', L = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', M = '\\[' + K + '*(' + L + ')(?:' + K + '*([*^$|!~]?=)' + K + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + L + '))|)' + K + '*\\]', N = ':(' + L + ')(?:\\(((\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|' + M + ')*)|.*)\\)|)', O = new RegExp(K + '+', 'g'), P = new RegExp('^' + K + '+|((?:^|[^\\\\])(?:\\\\.)*)' + K + '+$', 'g'), Q = new RegExp('^' + K + '*,' + K + '*'), R = new RegExp('^' + K + '*([>+~]|' + K + ')' + K + '*'), S = new RegExp('=' + K + '*([^\\]\'"]*?)' + K + '*\\]', 'g'), T = new RegExp(N), U = new RegExp('^' + L + '$'), V = {
ID: new RegExp('^#(' + L + ')'),
CLASS: new RegExp('^\\.(' + L + ')'),
TAG: new RegExp('^(' + L + '|[*])'),
ATTR: new RegExp('^' + M),
PSEUDO: new RegExp('^' + N),
CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + K + '*(even|odd|(([+-]|)(\\d*)n|)' + K + '*(?:([+-]|)' + K + '*(\\d+)|))' + K + '*\\)|)', 'i'),
bool: new RegExp('^(?:' + J + ')$', 'i'),
needsContext: new RegExp('^' + K + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + K + '*((?:-\\d)?\\d*)' + K + '*\\)|)(?=[^-]|$)', 'i')
}, W = /^(?:input|select|textarea|button)$/i, X = /^h\d$/i, Y = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, $ = /[+~]/, _ = new RegExp('\\\\([\\da-f]{1,6}' + K + '?|(' + K + ')|.)', 'ig'), aa = function (a, b, c) {
var d = '0x' + b - 65536;
return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
}, ba = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, ca = function (a, b) {
return b ? '\0' === a ? '\uFFFD' : a.slice(0, -1) + '\\' + a.charCodeAt(a.length - 1).toString(16) + ' ' : '\\' + a;
}, da = function () {
m();
}, ea = ta(function (a) {
return a.disabled === !0;
}, {
dir: 'parentNode',
next: 'legend'
});
try {
G.apply(D = H.call(v.childNodes), v.childNodes), D[v.childNodes.length].nodeType;
} catch (fa) {
G = {
apply: D.length ? function (a, b) {
F.apply(a, H.call(b));
} : function (a, b) {
var c = a.length, d = 0;
while (a[c++] = b[d++]);
a.length = c - 1;
}
};
}
function ga(a, b, d, e) {
var f, h, j, k, l, o, r, s = b && b.ownerDocument, w = b ? b.nodeType : 9;
if (d = d || [], 'string' != typeof a || !a || 1 !== w && 9 !== w && 11 !== w)
return d;
if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {
if (11 !== w && (l = Z.exec(a)))
if (f = l[1]) {
if (9 === w) {
if (!(j = b.getElementById(f)))
return d;
if (j.id === f)
return d.push(j), d;
} else if (s && (j = s.getElementById(f)) && t(b, j) && j.id === f)
return d.push(j), d;
} else {
if (l[2])
return G.apply(d, b.getElementsByTagName(a)), d;
if ((f = l[3]) && c.getElementsByClassName && b.getElementsByClassName)
return G.apply(d, b.getElementsByClassName(f)), d;
}
if (c.qsa && !A[a + ' '] && (!q || !q.test(a))) {
if (1 !== w)
s = b, r = a;
else if ('object' !== b.nodeName.toLowerCase()) {
(k = b.getAttribute('id')) ? k = k.replace(ba, ca) : b.setAttribute('id', k = u), o = g(a), h = o.length;
while (h--)
o[h] = '#' + k + ' ' + sa(o[h]);
r = o.join(','), s = $.test(a) && qa(b.parentNode) || b;
}
if (r)
try {
return G.apply(d, s.querySelectorAll(r)), d;
} catch (x) {
} finally {
k === u && b.removeAttribute('id');
}
}
}
return i(a.replace(P, '$1'), b, d, e);
}
function ha() {
var a = [];
function b(c, e) {
return a.push(c + ' ') > d.cacheLength && delete b[a.shift()], b[c + ' '] = e;
}
return b;
}
function ia(a) {
return a[u] = !0, a;
}
function ja(a) {
var b = n.createElement('fieldset');
try {
return !!a(b);
} catch (c) {
return !1;
} finally {
b.parentNode && b.parentNode.removeChild(b), b = null;
}
}
function ka(a, b) {
var c = a.split('|'), e = c.length;
while (e--)
d.attrHandle[c[e]] = b;
}
function la(a, b) {
var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
if (d)
return d;
if (c)
while (c = c.nextSibling)
if (c === b)
return -1;
return a ? 1 : -1;
}
function ma(a) {
return function (b) {
var c = b.nodeName.toLowerCase();
return 'input' === c && b.type === a;
};
}
function na(a) {
return function (b) {
var c = b.nodeName.toLowerCase();
return ('input' === c || 'button' === c) && b.type === a;
};
}
function oa(a) {
return function (b) {
return 'label' in b && b.disabled === a || 'form' in b && b.disabled === a || 'form' in b && b.disabled === !1 && (b.isDisabled === a || b.isDisabled !== !a && ('label' in b || !ea(b)) !== a);
};
}
function pa(a) {
return ia(function (b) {
return b = +b, ia(function (c, d) {
var e, f = a([], c.length, b), g = f.length;
while (g--)
c[e = f[g]] && (c[e] = !(d[e] = c[e]));
});
});
}
function qa(a) {
return a && 'undefined' != typeof a.getElementsByTagName && a;
}
c = ga.support = {}, f = ga.isXML = function (a) {
var b = a && (a.ownerDocument || a).documentElement;
return b ? 'HTML' !== b.nodeName : !1;
}, m = ga.setDocument = function (a) {
var b, e, g = a ? a.ownerDocument || a : v;
return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), v !== n && (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener('unload', da, !1) : e.attachEvent && e.attachEvent('onunload', da)), c.attributes = ja(function (a) {
return a.className = 'i', !a.getAttribute('className');
}), c.getElementsByTagName = ja(function (a) {
return a.appendChild(n.createComment('')), !a.getElementsByTagName('*').length;
}), c.getElementsByClassName = Y.test(n.getElementsByClassName), c.getById = ja(function (a) {
return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;
}), c.getById ? (d.find.ID = function (a, b) {
if ('undefined' != typeof b.getElementById && p) {
var c = b.getElementById(a);
return c ? [c] : [];
}
}, d.filter.ID = function (a) {
var b = a.replace(_, aa);
return function (a) {
return a.getAttribute('id') === b;
};
}) : (delete d.find.ID, d.filter.ID = function (a) {
var b = a.replace(_, aa);
return function (a) {
var c = 'undefined' != typeof a.getAttributeNode && a.getAttributeNode('id');
return c && c.value === b;
};
}), d.find.TAG = c.getElementsByTagName ? function (a, b) {
return 'undefined' != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
} : function (a, b) {
var c, d = [], e = 0, f = b.getElementsByTagName(a);
if ('*' === a) {
while (c = f[e++])
1 === c.nodeType && d.push(c);
return d;
}
return f;
}, d.find.CLASS = c.getElementsByClassName && function (a, b) {
return 'undefined' != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;
}, r = [], q = [], (c.qsa = Y.test(n.querySelectorAll)) && (ja(function (a) {
o.appendChild(a).innerHTML = '<a id=\'' + u + '\'></a><select id=\'' + u + '-\r\\\' msallowcapture=\'\'><option selected=\'\'></option></select>', a.querySelectorAll('[msallowcapture^=\'\']').length && q.push('[*^$]=' + K + '*(?:\'\'|"")'), a.querySelectorAll('[selected]').length || q.push('\\[' + K + '*(?:value|' + J + ')'), a.querySelectorAll('[id~=' + u + '-]').length || q.push('~='), a.querySelectorAll(':checked').length || q.push(':checked'), a.querySelectorAll('a#' + u + '+*').length || q.push('.#.+[+~]');
}), ja(function (a) {
a.innerHTML = '<a href=\'\' disabled=\'disabled\'></a><select disabled=\'disabled\'><option/></select>';
var b = n.createElement('input');
b.setAttribute('type', 'hidden'), a.appendChild(b).setAttribute('name', 'D'), a.querySelectorAll('[name=d]').length && q.push('name' + K + '*[*^$|!~]?='), 2 !== a.querySelectorAll(':enabled').length && q.push(':enabled', ':disabled'), o.appendChild(a).disabled = !0, 2 !== a.querySelectorAll(':disabled').length && q.push(':enabled', ':disabled'), a.querySelectorAll('*,:x'), q.push(',.*:');
})), (c.matchesSelector = Y.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function (a) {
c.disconnectedMatch = s.call(a, '*'), s.call(a, '[s!=\'\']:x'), r.push('!=', N);
}), q = q.length && new RegExp(q.join('|')), r = r.length && new RegExp(r.join('|')), b = Y.test(o.compareDocumentPosition), t = b || Y.test(o.contains) ? function (a, b) {
var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
} : function (a, b) {
if (b)
while (b = b.parentNode)
if (b === a)
return !0;
return !1;
}, B = b ? function (a, b) {
if (a === b)
return l = !0, 0;
var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? I(k, a) - I(k, b) : 0 : 4 & d ? -1 : 1);
} : function (a, b) {
if (a === b)
return l = !0, 0;
var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b];
if (!e || !f)
return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? I(k, a) - I(k, b) : 0;
if (e === f)
return la(a, b);
c = a;
while (c = c.parentNode)
g.unshift(c);
c = b;
while (c = c.parentNode)
h.unshift(c);
while (g[d] === h[d])
d++;
return d ? la(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;
}, n) : n;
}, ga.matches = function (a, b) {
return ga(a, null, null, b);
}, ga.matchesSelector = function (a, b) {
if ((a.ownerDocument || a) !== n && m(a), b = b.replace(S, '=\'$1\']'), c.matchesSelector && p && !A[b + ' '] && (!r || !r.test(b)) && (!q || !q.test(b)))
try {
var d = s.call(a, b);
if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType)
return d;
} catch (e) {
}
return ga(b, n, null, [a]).length > 0;
}, ga.contains = function (a, b) {
return (a.ownerDocument || a) !== n && m(a), t(a, b);
}, ga.attr = function (a, b) {
(a.ownerDocument || a) !== n && m(a);
var e = d.attrHandle[b.toLowerCase()], f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
}, ga.escape = function (a) {
return (a + '').replace(ba, ca);
}, ga.error = function (a) {
throw new Error('Syntax error, unrecognized expression: ' + a);
}, ga.uniqueSort = function (a) {
var b, d = [], e = 0, f = 0;
if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
while (b = a[f++])
b === a[f] && (e = d.push(f));
while (e--)
a.splice(d[e], 1);
}
return k = null, a;
}, e = ga.getText = function (a) {
var b, c = '', d = 0, f = a.nodeType;
if (f) {
if (1 === f || 9 === f || 11 === f) {
if ('string' == typeof a.textContent)
return a.textContent;
for (a = a.firstChild; a; a = a.nextSibling)
c += e(a);
} else if (3 === f || 4 === f)
return a.nodeValue;
} else
while (b = a[d++])
c += e(b);
return c;
}, d = ga.selectors = {
cacheLength: 50,
createPseudo: ia,
match: V,
attrHandle: {},
find: {},
relative: {
'>': {
dir: 'parentNode',
first: !0
},
' ': { dir: 'parentNode' },
'+': {
dir: 'previousSibling',
first: !0
},
'~': { dir: 'previousSibling' }
},
preFilter: {
ATTR: function (a) {
return a[1] = a[1].replace(_, aa), a[3] = (a[3] || a[4] || a[5] || '').replace(_, aa), '~=' === a[2] && (a[3] = ' ' + a[3] + ' '), a.slice(0, 4);
},
CHILD: function (a) {
return a[1] = a[1].toLowerCase(), 'nth' === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ('even' === a[3] || 'odd' === a[3])), a[5] = +(a[7] + a[8] || 'odd' === a[3])) : a[3] && ga.error(a[0]), a;
},
PSEUDO: function (a) {
var b, c = !a[6] && a[2];
return V.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || '' : c && T.test(c) && (b = g(c, !0)) && (b = c.indexOf(')', c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));
}
},
filter: {
TAG: function (a) {
var b = a.replace(_, aa).toLowerCase();
return '*' === a ? function () {
return !0;
} : function (a) {
return a.nodeName && a.nodeName.toLowerCase() === b;
};
},
CLASS: function (a) {
var b = y[a + ' '];
return b || (b = new RegExp('(^|' + K + ')' + a + '(' + K + '|$)')) && y(a, function (a) {
return b.test('string' == typeof a.className && a.className || 'undefined' != typeof a.getAttribute && a.getAttribute('class') || '');
});
},
ATTR: function (a, b, c) {
return function (d) {
var e = ga.attr(d, a);
return null == e ? '!=' === b : b ? (e += '', '=' === b ? e === c : '!=' === b ? e !== c : '^=' === b ? c && 0 === e.indexOf(c) : '*=' === b ? c && e.indexOf(c) > -1 : '$=' === b ? c && e.slice(-c.length) === c : '~=' === b ? (' ' + e.replace(O, ' ') + ' ').indexOf(c) > -1 : '|=' === b ? e === c || e.slice(0, c.length + 1) === c + '-' : !1) : !0;
};
},
CHILD: function (a, b, c, d, e) {
var f = 'nth' !== a.slice(0, 3), g = 'last' !== a.slice(-4), h = 'of-type' === b;
return 1 === d && 0 === e ? function (a) {
return !!a.parentNode;
} : function (b, c, i) {
var j, k, l, m, n, o, p = f !== g ? 'nextSibling' : 'previousSibling', q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h, t = !1;
if (q) {
if (f) {
while (p) {
m = b;
while (m = m[p])
if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType)
return !1;
o = p = 'only' === a && !o && 'nextSibling';
}
return !0;
}
if (o = [g ? q.firstChild : q.lastChild], g && s) {
m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];
while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
if (1 === m.nodeType && ++t && m === b) {
k[a] = [
w,
n,
t
];
break;
}
} else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1)
while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [
w,
t
]), m === b))
break;
return t -= e, t === d || t % d === 0 && t / d >= 0;
}
};
},
PSEUDO: function (a, b) {
var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error('unsupported pseudo: ' + a);
return e[u] ? e(b) : e.length > 1 ? (c = [
a,
a,
'',
b
], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {
var d, f = e(a, b), g = f.length;
while (g--)
d = I(a, f[g]), a[d] = !(c[d] = f[g]);
}) : function (a) {
return e(a, 0, c);
}) : e;
}
},
pseudos: {
not: ia(function (a) {
var b = [], c = [], d = h(a.replace(P, '$1'));
return d[u] ? ia(function (a, b, c, e) {
var f, g = d(a, null, e, []), h = a.length;
while (h--)
(f = g[h]) && (a[h] = !(b[h] = f));
}) : function (a, e, f) {
return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
};
}),
has: ia(function (a) {
return function (b) {
return ga(a, b).length > 0;
};
}),
contains: ia(function (a) {
return a = a.replace(_, aa), function (b) {
return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
};
}),
lang: ia(function (a) {
return U.test(a || '') || ga.error('unsupported lang: ' + a), a = a.replace(_, aa).toLowerCase(), function (b) {
var c;
do
if (c = p ? b.lang : b.getAttribute('xml:lang') || b.getAttribute('lang'))
return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + '-');
while ((b = b.parentNode) && 1 === b.nodeType);
return !1;
};
}),
target: function (b) {
var c = a.location && a.location.hash;
return c && c.slice(1) === b.id;
},
root: function (a) {
return a === o;
},
focus: function (a) {
return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
},
enabled: oa(!1),
disabled: oa(!0),
checked: function (a) {
var b = a.nodeName.toLowerCase();
return 'input' === b && !!a.checked || 'option' === b && !!a.selected;
},
selected: function (a) {
return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
},
empty: function (a) {
for (a = a.firstChild; a; a = a.nextSibling)
if (a.nodeType < 6)
return !1;
return !0;
},
parent: function (a) {
return !d.pseudos.empty(a);
},
header: function (a) {
return X.test(a.nodeName);
},
input: function (a) {
return W.test(a.nodeName);
},
button: function (a) {
var b = a.nodeName.toLowerCase();
return 'input' === b && 'button' === a.type || 'button' === b;
},
text: function (a) {
var b;
return 'input' === a.nodeName.toLowerCase() && 'text' === a.type && (null == (b = a.getAttribute('type')) || 'text' === b.toLowerCase());
},
first: pa(function () {
return [0];
}),
last: pa(function (a, b) {
return [b - 1];
}),
eq: pa(function (a, b, c) {
return [0 > c ? c + b : c];
}),
even: pa(function (a, b) {
for (var c = 0; b > c; c += 2)
a.push(c);
return a;
}),
odd: pa(function (a, b) {
for (var c = 1; b > c; c += 2)
a.push(c);
return a;
}),
lt: pa(function (a, b, c) {
for (var d = 0 > c ? c + b : c; --d >= 0;)
a.push(d);
return a;
}),
gt: pa(function (a, b, c) {
for (var d = 0 > c ? c + b : c; ++d < b;)
a.push(d);
return a;
})
}
}, d.pseudos.nth = d.pseudos.eq;
for (b in {
radio: !0,
checkbox: !0,
file: !0,
password: !0,
image: !0
})
d.pseudos[b] = ma(b);
for (b in {
submit: !0,
reset: !0
})
d.pseudos[b] = na(b);
function ra() {
}
ra.prototype = d.filters = d.pseudos, d.setFilters = new ra(), g = ga.tokenize = function (a, b) {
var c, e, f, g, h, i, j, k = z[a + ' '];
if (k)
return b ? 0 : k.slice(0);
h = a, i = [], j = d.preFilter;
while (h) {
c && !(e = Q.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({
value: c,
type: e[0].replace(P, ' ')
}), h = h.slice(c.length));
for (g in d.filter)
!(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
value: c,
type: g,
matches: e
}), h = h.slice(c.length));
if (!c)
break;
}
return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
};
function sa(a) {
for (var b = 0, c = a.length, d = ''; c > b; b++)
d += a[b].value;
return d;
}
function ta(a, b, c) {
var d = b.dir, e = b.next, f = e || d, g = c && 'parentNode' === f, h = x++;
return b.first ? function (b, c, e) {
while (b = b[d])
if (1 === b.nodeType || g)
return a(b, c, e);
} : function (b, c, i) {
var j, k, l, m = [
w,
h
];
if (i) {
while (b = b[d])
if ((1 === b.nodeType || g) && a(b, c, i))
return !0;
} else
while (b = b[d])
if (1 === b.nodeType || g)
if (l = b[u] || (b[u] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase())
b = b[d] || b;
else {
if ((j = k[f]) && j[0] === w && j[1] === h)
return m[2] = j[2];
if (k[f] = m, m[2] = a(b, c, i))
return !0;
}
};
}
function ua(a) {
return a.length > 1 ? function (b, c, d) {
var e = a.length;
while (e--)
if (!a[e](b, c, d))
return !1;
return !0;
} : a[0];
}
function va(a, b, c) {
for (var d = 0, e = b.length; e > d; d++)
ga(a, b[d], c);
return c;
}
function wa(a, b, c, d, e) {
for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)
(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
return g;
}
function xa(a, b, c, d, e, f) {
return d && !d[u] && (d = xa(d)), e && !e[u] && (e = xa(e, f)), ia(function (f, g, h, i) {
var j, k, l, m = [], n = [], o = g.length, p = f || va(b || '*', h.nodeType ? [h] : h, []), q = !a || !f && b ? p : wa(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
if (c && c(q, r, h, i), d) {
j = wa(r, n), d(j, [], h, i), k = j.length;
while (k--)
(l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
}
if (f) {
if (e || a) {
if (e) {
j = [], k = r.length;
while (k--)
(l = r[k]) && j.push(q[k] = l);
e(null, r = [], j, i);
}
k = r.length;
while (k--)
(l = r[k]) && (j = e ? I(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
}
} else
r = wa(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r);
});
}
function ya(a) {
for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[' '], i = g ? 1 : 0, k = ta(function (a) {
return a === b;
}, h, !0), l = ta(function (a) {
return I(b, a) > -1;
}, h, !0), m = [function (a, c, d) {
var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
return b = null, e;
}]; f > i; i++)
if (c = d.relative[a[i].type])
m = [ta(ua(m), c)];
else {
if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
for (e = ++i; f > e; e++)
if (d.relative[a[e].type])
break;
return xa(i > 1 && ua(m), i > 1 && sa(a.slice(0, i - 1).concat({ value: ' ' === a[i - 2].type ? '*' : '' })).replace(P, '$1'), c, e > i && ya(a.slice(i, e)), f > e && ya(a = a.slice(e)), f > e && sa(a));
}
m.push(c);
}
return ua(m);
}
function za(a, b) {
var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) {
var l, o, q, r = 0, s = '0', t = f && [], u = [], v = j, x = f || e && d.find.TAG('*', k), y = w += null == v ? 1 : Math.random() || 0.1, z = x.length;
for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {
if (e && l) {
o = 0, g || l.ownerDocument === n || (m(l), h = !p);
while (q = a[o++])
if (q(l, g || n, h)) {
i.push(l);
break;
}
k && (w = y);
}
c && ((l = !q && l) && r--, f && t.push(l));
}
if (r += s, c && s !== r) {
o = 0;
while (q = b[o++])
q(t, u, g, h);
if (f) {
if (r > 0)
while (s--)
t[s] || u[s] || (u[s] = E.call(i));
u = wa(u);
}
G.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && ga.uniqueSort(i);
}
return k && (w = y, j = v), t;
};
return c ? ia(f) : f;
}
return h = ga.compile = function (a, b) {
var c, d = [], e = [], f = A[a + ' '];
if (!f) {
b || (b = g(a)), c = b.length;
while (c--)
f = ya(b[c]), f[u] ? d.push(f) : e.push(f);
f = A(a, za(e, d)), f.selector = a;
}
return f;
}, i = ga.select = function (a, b, e, f) {
var i, j, k, l, m, n = 'function' == typeof a && a, o = !f && g(a = n.selector || a);
if (e = e || [], 1 === o.length) {
if (j = o[0] = o[0].slice(0), j.length > 2 && 'ID' === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
if (b = (d.find.ID(k.matches[0].replace(_, aa), b) || [])[0], !b)
return e;
n && (b = b.parentNode), a = a.slice(j.shift().value.length);
}
i = V.needsContext.test(a) ? 0 : j.length;
while (i--) {
if (k = j[i], d.relative[l = k.type])
break;
if ((m = d.find[l]) && (f = m(k.matches[0].replace(_, aa), $.test(j[0].type) && qa(b.parentNode) || b))) {
if (j.splice(i, 1), a = f.length && sa(j), !a)
return G.apply(e, f), e;
break;
}
}
}
return (n || h(a, o))(f, b, !p, e, !b || $.test(a) && qa(b.parentNode) || b), e;
}, c.sortStable = u.split('').sort(B).join('') === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function (a) {
return 1 & a.compareDocumentPosition(n.createElement('fieldset'));
}), ja(function (a) {
return a.innerHTML = '<a href=\'#\'></a>', '#' === a.firstChild.getAttribute('href');
}) || ka('type|href|height|width', function (a, b, c) {
return c ? void 0 : a.getAttribute(b, 'type' === b.toLowerCase() ? 1 : 2);
}), c.attributes && ja(function (a) {
return a.innerHTML = '<input/>', a.firstChild.setAttribute('value', ''), '' === a.firstChild.getAttribute('value');
}) || ka('value', function (a, b, c) {
return c || 'input' !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
}), ja(function (a) {
return null == a.getAttribute('disabled');
}) || ka(J, function (a, b, c) {
var d;
return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
}), ga;
}(a);
r.find = x, r.expr = x.selectors, r.expr[':'] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape;
var y = function (a, b, c) {
var d = [], e = void 0 !== c;
while ((a = a[b]) && 9 !== a.nodeType)
if (1 === a.nodeType) {
if (e && r(a).is(c))
break;
d.push(a);
}
return d;
}, z = function (a, b) {
for (var c = []; a; a = a.nextSibling)
1 === a.nodeType && a !== b && c.push(a);
return c;
}, A = r.expr.match.needsContext, B = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, C = /^.[^:#\[\.,]*$/;
function D(a, b, c) {
if (r.isFunction(b))
return r.grep(a, function (a, d) {
return !!b.call(a, d, a) !== c;
});
if (b.nodeType)
return r.grep(a, function (a) {
return a === b !== c;
});
if ('string' == typeof b) {
if (C.test(b))
return r.filter(b, a, c);
b = r.filter(b, a);
}
return r.grep(a, function (a) {
return i.call(b, a) > -1 !== c && 1 === a.nodeType;
});
}
r.filter = function (a, b, c) {
var d = b[0];
return c && (a = ':not(' + a + ')'), 1 === b.length && 1 === d.nodeType ? r.find.matchesSelector(d, a) ? [d] : [] : r.find.matches(a, r.grep(b, function (a) {
return 1 === a.nodeType;
}));
}, r.fn.extend({
find: function (a) {
var b, c, d = this.length, e = this;
if ('string' != typeof a)
return this.pushStack(r(a).filter(function () {
for (b = 0; d > b; b++)
if (r.contains(e[b], this))
return !0;
}));
for (c = this.pushStack([]), b = 0; d > b; b++)
r.find(a, e[b], c);
return d > 1 ? r.uniqueSort(c) : c;
},
filter: function (a) {
return this.pushStack(D(this, a || [], !1));
},
not: function (a) {
return this.pushStack(D(this, a || [], !0));
},
is: function (a) {
return !!D(this, 'string' == typeof a && A.test(a) ? r(a) : a || [], !1).length;
}
});
var E, F = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, G = r.fn.init = function (a, b, c) {
var e, f;
if (!a)
return this;
if (c = c || E, 'string' == typeof a) {
if (e = '<' === a[0] && '>' === a[a.length - 1] && a.length >= 3 ? [
null,
a,
null
] : F.exec(a), !e || !e[1] && b)
return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
if (e[1]) {
if (b = b instanceof r ? b[0] : b, r.merge(this, r.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), B.test(e[1]) && r.isPlainObject(b))
for (e in b)
r.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);
return this;
}
return f = d.getElementById(e[2]), f && (this[0] = f, this.length = 1), this;
}
return a.nodeType ? (this[0] = a, this.length = 1, this) : r.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(r) : r.makeArray(a, this);
};
G.prototype = r.fn, E = r(d);
var H = /^(?:parents|prev(?:Until|All))/, I = {
children: !0,
contents: !0,
next: !0,
prev: !0
};
r.fn.extend({
has: function (a) {
var b = r(a, this), c = b.length;
return this.filter(function () {
for (var a = 0; c > a; a++)
if (r.contains(this, b[a]))
return !0;
});
},
closest: function (a, b) {
var c, d = 0, e = this.length, f = [], g = 'string' != typeof a && r(a);
if (!A.test(a))
for (; e > d; d++)
for (c = this[d]; c && c !== b; c = c.parentNode)
if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && r.find.matchesSelector(c, a))) {
f.push(c);
break;
}
return this.pushStack(f.length > 1 ? r.uniqueSort(f) : f);
},
index: function (a) {
return a ? 'string' == typeof a ? i.call(r(a), this[0]) : i.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
},
add: function (a, b) {
return this.pushStack(r.uniqueSort(r.merge(this.get(), r(a, b))));
},
addBack: function (a) {
return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
}
});
function J(a, b) {
while ((a = a[b]) && 1 !== a.nodeType);
return a;
}
r.each({
parent: function (a) {
var b = a.parentNode;
return b && 11 !== b.nodeType ? b : null;
},
parents: function (a) {
return y(a, 'parentNode');
},
parentsUntil: function (a, b, c) {
return y(a, 'parentNode', c);
},
next: function (a) {
return J(a, 'nextSibling');
},
prev: function (a) {
return J(a, 'previousSibling');
},
nextAll: function (a) {
return y(a, 'nextSibling');
},
prevAll: function (a) {
return y(a, 'previousSibling');
},
nextUntil: function (a, b, c) {
return y(a, 'nextSibling', c);
},
prevUntil: function (a, b, c) {
return y(a, 'previousSibling', c);
},
siblings: function (a) {
return z((a.parentNode || {}).firstChild, a);
},
children: function (a) {
return z(a.firstChild);
},
contents: function (a) {
return a.contentDocument || r.merge([], a.childNodes);
}
}, function (a, b) {
r.fn[a] = function (c, d) {
var e = r.map(this, b, c);
return 'Until' !== a.slice(-5) && (d = c), d && 'string' == typeof d && (e = r.filter(d, e)), this.length > 1 && (I[a] || r.uniqueSort(e), H.test(a) && e.reverse()), this.pushStack(e);
};
});
var K = /\S+/g;
function L(a) {
var b = {};
return r.each(a.match(K) || [], function (a, c) {
b[c] = !0;
}), b;
}
r.Callbacks = function (a) {
a = 'string' == typeof a ? L(a) : r.extend({}, a);
var b, c, d, e, f = [], g = [], h = -1, i = function () {
for (e = a.once, d = b = !0; g.length; h = -1) {
c = g.shift();
while (++h < f.length)
f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);
}
a.memory || (c = !1), b = !1, e && (f = c ? [] : '');
}, j = {
add: function () {
return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {
r.each(b, function (b, c) {
r.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && 'string' !== r.type(c) && d(c);
});
}(arguments), c && !b && i()), this;
},
remove: function () {
return r.each(arguments, function (a, b) {
var c;
while ((c = r.inArray(b, f, c)) > -1)
f.splice(c, 1), h >= c && h--;
}), this;
},
has: function (a) {
return a ? r.inArray(a, f) > -1 : f.length > 0;
},
empty: function () {
return f && (f = []), this;
},
disable: function () {
return e = g = [], f = c = '', this;
},
disabled: function () {
return !f;
},
lock: function () {
return e = g = [], c || b || (f = c = ''), this;
},
locked: function () {
return !!e;
},
fireWith: function (a, c) {
return e || (c = c || [], c = [
a,
c.slice ? c.slice() : c
], g.push(c), b || i()), this;
},
fire: function () {
return j.fireWith(this, arguments), this;
},
fired: function () {
return !!d;
}
};
return j;
};
function M(a) {
return a;
}
function N(a) {
throw a;
}
function O(a, b, c) {
var d;
try {
a && r.isFunction(d = a.promise) ? d.call(a).done(b).fail(c) : a && r.isFunction(d = a.then) ? d.call(a, b, c) : b.call(void 0, a);
} catch (a) {
c.call(void 0, a);
}
}
r.extend({
Deferred: function (b) {
var c = [
[
'notify',
'progress',
r.Callbacks('memory'),
r.Callbacks('memory'),
2
],
[
'resolve',
'done',
r.Callbacks('once memory'),
r.Callbacks('once memory'),
0,
'resolved'
],
[
'reject',
'fail',
r.Callbacks('once memory'),
r.Callbacks('once memory'),
1,
'rejected'
]
], d = 'pending', e = {
state: function () {
return d;
},
always: function () {
return f.done(arguments).fail(arguments), this;
},
'catch': function (a) {
return e.then(null, a);
},
pipe: function () {
var a = arguments;
return r.Deferred(function (b) {
r.each(c, function (c, d) {
var e = r.isFunction(a[d[4]]) && a[d[4]];
f[d[1]](function () {
var a = e && e.apply(this, arguments);
a && r.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + 'With'](this, e ? [a] : arguments);
});
}), a = null;
}).promise();
},
then: function (b, d, e) {
var f = 0;
function g(b, c, d, e) {
return function () {
var h = this, i = arguments, j = function () {
var a, j;
if (!(f > b)) {
if (a = d.apply(h, i), a === c.promise())
throw new TypeError('Thenable self-resolution');
j = a && ('object' == typeof a || 'function' == typeof a) && a.then, r.isFunction(j) ? e ? j.call(a, g(f, c, M, e), g(f, c, N, e)) : (f++, j.call(a, g(f, c, M, e), g(f, c, N, e), g(f, c, M, c.notifyWith))) : (d !== M && (h = void 0, i = [a]), (e || c.resolveWith)(h, i));
}
}, k = e ? j : function () {
try {
j();
} catch (a) {
r.Deferred.exceptionHook && r.Deferred.exceptionHook(a, k.stackTrace), b + 1 >= f && (d !== N && (h = void 0, i = [a]), c.rejectWith(h, i));
}
};
b ? k() : (r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook()), a.setTimeout(k));
};
}
return r.Deferred(function (a) {
c[0][3].add(g(0, a, r.isFunction(e) ? e : M, a.notifyWith)), c[1][3].add(g(0, a, r.isFunction(b) ? b : M)), c[2][3].add(g(0, a, r.isFunction(d) ? d : N));
}).promise();
},
promise: function (a) {
return null != a ? r.extend(a, e) : e;
}
}, f = {};
return r.each(c, function (a, b) {
var g = b[2], h = b[5];
e[b[1]] = g.add, h && g.add(function () {
d = h;
}, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function () {
return f[b[0] + 'With'](this === f ? void 0 : this, arguments), this;
}, f[b[0] + 'With'] = g.fireWith;
}), e.promise(f), b && b.call(f, f), f;
},
when: function (a) {
var b = arguments.length, c = b, d = Array(c), e = f.call(arguments), g = r.Deferred(), h = function (a) {
return function (c) {
d[a] = this, e[a] = arguments.length > 1 ? f.call(arguments) : c, --b || g.resolveWith(d, e);
};
};
if (1 >= b && (O(a, g.done(h(c)).resolve, g.reject), 'pending' === g.state() || r.isFunction(e[c] && e[c].then)))
return g.then();
while (c--)
O(e[c], h(c), g.reject);
return g.promise();
}
});
var P = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
r.Deferred.exceptionHook = function (b, c) {
a.console && a.console.warn && b && P.test(b.name) && a.console.warn('jQuery.Deferred exception: ' + b.message, b.stack, c);
};
var Q = r.Deferred();
r.fn.ready = function (a) {
return Q.then(a), this;
}, r.extend({
isReady: !1,
readyWait: 1,
holdReady: function (a) {
a ? r.readyWait++ : r.ready(!0);
},
ready: function (a) {
(a === !0 ? --r.readyWait : r.isReady) || (r.isReady = !0, a !== !0 && --r.readyWait > 0 || Q.resolveWith(d, [r]));
}
}), r.ready.then = Q.then;
function R() {
d.removeEventListener('DOMContentLoaded', R), a.removeEventListener('load', R), r.ready();
}
'complete' === d.readyState || 'loading' !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(r.ready) : (d.addEventListener('DOMContentLoaded', R), a.addEventListener('load', R));
var S = function (a, b, c, d, e, f, g) {
var h = 0, i = a.length, j = null == c;
if ('object' === r.type(c)) {
e = !0;
for (h in c)
S(a, b, h, c[h], !0, f, g);
} else if (void 0 !== d && (e = !0, r.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) {
return j.call(r(a), c);
})), b))
for (; i > h; h++)
b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
}, T = function (a) {
return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;
};
function U() {
this.expando = r.expando + U.uid++;
}
U.uid = 1, U.prototype = {
cache: function (a) {
var b = a[this.expando];
return b || (b = {}, T(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
value: b,
configurable: !0
}))), b;
},
set: function (a, b, c) {
var d, e = this.cache(a);
if ('string' == typeof b)
e[r.camelCase(b)] = c;
else
for (d in b)
e[r.camelCase(d)] = b[d];
return e;
},
get: function (a, b) {
return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][r.camelCase(b)];
},
access: function (a, b, c) {
return void 0 === b || b && 'string' == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b);
},
remove: function (a, b) {
var c, d = a[this.expando];
if (void 0 !== d) {
if (void 0 !== b) {
r.isArray(b) ? b = b.map(r.camelCase) : (b = r.camelCase(b), b = b in d ? [b] : b.match(K) || []), c = b.length;
while (c--)
delete d[b[c]];
}
(void 0 === b || r.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);
}
},
hasData: function (a) {
var b = a[this.expando];
return void 0 !== b && !r.isEmptyObject(b);
}
};
var V = new U(), W = new U(), X = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Y = /[A-Z]/g;
function Z(a, b, c) {
var d;
if (void 0 === c && 1 === a.nodeType)
if (d = 'data-' + b.replace(Y, '-$&').toLowerCase(), c = a.getAttribute(d), 'string' == typeof c) {
try {
c = 'true' === c ? !0 : 'false' === c ? !1 : 'null' === c ? null : +c + '' === c ? +c : X.test(c) ? JSON.parse(c) : c;
} catch (e) {
}
W.set(a, b, c);
} else
c = void 0;
return c;
}
r.extend({
hasData: function (a) {
return W.hasData(a) || V.hasData(a);
},
data: function (a, b, c) {
return W.access(a, b, c);
},
removeData: function (a, b) {
W.remove(a, b);
},
_data: function (a, b, c) {
return V.access(a, b, c);
},
_removeData: function (a, b) {
V.remove(a, b);
}
}), r.fn.extend({
data: function (a, b) {
var c, d, e, f = this[0], g = f && f.attributes;
if (void 0 === a) {
if (this.length && (e = W.get(f), 1 === f.nodeType && !V.get(f, 'hasDataAttrs'))) {
c = g.length;
while (c--)
g[c] && (d = g[c].name, 0 === d.indexOf('data-') && (d = r.camelCase(d.slice(5)), Z(f, d, e[d])));
V.set(f, 'hasDataAttrs', !0);
}
return e;
}
return 'object' == typeof a ? this.each(function () {
W.set(this, a);
}) : S(this, function (b) {
var c;
if (f && void 0 === b) {
if (c = W.get(f, a), void 0 !== c)
return c;
if (c = Z(f, a), void 0 !== c)
return c;
} else
this.each(function () {
W.set(this, a, b);
});
}, null, b, arguments.length > 1, null, !0);
},
removeData: function (a) {
return this.each(function () {
W.remove(this, a);
});
}
}), r.extend({
queue: function (a, b, c) {
var d;
return a ? (b = (b || 'fx') + 'queue', d = V.get(a, b), c && (!d || r.isArray(c) ? d = V.access(a, b, r.makeArray(c)) : d.push(c)), d || []) : void 0;
},
dequeue: function (a, b) {
b = b || 'fx';
var c = r.queue(a, b), d = c.length, e = c.shift(), f = r._queueHooks(a, b), g = function () {
r.dequeue(a, b);
};
'inprogress' === e && (e = c.shift(), d--), e && ('fx' === b && c.unshift('inprogress'), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
},
_queueHooks: function (a, b) {
var c = b + 'queueHooks';
return V.get(a, c) || V.access(a, c, {
empty: r.Callbacks('once memory').add(function () {
V.remove(a, [
b + 'queue',
c
]);
})
});
}
}), r.fn.extend({
queue: function (a, b) {
var c = 2;
return 'string' != typeof a && (b = a, a = 'fx', c--), arguments.length < c ? r.queue(this[0], a) : void 0 === b ? this : this.each(function () {
var c = r.queue(this, a, b);
r._queueHooks(this, a), 'fx' === a && 'inprogress' !== c[0] && r.dequeue(this, a);
});
},
dequeue: function (a) {
return this.each(function () {
r.dequeue(this, a);
});
},
clearQueue: function (a) {
return this.queue(a || 'fx', []);
},
promise: function (a, b) {
var c, d = 1, e = r.Deferred(), f = this, g = this.length, h = function () {
--d || e.resolveWith(f, [f]);
};
'string' != typeof a && (b = a, a = void 0), a = a || 'fx';
while (g--)
c = V.get(f[g], a + 'queueHooks'), c && c.empty && (d++, c.empty.add(h));
return h(), e.promise(b);
}
});
var $ = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, _ = new RegExp('^(?:([+-])=|)(' + $ + ')([a-z%]*)$', 'i'), aa = [
'Top',
'Right',
'Bottom',
'Left'
], ba = function (a, b) {
return a = b || a, 'none' === a.style.display || '' === a.style.display && r.contains(a.ownerDocument, a) && 'none' === r.css(a, 'display');
}, ca = function (a, b, c, d) {
var e, f, g = {};
for (f in b)
g[f] = a.style[f], a.style[f] = b[f];
e = c.apply(a, d || []);
for (f in b)
a.style[f] = g[f];
return e;
};
function da(a, b, c, d) {
var e, f = 1, g = 20, h = d ? function () {
return d.cur();
} : function () {
return r.css(a, b, '');
}, i = h(), j = c && c[3] || (r.cssNumber[b] ? '' : 'px'), k = (r.cssNumber[b] || 'px' !== j && +i) && _.exec(r.css(a, b));
if (k && k[3] !== j) {
j = j || k[3], c = c || [], k = +i || 1;
do
f = f || '.5', k /= f, r.style(a, b, k + j);
while (f !== (f = h() / i) && 1 !== f && --g);
}
return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;
}
var ea = {};
function fa(a) {
var b, c = a.ownerDocument, d = a.nodeName, e = ea[d];
return e ? e : (b = c.body.appendChild(c.createElement(d)), e = r.css(b, 'display'), b.parentNode.removeChild(b), 'none' === e && (e = 'block'), ea[d] = e, e);
}
function ga(a, b) {
for (var c, d, e = [], f = 0, g = a.length; g > f; f++)
d = a[f], d.style && (c = d.style.display, b ? ('none' === c && (e[f] = V.get(d, 'display') || null, e[f] || (d.style.display = '')), '' === d.style.display && ba(d) && (e[f] = fa(d))) : 'none' !== c && (e[f] = 'none', V.set(d, 'display', c)));
for (f = 0; g > f; f++)
null != e[f] && (a[f].style.display = e[f]);
return a;
}
r.fn.extend({
show: function () {
return ga(this, !0);
},
hide: function () {
return ga(this);
},
toggle: function (a) {
return 'boolean' == typeof a ? a ? this.show() : this.hide() : this.each(function () {
ba(this) ? r(this).show() : r(this).hide();
});
}
});
var ha = /^(?:checkbox|radio)$/i, ia = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, ja = /^$|\/(?:java|ecma)script/i, ka = {
option: [
1,
'<select multiple=\'multiple\'>',
'</select>'
],
thead: [
1,
'<table>',
'</table>'
],
col: [
2,
'<table><colgroup>',
'</colgroup></table>'
],
tr: [
2,
'<table><tbody>',
'</tbody></table>'
],
td: [
3,
'<table><tbody><tr>',
'</tr></tbody></table>'
],
_default: [
0,
'',
''
]
};
ka.optgroup = ka.option, ka.tbody = ka.tfoot = ka.colgroup = ka.caption = ka.thead, ka.th = ka.td;
function la(a, b) {
var c = 'undefined' != typeof a.getElementsByTagName ? a.getElementsByTagName(b || '*') : 'undefined' != typeof a.querySelectorAll ? a.querySelectorAll(b || '*') : [];
return void 0 === b || b && r.nodeName(a, b) ? r.merge([a], c) : c;
}
function ma(a, b) {
for (var c = 0, d = a.length; d > c; c++)
V.set(a[c], 'globalEval', !b || V.get(b[c], 'globalEval'));
}
var na = /<|&#?\w+;/;
function oa(a, b, c, d, e) {
for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; o > n; n++)
if (f = a[n], f || 0 === f)
if ('object' === r.type(f))
r.merge(m, f.nodeType ? [f] : f);
else if (na.test(f)) {
g = g || l.appendChild(b.createElement('div')), h = (ia.exec(f) || [
'',
''
])[1].toLowerCase(), i = ka[h] || ka._default, g.innerHTML = i[1] + r.htmlPrefilter(f) + i[2], k = i[0];
while (k--)
g = g.lastChild;
r.merge(m, g.childNodes), g = l.firstChild, g.textContent = '';
} else
m.push(b.createTextNode(f));
l.textContent = '', n = 0;
while (f = m[n++])
if (d && r.inArray(f, d) > -1)
e && e.push(f);
else if (j = r.contains(f.ownerDocument, f), g = la(l.appendChild(f), 'script'), j && ma(g), c) {
k = 0;
while (f = g[k++])
ja.test(f.type || '') && c.push(f);
}
return l;
}
!function () {
var a = d.createDocumentFragment(), b = a.appendChild(d.createElement('div')), c = d.createElement('input');
c.setAttribute('type', 'radio'), c.setAttribute('checked', 'checked'), c.setAttribute('name', 't'), b.appendChild(c), o.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = '<textarea>x</textarea>', o.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;
}();
var pa = d.documentElement, qa = /^key/, ra = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, sa = /^([^.]*)(?:\.(.+)|)/;
function ta() {
return !0;
}
function ua() {
return !1;
}
function va() {
try {
return d.activeElement;
} catch (a) {
}
}
function wa(a, b, c, d, e, f) {
var g, h;
if ('object' == typeof b) {
'string' != typeof c && (d = d || c, c = void 0);
for (h in b)
wa(a, h, c, d, b[h], f);
return a;
}
if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ('string' == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1)
e = ua;
else if (!e)
return a;
return 1 === f && (g = e, e = function (a) {
return r().off(a), g.apply(this, arguments);
}, e.guid = g.guid || (g.guid = r.guid++)), a.each(function () {
r.event.add(this, b, e, d, c);
});
}
r.event = {
global: {},
add: function (a, b, c, d, e) {
var f, g, h, i, j, k, l, m, n, o, p, q = V.get(a);
if (q) {
c.handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector(pa, e), c.guid || (c.guid = r.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function (b) {
return 'undefined' != typeof r && r.event.triggered !== b.type ? r.event.dispatch.apply(a, arguments) : void 0;
}), b = (b || '').match(K) || [''], j = b.length;
while (j--)
h = sa.exec(b[j]) || [], n = p = h[1], o = (h[2] || '').split('.').sort(), n && (l = r.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = r.event.special[n] || {}, k = r.extend({
type: n,
origType: p,
data: d,
handler: c,
guid: c.guid,
selector: e,
needsContext: e && r.expr.match.needsContext.test(e),
namespace: o.join('.')
}, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), r.event.global[n] = !0);
}
},
remove: function (a, b, c, d, e) {
var f, g, h, i, j, k, l, m, n, o, p, q = V.hasData(a) && V.get(a);
if (q && (i = q.events)) {
b = (b || '').match(K) || [''], j = b.length;
while (j--)
if (h = sa.exec(b[j]) || [], n = p = h[1], o = (h[2] || '').split('.').sort(), n) {
l = r.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp('(^|\\.)' + o.join('\\.(?:.*\\.|)') + '(\\.|$)'), g = f = m.length;
while (f--)
k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ('**' !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || r.removeEvent(a, n, q.handle), delete i[n]);
} else
for (n in i)
r.event.remove(a, n + b[j], c, d, !0);
r.isEmptyObject(i) && V.remove(a, 'handle events');
}
},
dispatch: function (a) {
var b = r.event.fix(a), c, d, e, f, g, h, i = new Array(arguments.length), j = (V.get(this, 'events') || {})[b.type] || [], k = r.event.special[b.type] || {};
for (i[0] = b, c = 1; c < arguments.length; c++)
i[c] = arguments[c];
if (b.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, b) !== !1) {
h = r.event.handlers.call(this, b, j), c = 0;
while ((f = h[c++]) && !b.isPropagationStopped()) {
b.currentTarget = f.elem, d = 0;
while ((g = f.handlers[d++]) && !b.isImmediatePropagationStopped())
b.rnamespace && !b.rnamespace.test(g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (b.result = e) === !1 && (b.preventDefault(), b.stopPropagation()));
}
return k.postDispatch && k.postDispatch.call(this, b), b.result;
}
},
handlers: function (a, b) {
var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
if (h && i.nodeType && ('click' !== a.type || isNaN(a.button) || a.button < 1))
for (; i !== this; i = i.parentNode || this)
if (1 === i.nodeType && (i.disabled !== !0 || 'click' !== a.type)) {
for (d = [], c = 0; h > c; c++)
f = b[c], e = f.selector + ' ', void 0 === d[e] && (d[e] = f.needsContext ? r(e, this).index(i) > -1 : r.find(e, this, null, [i]).length), d[e] && d.push(f);
d.length && g.push({
elem: i,
handlers: d
});
}
return h < b.length && g.push({
elem: this,
handlers: b.slice(h)
}), g;
},
addProp: function (a, b) {
Object.defineProperty(r.Event.prototype, a, {
enumerable: !0,
configurable: !0,
get: r.isFunction(b) ? function () {
return this.originalEvent ? b(this.originalEvent) : void 0;
} : function () {
return this.originalEvent ? this.originalEvent[a] : void 0;
},
set: function (b) {
Object.defineProperty(this, a, {
enumerable: !0,
configurable: !0,
writable: !0,
value: b
});
}
});
},
fix: function (a) {
return a[r.expando] ? a : new r.Event(a);
},
special: {
load: { noBubble: !0 },
focus: {
trigger: function () {
return this !== va() && this.focus ? (this.focus(), !1) : void 0;
},
delegateType: 'focusin'
},
blur: {
trigger: function () {
return this === va() && this.blur ? (this.blur(), !1) : void 0;
},
delegateType: 'focusout'
},
click: {
trigger: function () {
return 'checkbox' === this.type && this.click && r.nodeName(this, 'input') ? (this.click(), !1) : void 0;
},
_default: function (a) {
return r.nodeName(a.target, 'a');
}
},
beforeunload: {
postDispatch: function (a) {
void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
}
}
}
}, r.removeEvent = function (a, b, c) {
a.removeEventListener && a.removeEventListener(b, c);
}, r.Event = function (a, b) {
return this instanceof r.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ta : ua, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && r.extend(this, b), this.timeStamp = a && a.timeStamp || r.now(), void (this[r.expando] = !0)) : new r.Event(a, b);
}, r.Event.prototype = {
constructor: r.Event,
isDefaultPrevented: ua,
isPropagationStopped: ua,
isImmediatePropagationStopped: ua,
isSimulated: !1,
preventDefault: function () {
var a = this.originalEvent;
this.isDefaultPrevented = ta, a && !this.isSimulated && a.preventDefault();
},
stopPropagation: function () {
var a = this.originalEvent;
this.isPropagationStopped = ta, a && !this.isSimulated && a.stopPropagation();
},
stopImmediatePropagation: function () {
var a = this.originalEvent;
this.isImmediatePropagationStopped = ta, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();
}
}, r.each({
altKey: !0,
bubbles: !0,
cancelable: !0,
changedTouches: !0,
ctrlKey: !0,
detail: !0,
eventPhase: !0,
metaKey: !0,
pageX: !0,
pageY: !0,
shiftKey: !0,
view: !0,
'char': !0,
charCode: !0,
key: !0,
keyCode: !0,
button: !0,
buttons: !0,
clientX: !0,
clientY: !0,
offsetX: !0,
offsetY: !0,
pointerId: !0,
pointerType: !0,
screenX: !0,
screenY: !0,
targetTouches: !0,
toElement: !0,
touches: !0,
which: function (a) {
var b = a.button;
return null == a.which && qa.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && ra.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which;
}
}, r.event.addProp), r.each({
mouseenter: 'mouseover',
mouseleave: 'mouseout',
pointerenter: 'pointerover',
pointerleave: 'pointerout'
}, function (a, b) {
r.event.special[a] = {
delegateType: b,
bindType: b,
handle: function (a) {
var c, d = this, e = a.relatedTarget, f = a.handleObj;
return e && (e === d || r.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;
}
};
}), r.fn.extend({
on: function (a, b, c, d) {
return wa(this, a, b, c, d);
},
one: function (a, b, c, d) {
return wa(this, a, b, c, d, 1);
},
off: function (a, b, c) {
var d, e;
if (a && a.preventDefault && a.handleObj)
return d = a.handleObj, r(a.delegateTarget).off(d.namespace ? d.origType + '.' + d.namespace : d.origType, d.selector, d.handler), this;
if ('object' == typeof a) {
for (e in a)
this.off(e, b, a[e]);
return this;
}
return b !== !1 && 'function' != typeof b || (c = b, b = void 0), c === !1 && (c = ua), this.each(function () {
r.event.remove(this, a, c, b);
});
}
});
var xa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, ya = /<script|<style|<link/i, za = /checked\s*(?:[^=]|=\s*.checked.)/i, Aa = /^true\/(.*)/, Ba = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
function Ca(a, b) {
return r.nodeName(a, 'table') && r.nodeName(11 !== b.nodeType ? b : b.firstChild, 'tr') ? a.getElementsByTagName('tbody')[0] || a : a;
}
function Da(a) {
return a.type = (null !== a.getAttribute('type')) + '/' + a.type, a;
}
function Ea(a) {
var b = Aa.exec(a.type);
return b ? a.type = b[1] : a.removeAttribute('type'), a;
}
function Fa(a, b) {
var c, d, e, f, g, h, i, j;
if (1 === b.nodeType) {
if (V.hasData(a) && (f = V.access(a), g = V.set(b, f), j = f.events)) {
delete g.handle, g.events = {};
for (e in j)
for (c = 0, d = j[e].length; d > c; c++)
r.event.add(b, e, j[e][c]);
}
W.hasData(a) && (h = W.access(a), i = r.extend({}, h), W.set(b, i));
}
}
function Ga(a, b) {
var c = b.nodeName.toLowerCase();
'input' === c && ha.test(a.type) ? b.checked = a.checked : 'input' !== c && 'textarea' !== c || (b.defaultValue = a.defaultValue);
}
function Ha(a, b, c, d) {
b = g.apply([], b);
var e, f, h, i, j, k, l = 0, m = a.length, n = m - 1, q = b[0], s = r.isFunction(q);
if (s || m > 1 && 'string' == typeof q && !o.checkClone && za.test(q))
return a.each(function (e) {
var f = a.eq(e);
s && (b[0] = q.call(this, e, f.html())), Ha(f, b, c, d);
});
if (m && (e = oa(b, a[0].ownerDocument, !1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {
for (h = r.map(la(e, 'script'), Da), i = h.length; m > l; l++)
j = e, l !== n && (j = r.clone(j, !0, !0), i && r.merge(h, la(j, 'script'))), c.call(a[l], j, l);
if (i)
for (k = h[h.length - 1].ownerDocument, r.map(h, Ea), l = 0; i > l; l++)
j = h[l], ja.test(j.type || '') && !V.access(j, 'globalEval') && r.contains(k, j) && (j.src ? r._evalUrl && r._evalUrl(j.src) : p(j.textContent.replace(Ba, ''), k));
}
return a;
}
function Ia(a, b, c) {
for (var d, e = b ? r.filter(b, a) : a, f = 0; null != (d = e[f]); f++)
c || 1 !== d.nodeType || r.cleanData(la(d)), d.parentNode && (c && r.contains(d.ownerDocument, d) && ma(la(d, 'script')), d.parentNode.removeChild(d));
return a;
}
r.extend({
htmlPrefilter: function (a) {
return a.replace(xa, '<$1></$2>');
},
clone: function (a, b, c) {
var d, e, f, g, h = a.cloneNode(!0), i = r.contains(a.ownerDocument, a);
if (!(o.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || r.isXMLDoc(a)))
for (g = la(h), f = la(a), d = 0, e = f.length; e > d; d++)
Ga(f[d], g[d]);
if (b)
if (c)
for (f = f || la(a), g = g || la(h), d = 0, e = f.length; e > d; d++)
Fa(f[d], g[d]);
else
Fa(a, h);
return g = la(h, 'script'), g.length > 0 && ma(g, !i && la(a, 'script')), h;
},
cleanData: function (a) {
for (var b, c, d, e = r.event.special, f = 0; void 0 !== (c = a[f]); f++)
if (T(c)) {
if (b = c[V.expando]) {
if (b.events)
for (d in b.events)
e[d] ? r.event.remove(c, d) : r.removeEvent(c, d, b.handle);
c[V.expando] = void 0;
}
c[W.expando] && (c[W.expando] = void 0);
}
}
}), r.fn.extend({
detach: function (a) {
return Ia(this, a, !0);
},
remove: function (a) {
return Ia(this, a);
},
text: function (a) {
return S(this, function (a) {
return void 0 === a ? r.text(this) : this.empty().each(function () {
1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);
});
}, null, a, arguments.length);
},
append: function () {
return Ha(this, arguments, function (a) {
if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
var b = Ca(this, a);
b.appendChild(a);
}
});
},
prepend: function () {
return Ha(this, arguments, function (a) {
if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
var b = Ca(this, a);
b.insertBefore(a, b.firstChild);
}
});
},
before: function () {
return Ha(this, arguments, function (a) {
this.parentNode && this.parentNode.insertBefore(a, this);
});
},
after: function () {
return Ha(this, arguments, function (a) {
this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
});
},
empty: function () {
for (var a, b = 0; null != (a = this[b]); b++)
1 === a.nodeType && (r.cleanData(la(a, !1)), a.textContent = '');
return this;
},
clone: function (a, b) {
return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {
return r.clone(this, a, b);
});
},
html: function (a) {
return S(this, function (a) {
var b = this[0] || {}, c = 0, d = this.length;
if (void 0 === a && 1 === b.nodeType)
return b.innerHTML;
if ('string' == typeof a && !ya.test(a) && !ka[(ia.exec(a) || [
'',
''
])[1].toLowerCase()]) {
a = r.htmlPrefilter(a);
try {
for (; d > c; c++)
b = this[c] || {}, 1 === b.nodeType && (r.cleanData(la(b, !1)), b.innerHTML = a);
b = 0;
} catch (e) {
}
}
b && this.empty().append(a);
}, null, a, arguments.length);
},
replaceWith: function () {
var a = [];
return Ha(this, arguments, function (b) {
var c = this.parentNode;
r.inArray(this, a) < 0 && (r.cleanData(la(this)), c && c.replaceChild(b, this));
}, a);
}
}), r.each({
appendTo: 'append',
prependTo: 'prepend',
insertBefore: 'before',
insertAfter: 'after',
replaceAll: 'replaceWith'
}, function (a, b) {
r.fn[a] = function (a) {
for (var c, d = [], e = r(a), f = e.length - 1, g = 0; f >= g; g++)
c = g === f ? this : this.clone(!0), r(e[g])[b](c), h.apply(d, c.get());
return this.pushStack(d);
};
});
var Ja = /^margin/, Ka = new RegExp('^(' + $ + ')(?!px)[a-z%]+$', 'i'), La = function (b) {
var c = b.ownerDocument.defaultView;
return c && c.opener || (c = a), c.getComputedStyle(b);
};
!function () {
function b() {
if (i) {
i.style.cssText = 'box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%', i.innerHTML = '', pa.appendChild(h);
var b = a.getComputedStyle(i);
c = '1%' !== b.top, g = '2px' === b.marginLeft, e = '4px' === b.width, i.style.marginRight = '50%', f = '4px' === b.marginRight, pa.removeChild(h), i = null;
}
}
var c, e, f, g, h = d.createElement('div'), i = d.createElement('div');
i.style && (i.style.backgroundClip = 'content-box', i.cloneNode(!0).style.backgroundClip = '', o.clearCloneStyle = 'content-box' === i.style.backgroundClip, h.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute', h.appendChild(i), r.extend(o, {
pixelPosition: function () {
return b(), c;
},
boxSizingReliable: function () {
return b(), e;
},
pixelMarginRight: function () {
return b(), f;
},
reliableMarginLeft: function () {
return b(), g;
}
}));
}();
function Ma(a, b, c) {
var d, e, f, g, h = a.style;
return c = c || La(a), c && (g = c.getPropertyValue(b) || c[b], '' !== g || r.contains(a.ownerDocument, a) || (g = r.style(a, b)), !o.pixelMarginRight() && Ka.test(g) && Ja.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + '' : g;
}
function Na(a, b) {
return {
get: function () {
return a() ? void delete this.get : (this.get = b).apply(this, arguments);
}
};
}
var Oa = /^(none|table(?!-c[ea]).+)/, Pa = {
position: 'absolute',
visibility: 'hidden',
display: 'block'
}, Qa = {
letterSpacing: '0',
fontWeight: '400'
}, Ra = [
'Webkit',
'Moz',
'ms'
], Sa = d.createElement('div').style;
function Ta(a) {
if (a in Sa)
return a;
var b = a[0].toUpperCase() + a.slice(1), c = Ra.length;
while (c--)
if (a = Ra[c] + b, a in Sa)
return a;
}
function Ua(a, b, c) {
var d = _.exec(b);
return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || 'px') : b;
}
function Va(a, b, c, d, e) {
for (var f = c === (d ? 'border' : 'content') ? 4 : 'width' === b ? 1 : 0, g = 0; 4 > f; f += 2)
'margin' === c && (g += r.css(a, c + aa[f], !0, e)), d ? ('content' === c && (g -= r.css(a, 'padding' + aa[f], !0, e)), 'margin' !== c && (g -= r.css(a, 'border' + aa[f] + 'Width', !0, e))) : (g += r.css(a, 'padding' + aa[f], !0, e), 'padding' !== c && (g += r.css(a, 'border' + aa[f] + 'Width', !0, e)));
return g;
}
function Wa(a, b, c) {
var d, e = !0, f = La(a), g = 'border-box' === r.css(a, 'boxSizing', !1, f);
if (a.getClientRects().length && (d = a.getBoundingClientRect()[b]), 0 >= d || null == d) {
if (d = Ma(a, b, f), (0 > d || null == d) && (d = a.style[b]), Ka.test(d))
return d;
e = g && (o.boxSizingReliable() || d === a.style[b]), d = parseFloat(d) || 0;
}
return d + Va(a, b, c || (g ? 'border' : 'content'), e, f) + 'px';
}
r.extend({
cssHooks: {
opacity: {
get: function (a, b) {
if (b) {
var c = Ma(a, 'opacity');
return '' === c ? '1' : c;
}
}
}
},
cssNumber: {
animationIterationCount: !0,
columnCount: !0,
fillOpacity: !0,
flexGrow: !0,
flexShrink: !0,
fontWeight: !0,
lineHeight: !0,
opacity: !0,
order: !0,
orphans: !0,
widows: !0,
zIndex: !0,
zoom: !0
},
cssProps: { 'float': 'cssFloat' },
style: function (a, b, c, d) {
if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
var e, f, g, h = r.camelCase(b), i = a.style;
return b = r.cssProps[h] || (r.cssProps[h] = Ta(h) || h), g = r.cssHooks[b] || r.cssHooks[h], void 0 === c ? g && 'get' in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, 'string' === f && (e = _.exec(c)) && e[1] && (c = da(a, b, e), f = 'number'), null != c && c === c && ('number' === f && (c += e && e[3] || (r.cssNumber[h] ? '' : 'px')), o.clearCloneStyle || '' !== c || 0 !== b.indexOf('background') || (i[b] = 'inherit'), g && 'set' in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);
}
},
css: function (a, b, c, d) {
var e, f, g, h = r.camelCase(b);
return b = r.cssProps[h] || (r.cssProps[h] = Ta(h) || h), g = r.cssHooks[b] || r.cssHooks[h], g && 'get' in g && (e = g.get(a, !0, c)), void 0 === e && (e = Ma(a, b, d)), 'normal' === e && b in Qa && (e = Qa[b]), '' === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;
}
}), r.each([
'height',
'width'
], function (a, b) {
r.cssHooks[b] = {
get: function (a, c, d) {
return c ? !Oa.test(r.css(a, 'display')) || a.getClientRects().length && a.getBoundingClientRect().width ? Wa(a, b, d) : ca(a, Pa, function () {
return Wa(a, b, d);
}) : void 0;
},
set: function (a, c, d) {
var e, f = d && La(a), g = d && Va(a, b, d, 'border-box' === r.css(a, 'boxSizing', !1, f), f);
return g && (e = _.exec(c)) && 'px' !== (e[3] || 'px') && (a.style[b] = c, c = r.css(a, b)), Ua(a, c, g);
}
};
}), r.cssHooks.marginLeft = Na(o.reliableMarginLeft, function (a, b) {
return b ? (parseFloat(Ma(a, 'marginLeft')) || a.getBoundingClientRect().left - ca(a, { marginLeft: 0 }, function () {
return a.getBoundingClientRect().left;
})) + 'px' : void 0;
}), r.each({
margin: '',
padding: '',
border: 'Width'
}, function (a, b) {
r.cssHooks[a + b] = {
expand: function (c) {
for (var d = 0, e = {}, f = 'string' == typeof c ? c.split(' ') : [c]; 4 > d; d++)
e[a + aa[d] + b] = f[d] || f[d - 2] || f[0];
return e;
}
}, Ja.test(a) || (r.cssHooks[a + b].set = Ua);
}), r.fn.extend({
css: function (a, b) {
return S(this, function (a, b, c) {
var d, e, f = {}, g = 0;
if (r.isArray(b)) {
for (d = La(a), e = b.length; e > g; g++)
f[b[g]] = r.css(a, b[g], !1, d);
return f;
}
return void 0 !== c ? r.style(a, b, c) : r.css(a, b);
}, a, b, arguments.length > 1);
}
});
function Xa(a, b, c, d, e) {
return new Xa.prototype.init(a, b, c, d, e);
}
r.Tween = Xa, Xa.prototype = {
constructor: Xa,
init: function (a, b, c, d, e, f) {
this.elem = a, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (r.cssNumber[c] ? '' : 'px');
},
cur: function () {
var a = Xa.propHooks[this.prop];
return a && a.get ? a.get(this) : Xa.propHooks._default.get(this);
},
run: function (a) {
var b, c = Xa.propHooks[this.prop];
return this.options.duration ? this.pos = b = r.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Xa.propHooks._default.set(this), this;
}
}, Xa.prototype.init.prototype = Xa.prototype, Xa.propHooks = {
_default: {
get: function (a) {
var b;
return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = r.css(a.elem, a.prop, ''), b && 'auto' !== b ? b : 0);
},
set: function (a) {
r.fx.step[a.prop] ? r.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[r.cssProps[a.prop]] && !r.cssHooks[a.prop] ? a.elem[a.prop] = a.now : r.style(a.elem, a.prop, a.now + a.unit);
}
}
}, Xa.propHooks.scrollTop = Xa.propHooks.scrollLeft = {
set: function (a) {
a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
}
}, r.easing = {
linear: function (a) {
return a;
},
swing: function (a) {
return 0.5 - Math.cos(a * Math.PI) / 2;
},
_default: 'swing'
}, r.fx = Xa.prototype.init, r.fx.step = {};
var Ya, Za, $a = /^(?:toggle|show|hide)$/, _a = /queueHooks$/;
function ab() {
Za && (a.requestAnimationFrame(ab), r.fx.tick());
}
function bb() {
return a.setTimeout(function () {
Ya = void 0;
}), Ya = r.now();
}
function cb(a, b) {
var c, d = 0, e = { height: a };
for (b = b ? 1 : 0; 4 > d; d += 2 - b)
c = aa[d], e['margin' + c] = e['padding' + c] = a;
return b && (e.opacity = e.width = a), e;
}
function db(a, b, c) {
for (var d, e = (gb.tweeners[b] || []).concat(gb.tweeners['*']), f = 0, g = e.length; g > f; f++)
if (d = e[f].call(c, b, a))
return d;
}
function eb(a, b, c) {
var d, e, f, g, h, i, j, k, l = 'width' in b || 'height' in b, m = this, n = {}, o = a.style, p = a.nodeType && ba(a), q = V.get(a, 'fxshow');
c.queue || (g = r._queueHooks(a, 'fx'), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function () {
g.unqueued || h();
}), g.unqueued++, m.always(function () {
m.always(function () {
g.unqueued--, r.queue(a, 'fx').length || g.empty.fire();
});
}));
for (d in b)
if (e = b[d], $a.test(e)) {
if (delete b[d], f = f || 'toggle' === e, e === (p ? 'hide' : 'show')) {
if ('show' !== e || !q || void 0 === q[d])
continue;
p = !0;
}
n[d] = q && q[d] || r.style(a, d);
}
if (i = !r.isEmptyObject(b), i || !r.isEmptyObject(n)) {
l && 1 === a.nodeType && (c.overflow = [
o.overflow,
o.overflowX,
o.overflowY
], j = q && q.display, null == j && (j = V.get(a, 'display')), k = r.css(a, 'display'), 'none' === k && (j ? k = j : (ga([a], !0), j = a.style.display || j, k = r.css(a, 'display'), ga([a]))), ('inline' === k || 'inline-block' === k && null != j) && 'none' === r.css(a, 'float') && (i || (m.done(function () {
o.display = j;
}), null == j && (k = o.display, j = 'none' === k ? '' : k)), o.display = 'inline-block')), c.overflow && (o.overflow = 'hidden', m.always(function () {
o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];
})), i = !1;
for (d in n)
i || (q ? 'hidden' in q && (p = q.hidden) : q = V.access(a, 'fxshow', { display: j }), f && (q.hidden = !p), p && ga([a], !0), m.done(function () {
p || ga([a]), V.remove(a, 'fxshow');
for (d in n)
r.style(a, d, n[d]);
})), i = db(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0));
}
}
function fb(a, b) {
var c, d, e, f, g;
for (c in a)
if (d = r.camelCase(c), e = b[d], f = a[c], r.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = r.cssHooks[d], g && 'expand' in g) {
f = g.expand(f), delete a[d];
for (c in f)
c in a || (a[c] = f[c], b[c] = e);
} else
b[d] = e;
}
function gb(a, b, c) {
var d, e, f = 0, g = gb.prefilters.length, h = r.Deferred().always(function () {
delete i.elem;
}), i = function () {
if (e)
return !1;
for (var b = Ya || bb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)
j.tweens[g].run(f);
return h.notifyWith(a, [
j,
f,
c
]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);
}, j = h.promise({
elem: a,
props: r.extend({}, b),
opts: r.extend(!0, {
specialEasing: {},
easing: r.easing._default
}, c),
originalProperties: b,
originalOptions: c,
startTime: Ya || bb(),
duration: c.duration,
tweens: [],
createTween: function (b, c) {
var d = r.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
return j.tweens.push(d), d;
},
stop: function (b) {
var c = 0, d = b ? j.tweens.length : 0;
if (e)
return this;
for (e = !0; d > c; c++)
j.tweens[c].run(1);
return b ? (h.notifyWith(a, [
j,
1,
0
]), h.resolveWith(a, [
j,
b
])) : h.rejectWith(a, [
j,
b
]), this;
}
}), k = j.props;
for (fb(k, j.opts.specialEasing); g > f; f++)
if (d = gb.prefilters[f].call(j, a, k, j.opts))
return r.isFunction(d.stop) && (r._queueHooks(j.elem, j.opts.queue).stop = r.proxy(d.stop, d)), d;
return r.map(k, db, j), r.isFunction(j.opts.start) && j.opts.start.call(a, j), r.fx.timer(r.extend(i, {
elem: a,
anim: j,
queue: j.opts.queue
})), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
}
r.Animation = r.extend(gb, {
tweeners: {
'*': [function (a, b) {
var c = this.createTween(a, b);
return da(c.elem, a, _.exec(b), c), c;
}]
},
tweener: function (a, b) {
r.isFunction(a) ? (b = a, a = ['*']) : a = a.match(K);
for (var c, d = 0, e = a.length; e > d; d++)
c = a[d], gb.tweeners[c] = gb.tweeners[c] || [], gb.tweeners[c].unshift(b);
},
prefilters: [eb],
prefilter: function (a, b) {
b ? gb.prefilters.unshift(a) : gb.prefilters.push(a);
}
}), r.speed = function (a, b, c) {
var e = a && 'object' == typeof a ? r.extend({}, a) : {
complete: c || !c && b || r.isFunction(a) && a,
duration: a,
easing: c && b || b && !r.isFunction(b) && b
};
return r.fx.off || d.hidden ? e.duration = 0 : e.duration = 'number' == typeof e.duration ? e.duration : e.duration in r.fx.speeds ? r.fx.speeds[e.duration] : r.fx.speeds._default, null != e.queue && e.queue !== !0 || (e.queue = 'fx'), e.old = e.complete, e.complete = function () {
r.isFunction(e.old) && e.old.call(this), e.queue && r.dequeue(this, e.queue);
}, e;
}, r.fn.extend({
fadeTo: function (a, b, c, d) {
return this.filter(ba).css('opacity', 0).show().end().animate({ opacity: b }, a, c, d);
},
animate: function (a, b, c, d) {
var e = r.isEmptyObject(a), f = r.speed(b, c, d), g = function () {
var b = gb(this, r.extend({}, a), f);
(e || V.get(this, 'finish')) && b.stop(!0);
};
return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
},
stop: function (a, b, c) {
var d = function (a) {
var b = a.stop;
delete a.stop, b(c);
};
return 'string' != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || 'fx', []), this.each(function () {
var b = !0, e = null != a && a + 'queueHooks', f = r.timers, g = V.get(this);
if (e)
g[e] && g[e].stop && d(g[e]);
else
for (e in g)
g[e] && g[e].stop && _a.test(e) && d(g[e]);
for (e = f.length; e--;)
f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
!b && c || r.dequeue(this, a);
});
},
finish: function (a) {
return a !== !1 && (a = a || 'fx'), this.each(function () {
var b, c = V.get(this), d = c[a + 'queue'], e = c[a + 'queueHooks'], f = r.timers, g = d ? d.length : 0;
for (c.finish = !0, r.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;)
f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
for (b = 0; g > b; b++)
d[b] && d[b].finish && d[b].finish.call(this);
delete c.finish;
});
}
}), r.each([
'toggle',
'show',
'hide'
], function (a, b) {
var c = r.fn[b];
r.fn[b] = function (a, d, e) {
return null == a || 'boolean' == typeof a ? c.apply(this, arguments) : this.animate(cb(b, !0), a, d, e);
};
}), r.each({
slideDown: cb('show'),
slideUp: cb('hide'),
slideToggle: cb('toggle'),
fadeIn: { opacity: 'show' },
fadeOut: { opacity: 'hide' },
fadeToggle: { opacity: 'toggle' }
}, function (a, b) {
r.fn[a] = function (a, c, d) {
return this.animate(b, a, c, d);
};
}), r.timers = [], r.fx.tick = function () {
var a, b = 0, c = r.timers;
for (Ya = r.now(); b < c.length; b++)
a = c[b], a() || c[b] !== a || c.splice(b--, 1);
c.length || r.fx.stop(), Ya = void 0;
}, r.fx.timer = function (a) {
r.timers.push(a), a() ? r.fx.start() : r.timers.pop();
}, r.fx.interval = 13, r.fx.start = function () {
Za || (Za = a.requestAnimationFrame ? a.requestAnimationFrame(ab) : a.setInterval(r.fx.tick, r.fx.interval));
}, r.fx.stop = function () {
a.cancelAnimationFrame ? a.cancelAnimationFrame(Za) : a.clearInterval(Za), Za = null;
}, r.fx.speeds = {
slow: 600,
fast: 200,
_default: 400
}, r.fn.delay = function (b, c) {
return b = r.fx ? r.fx.speeds[b] || b : b, c = c || 'fx', this.queue(c, function (c, d) {
var e = a.setTimeout(c, b);
d.stop = function () {
a.clearTimeout(e);
};
});
}, function () {
var a = d.createElement('input'), b = d.createElement('select'), c = b.appendChild(d.createElement('option'));
a.type = 'checkbox', o.checkOn = '' !== a.value, o.optSelected = c.selected, a = d.createElement('input'), a.value = 't', a.type = 'radio', o.radioValue = 't' === a.value;
}();
var hb, ib = r.expr.attrHandle;
r.fn.extend({
attr: function (a, b) {
return S(this, r.attr, a, b, arguments.length > 1);
},
removeAttr: function (a) {
return this.each(function () {
r.removeAttr(this, a);
});
}
}), r.extend({
attr: function (a, b, c) {
var d, e, f = a.nodeType;
if (3 !== f && 8 !== f && 2 !== f)
return 'undefined' == typeof a.getAttribute ? r.prop(a, b, c) : (1 === f && r.isXMLDoc(a) || (e = r.attrHooks[b.toLowerCase()] || (r.expr.match.bool.test(b) ? hb : void 0)), void 0 !== c ? null === c ? void r.removeAttr(a, b) : e && 'set' in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ''), c) : e && 'get' in e && null !== (d = e.get(a, b)) ? d : (d = r.find.attr(a, b), null == d ? void 0 : d));
},
attrHooks: {
type: {
set: function (a, b) {
if (!o.radioValue && 'radio' === b && r.nodeName(a, 'input')) {
var c = a.value;
return a.setAttribute('type', b), c && (a.value = c), b;
}
}
}
},
removeAttr: function (a, b) {
var c, d = 0, e = b && b.match(K);
if (e && 1 === a.nodeType)
while (c = e[d++])
a.removeAttribute(c);
}
}), hb = {
set: function (a, b, c) {
return b === !1 ? r.removeAttr(a, c) : a.setAttribute(c, c), c;
}
}, r.each(r.expr.match.bool.source.match(/\w+/g), function (a, b) {
var c = ib[b] || r.find.attr;
ib[b] = function (a, b, d) {
var e, f, g = b.toLowerCase();
return d || (f = ib[g], ib[g] = e, e = null != c(a, b, d) ? g : null, ib[g] = f), e;
};
});
var jb = /^(?:input|select|textarea|button)$/i, kb = /^(?:a|area)$/i;
r.fn.extend({
prop: function (a, b) {
return S(this, r.prop, a, b, arguments.length > 1);
},
removeProp: function (a) {
return this.each(function () {
delete this[r.propFix[a] || a];
});
}
}), r.extend({
prop: function (a, b, c) {
var d, e, f = a.nodeType;
if (3 !== f && 8 !== f && 2 !== f)
return 1 === f && r.isXMLDoc(a) || (b = r.propFix[b] || b, e = r.propHooks[b]), void 0 !== c ? e && 'set' in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && 'get' in e && null !== (d = e.get(a, b)) ? d : a[b];
},
propHooks: {
tabIndex: {
get: function (a) {
var b = r.find.attr(a, 'tabindex');
return b ? parseInt(b, 10) : jb.test(a.nodeName) || kb.test(a.nodeName) && a.href ? 0 : -1;
}
}
},
propFix: {
'for': 'htmlFor',
'class': 'className'
}
}), o.optSelected || (r.propHooks.selected = {
get: function (a) {
var b = a.parentNode;
return b && b.parentNode && b.parentNode.selectedIndex, null;
},
set: function (a) {
var b = a.parentNode;
b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);
}
}), r.each([
'tabIndex',
'readOnly',
'maxLength',
'cellSpacing',
'cellPadding',
'rowSpan',
'colSpan',
'useMap',
'frameBorder',
'contentEditable'
], function () {
r.propFix[this.toLowerCase()] = this;
});
var lb = /[\t\r\n\f]/g;
function mb(a) {
return a.getAttribute && a.getAttribute('class') || '';
}
r.fn.extend({
addClass: function (a) {
var b, c, d, e, f, g, h, i = 0;
if (r.isFunction(a))
return this.each(function (b) {
r(this).addClass(a.call(this, b, mb(this)));
});
if ('string' == typeof a && a) {
b = a.match(K) || [];
while (c = this[i++])
if (e = mb(c), d = 1 === c.nodeType && (' ' + e + ' ').replace(lb, ' ')) {
g = 0;
while (f = b[g++])
d.indexOf(' ' + f + ' ') < 0 && (d += f + ' ');
h = r.trim(d), e !== h && c.setAttribute('class', h);
}
}
return this;
},
removeClass: function (a) {
var b, c, d, e, f, g, h, i = 0;
if (r.isFunction(a))
return this.each(function (b) {
r(this).removeClass(a.call(this, b, mb(this)));
});
if (!arguments.length)
return this.attr('class', '');
if ('string' == typeof a && a) {
b = a.match(K) || [];
while (c = this[i++])
if (e = mb(c), d = 1 === c.nodeType && (' ' + e + ' ').replace(lb, ' ')) {
g = 0;
while (f = b[g++])
while (d.indexOf(' ' + f + ' ') > -1)
d = d.replace(' ' + f + ' ', ' ');
h = r.trim(d), e !== h && c.setAttribute('class', h);
}
}
return this;
},
toggleClass: function (a, b) {
var c = typeof a;
return 'boolean' == typeof b && 'string' === c ? b ? this.addClass(a) : this.removeClass(a) : r.isFunction(a) ? this.each(function (c) {
r(this).toggleClass(a.call(this, c, mb(this), b), b);
}) : this.each(function () {
var b, d, e, f;
if ('string' === c) {
d = 0, e = r(this), f = a.match(K) || [];
while (b = f[d++])
e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
} else
void 0 !== a && 'boolean' !== c || (b = mb(this), b && V.set(this, '__className__', b), this.setAttribute && this.setAttribute('class', b || a === !1 ? '' : V.get(this, '__className__') || ''));
});
},
hasClass: function (a) {
var b, c, d = 0;
b = ' ' + a + ' ';
while (c = this[d++])
if (1 === c.nodeType && (' ' + mb(c) + ' ').replace(lb, ' ').indexOf(b) > -1)
return !0;
return !1;
}
});
var nb = /\r/g, ob = /[\x20\t\r\n\f]+/g;
r.fn.extend({
val: function (a) {
var b, c, d, e = this[0];
{
if (arguments.length)
return d = r.isFunction(a), this.each(function (c) {
var e;
1 === this.nodeType && (e = d ? a.call(this, c, r(this).val()) : a, null == e ? e = '' : 'number' == typeof e ? e += '' : r.isArray(e) && (e = r.map(e, function (a) {
return null == a ? '' : a + '';
})), b = r.valHooks[this.type] || r.valHooks[this.nodeName.toLowerCase()], b && 'set' in b && void 0 !== b.set(this, e, 'value') || (this.value = e));
});
if (e)
return b = r.valHooks[e.type] || r.valHooks[e.nodeName.toLowerCase()], b && 'get' in b && void 0 !== (c = b.get(e, 'value')) ? c : (c = e.value, 'string' == typeof c ? c.replace(nb, '') : null == c ? '' : c);
}
}
}), r.extend({
valHooks: {
option: {
get: function (a) {
var b = r.find.attr(a, 'value');
return null != b ? b : r.trim(r.text(a)).replace(ob, ' ');
}
},
select: {
get: function (a) {
for (var b, c, d = a.options, e = a.selectedIndex, f = 'select-one' === a.type, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
if (c = d[i], (c.selected || i === e) && !c.disabled && (!c.parentNode.disabled || !r.nodeName(c.parentNode, 'optgroup'))) {
if (b = r(c).val(), f)
return b;
g.push(b);
}
return g;
},
set: function (a, b) {
var c, d, e = a.options, f = r.makeArray(b), g = e.length;
while (g--)
d = e[g], (d.selected = r.inArray(r.valHooks.option.get(d), f) > -1) && (c = !0);
return c || (a.selectedIndex = -1), f;
}
}
}
}), r.each([
'radio',
'checkbox'
], function () {
r.valHooks[this] = {
set: function (a, b) {
return r.isArray(b) ? a.checked = r.inArray(r(a).val(), b) > -1 : void 0;
}
}, o.checkOn || (r.valHooks[this].get = function (a) {
return null === a.getAttribute('value') ? 'on' : a.value;
});
});
var pb = /^(?:focusinfocus|focusoutblur)$/;
r.extend(r.event, {
trigger: function (b, c, e, f) {
var g, h, i, j, k, m, n, o = [e || d], p = l.call(b, 'type') ? b.type : b, q = l.call(b, 'namespace') ? b.namespace.split('.') : [];
if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !pb.test(p + r.event.triggered) && (p.indexOf('.') > -1 && (q = p.split('.'), p = q.shift(), q.sort()), k = p.indexOf(':') < 0 && 'on' + p, b = b[r.expando] ? b : new r.Event(p, 'object' == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = q.join('.'), b.rnamespace = b.namespace ? new RegExp('(^|\\.)' + q.join('\\.(?:.*\\.|)') + '(\\.|$)') : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : r.makeArray(c, [b]), n = r.event.special[p] || {}, f || !n.trigger || n.trigger.apply(e, c) !== !1)) {
if (!f && !n.noBubble && !r.isWindow(e)) {
for (j = n.delegateType || p, pb.test(j + p) || (h = h.parentNode); h; h = h.parentNode)
o.push(h), i = h;
i === (e.ownerDocument || d) && o.push(i.defaultView || i.parentWindow || a);
}
g = 0;
while ((h = o[g++]) && !b.isPropagationStopped())
b.type = g > 1 ? j : n.bindType || p, m = (V.get(h, 'events') || {})[b.type] && V.get(h, 'handle'), m && m.apply(h, c), m = k && h[k], m && m.apply && T(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());
return b.type = p, f || b.isDefaultPrevented() || n._default && n._default.apply(o.pop(), c) !== !1 || !T(e) || k && r.isFunction(e[p]) && !r.isWindow(e) && (i = e[k], i && (e[k] = null), r.event.triggered = p, e[p](), r.event.triggered = void 0, i && (e[k] = i)), b.result;
}
},
simulate: function (a, b, c) {
var d = r.extend(new r.Event(), c, {
type: a,
isSimulated: !0
});
r.event.trigger(d, null, b);
}
}), r.fn.extend({
trigger: function (a, b) {
return this.each(function () {
r.event.trigger(a, b, this);
});
},
triggerHandler: function (a, b) {
var c = this[0];
return c ? r.event.trigger(a, b, c, !0) : void 0;
}
}), r.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), function (a, b) {
r.fn[b] = function (a, c) {
return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
};
}), r.fn.extend({
hover: function (a, b) {
return this.mouseenter(a).mouseleave(b || a);
}
}), o.focusin = 'onfocusin' in a, o.focusin || r.each({
focus: 'focusin',
blur: 'focusout'
}, function (a, b) {
var c = function (a) {
r.event.simulate(b, a.target, r.event.fix(a));
};
r.event.special[b] = {
setup: function () {
var d = this.ownerDocument || this, e = V.access(d, b);
e || d.addEventListener(a, c, !0), V.access(d, b, (e || 0) + 1);
},
teardown: function () {
var d = this.ownerDocument || this, e = V.access(d, b) - 1;
e ? V.access(d, b, e) : (d.removeEventListener(a, c, !0), V.remove(d, b));
}
};
});
var qb = a.location, rb = r.now(), sb = /\?/;
r.parseXML = function (b) {
var c;
if (!b || 'string' != typeof b)
return null;
try {
c = new a.DOMParser().parseFromString(b, 'text/xml');
} catch (d) {
c = void 0;
}
return c && !c.getElementsByTagName('parsererror').length || r.error('Invalid XML: ' + b), c;
};
var tb = /\[\]$/, ub = /\r?\n/g, vb = /^(?:submit|button|image|reset|file)$/i, wb = /^(?:input|select|textarea|keygen)/i;
function xb(a, b, c, d) {
var e;
if (r.isArray(b))
r.each(b, function (b, e) {
c || tb.test(a) ? d(a, e) : xb(a + '[' + ('object' == typeof e && null != e ? b : '') + ']', e, c, d);
});
else if (c || 'object' !== r.type(b))
d(a, b);
else
for (e in b)
xb(a + '[' + e + ']', b[e], c, d);
}
r.param = function (a, b) {
var c, d = [], e = function (a, b) {
var c = r.isFunction(b) ? b() : b;
d[d.length] = encodeURIComponent(a) + '=' + encodeURIComponent(null == c ? '' : c);
};
if (r.isArray(a) || a.jquery && !r.isPlainObject(a))
r.each(a, function () {
e(this.name, this.value);
});
else
for (c in a)
xb(c, a[c], b, e);
return d.join('&');
}, r.fn.extend({
serialize: function () {
return r.param(this.serializeArray());
},
serializeArray: function () {
return this.map(function () {
var a = r.prop(this, 'elements');
return a ? r.makeArray(a) : this;
}).filter(function () {
var a = this.type;
return this.name && !r(this).is(':disabled') && wb.test(this.nodeName) && !vb.test(a) && (this.checked || !ha.test(a));
}).map(function (a, b) {
var c = r(this).val();
return null == c ? null : r.isArray(c) ? r.map(c, function (a) {
return {
name: b.name,
value: a.replace(ub, '\r\n')
};
}) : {
name: b.name,
value: c.replace(ub, '\r\n')
};
}).get();
}
});
var yb = /%20/g, zb = /#.*$/, Ab = /([?&])_=[^&]*/, Bb = /^(.*?):[ \t]*([^\r\n]*)$/gm, Cb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Db = /^(?:GET|HEAD)$/, Eb = /^\/\//, Fb = {}, Gb = {}, Hb = '*/'.concat('*'), Ib = d.createElement('a');
Ib.href = qb.href;
function Jb(a) {
return function (b, c) {
'string' != typeof b && (c = b, b = '*');
var d, e = 0, f = b.toLowerCase().match(K) || [];
if (r.isFunction(c))
while (d = f[e++])
'+' === d[0] ? (d = d.slice(1) || '*', (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
};
}
function Kb(a, b, c, d) {
var e = {}, f = a === Gb;
function g(h) {
var i;
return e[h] = !0, r.each(a[h] || [], function (a, h) {
var j = h(b, c, d);
return 'string' != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);
}), i;
}
return g(b.dataTypes[0]) || !e['*'] && g('*');
}
function Lb(a, b) {
var c, d, e = r.ajaxSettings.flatOptions || {};
for (c in b)
void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
return d && r.extend(!0, a, d), a;
}
function Mb(a, b, c) {
var d, e, f, g, h = a.contents, i = a.dataTypes;
while ('*' === i[0])
i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader('Content-Type'));
if (d)
for (e in h)
if (h[e] && h[e].test(d)) {
i.unshift(e);
break;
}
if (i[0] in c)
f = i[0];
else {
for (e in c) {
if (!i[0] || a.converters[e + ' ' + i[0]]) {
f = e;
break;
}
g || (g = e);
}
f = f || g;
}
return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
}
function Nb(a, b, c, d) {
var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
if (k[1])
for (g in a.converters)
j[g.toLowerCase()] = a.converters[g];
f = k.shift();
while (f)
if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
if ('*' === f)
f = i;
else if ('*' !== i && i !== f) {
if (g = j[i + ' ' + f] || j['* ' + f], !g)
for (e in j)
if (h = e.split(' '), h[1] === f && (g = j[i + ' ' + h[0]] || j['* ' + h[0]])) {
g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
break;
}
if (g !== !0)
if (g && a['throws'])
b = g(b);
else
try {
b = g(b);
} catch (l) {
return {
state: 'parsererror',
error: g ? l : 'No conversion from ' + i + ' to ' + f
};
}
}
return {
state: 'success',
data: b
};
}
r.extend({
active: 0,
lastModified: {},
etag: {},
ajaxSettings: {
url: qb.href,
type: 'GET',
isLocal: Cb.test(qb.protocol),
global: !0,
processData: !0,
async: !0,
contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
accepts: {
'*': Hb,
text: 'text/plain',
html: 'text/html',
xml: 'application/xml, text/xml',
json: 'application/json, text/javascript'
},
contents: {
xml: /\bxml\b/,
html: /\bhtml/,
json: /\bjson\b/
},
responseFields: {
xml: 'responseXML',
text: 'responseText',
json: 'responseJSON'
},
converters: {
'* text': String,
'text html': !0,
'text json': JSON.parse,
'text xml': r.parseXML
},
flatOptions: {
url: !0,
context: !0
}
},
ajaxSetup: function (a, b) {
return b ? Lb(Lb(a, r.ajaxSettings), b) : Lb(r.ajaxSettings, a);
},
ajaxPrefilter: Jb(Fb),
ajaxTransport: Jb(Gb),
ajax: function (b, c) {
'object' == typeof b && (c = b, b = void 0), c = c || {};
var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup({}, c), p = o.context || o, q = o.context && (p.nodeType || p.jquery) ? r(p) : r.event, s = r.Deferred(), t = r.Callbacks('once memory'), u = o.statusCode || {}, v = {}, w = {}, x = 'canceled', y = {
readyState: 0,
getResponseHeader: function (a) {
var b;
if (k) {
if (!h) {
h = {};
while (b = Bb.exec(g))
h[b[1].toLowerCase()] = b[2];
}
b = h[a.toLowerCase()];
}
return null == b ? null : b;
},
getAllResponseHeaders: function () {
return k ? g : null;
},
setRequestHeader: function (a, b) {
return null == k && (a = w[a.toLowerCase()] = w[a.toLowerCase()] || a, v[a] = b), this;
},
overrideMimeType: function (a) {
return null == k && (o.mimeType = a), this;
},
statusCode: function (a) {
var b;
if (a)
if (k)
y.always(a[y.status]);
else
for (b in a)
u[b] = [
u[b],
a[b]
];
return this;
},
abort: function (a) {
var b = a || x;
return e && e.abort(b), A(0, b), this;
}
};
if (s.promise(y), o.url = ((b || o.url || qb.href) + '').replace(Eb, qb.protocol + '//'), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || '*').toLowerCase().match(K) || [''], null == o.crossDomain) {
j = d.createElement('a');
try {
j.href = o.url, j.href = j.href, o.crossDomain = Ib.protocol + '//' + Ib.host != j.protocol + '//' + j.host;
} catch (z) {
o.crossDomain = !0;
}
}
if (o.data && o.processData && 'string' != typeof o.data && (o.data = r.param(o.data, o.traditional)), Kb(Fb, o, c, y), k)
return y;
l = r.event && o.global, l && 0 === r.active++ && r.event.trigger('ajaxStart'), o.type = o.type.toUpperCase(), o.hasContent = !Db.test(o.type), f = o.url.replace(zb, ''), o.hasContent ? o.data && o.processData && 0 === (o.contentType || '').indexOf('application/x-www-form-urlencoded') && (o.data = o.data.replace(yb, '+')) : (n = o.url.slice(f.length), o.data && (f += (sb.test(f) ? '&' : '?') + o.data, delete o.data), o.cache === !1 && (f = f.replace(Ab, ''), n = (sb.test(f) ? '&' : '?') + '_=' + rb++ + n), o.url = f + n), o.ifModified && (r.lastModified[f] && y.setRequestHeader('If-Modified-Since', r.lastModified[f]), r.etag[f] && y.setRequestHeader('If-None-Match', r.etag[f])), (o.data && o.hasContent && o.contentType !== !1 || c.contentType) && y.setRequestHeader('Content-Type', o.contentType), y.setRequestHeader('Accept', o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ('*' !== o.dataTypes[0] ? ', ' + Hb + '; q=0.01' : '') : o.accepts['*']);
for (m in o.headers)
y.setRequestHeader(m, o.headers[m]);
if (o.beforeSend && (o.beforeSend.call(p, y, o) === !1 || k))
return y.abort();
if (x = 'abort', t.add(o.complete), y.done(o.success), y.fail(o.error), e = Kb(Gb, o, c, y)) {
if (y.readyState = 1, l && q.trigger('ajaxSend', [
y,
o
]), k)
return y;
o.async && o.timeout > 0 && (i = a.setTimeout(function () {
y.abort('timeout');
}, o.timeout));
try {
k = !1, e.send(v, A);
} catch (z) {
if (k)
throw z;
A(-1, z);
}
} else
A(-1, 'No Transport');
function A(b, c, d, h) {
var j, m, n, v, w, x = c;
k || (k = !0, i && a.clearTimeout(i), e = void 0, g = h || '', y.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (v = Mb(o, y, d)), v = Nb(o, v, y, j), j ? (o.ifModified && (w = y.getResponseHeader('Last-Modified'), w && (r.lastModified[f] = w), w = y.getResponseHeader('etag'), w && (r.etag[f] = w)), 204 === b || 'HEAD' === o.type ? x = 'nocontent' : 304 === b ? x = 'notmodified' : (x = v.state, m = v.data, n = v.error, j = !n)) : (n = x, !b && x || (x = 'error', 0 > b && (b = 0))), y.status = b, y.statusText = (c || x) + '', j ? s.resolveWith(p, [
m,
x,
y
]) : s.rejectWith(p, [
y,
x,
n
]), y.statusCode(u), u = void 0, l && q.trigger(j ? 'ajaxSuccess' : 'ajaxError', [
y,
o,
j ? m : n
]), t.fireWith(p, [
y,
x
]), l && (q.trigger('ajaxComplete', [
y,
o
]), --r.active || r.event.trigger('ajaxStop')));
}
return y;
},
getJSON: function (a, b, c) {
return r.get(a, b, c, 'json');
},
getScript: function (a, b) {
return r.get(a, void 0, b, 'script');
}
}), r.each([
'get',
'post'
], function (a, b) {
r[b] = function (a, c, d, e) {
return r.isFunction(c) && (e = e || d, d = c, c = void 0), r.ajax(r.extend({
url: a,
type: b,
dataType: e,
data: c,
success: d
}, r.isPlainObject(a) && a));
};
}), r._evalUrl = function (a) {
return r.ajax({
url: a,
type: 'GET',
dataType: 'script',
cache: !0,
async: !1,
global: !1,
'throws': !0
});
}, r.fn.extend({
wrapAll: function (a) {
var b;
return this[0] && (r.isFunction(a) && (a = a.call(this[0])), b = r(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {
var a = this;
while (a.firstElementChild)
a = a.firstElementChild;
return a;
}).append(this)), this;
},
wrapInner: function (a) {
return r.isFunction(a) ? this.each(function (b) {
r(this).wrapInner(a.call(this, b));
}) : this.each(function () {
var b = r(this), c = b.contents();
c.length ? c.wrapAll(a) : b.append(a);
});
},
wrap: function (a) {
var b = r.isFunction(a);
return this.each(function (c) {
r(this).wrapAll(b ? a.call(this, c) : a);
});
},
unwrap: function (a) {
return this.parent(a).not('body').each(function () {
r(this).replaceWith(this.childNodes);
}), this;
}
}), r.expr.pseudos.hidden = function (a) {
return !r.expr.pseudos.visible(a);
}, r.expr.pseudos.visible = function (a) {
return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length);
}, r.ajaxSettings.xhr = function () {
try {
return new a.XMLHttpRequest();
} catch (b) {
}
};
var Ob = {
0: 200,
1223: 204
}, Pb = r.ajaxSettings.xhr();
o.cors = !!Pb && 'withCredentials' in Pb, o.ajax = Pb = !!Pb, r.ajaxTransport(function (b) {
var c, d;
return o.cors || Pb && !b.crossDomain ? {
send: function (e, f) {
var g, h = b.xhr();
if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
for (g in b.xhrFields)
h[g] = b.xhrFields[g];
b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e['X-Requested-With'] || (e['X-Requested-With'] = 'XMLHttpRequest');
for (g in e)
h.setRequestHeader(g, e[g]);
c = function (a) {
return function () {
c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, 'abort' === a ? h.abort() : 'error' === a ? 'number' != typeof h.status ? f(0, 'error') : f(h.status, h.statusText) : f(Ob[h.status] || h.status, h.statusText, 'text' !== (h.responseType || 'text') || 'string' != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));
};
}, h.onload = c(), d = h.onerror = c('error'), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {
4 === h.readyState && a.setTimeout(function () {
c && d();
});
}, c = c('abort');
try {
h.send(b.hasContent && b.data || null);
} catch (i) {
if (c)
throw i;
}
},
abort: function () {
c && c();
}
} : void 0;
}), r.ajaxPrefilter(function (a) {
a.crossDomain && (a.contents.script = !1);
}), r.ajaxSetup({
accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
contents: { script: /\b(?:java|ecma)script\b/ },
converters: {
'text script': function (a) {
return r.globalEval(a), a;
}
}
}), r.ajaxPrefilter('script', function (a) {
void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = 'GET');
}), r.ajaxTransport('script', function (a) {
if (a.crossDomain) {
var b, c;
return {
send: function (e, f) {
b = r('<script>').prop({
charset: a.scriptCharset,
src: a.url
}).on('load error', c = function (a) {
b.remove(), c = null, a && f('error' === a.type ? 404 : 200, a.type);
}), d.head.appendChild(b[0]);
},
abort: function () {
c && c();
}
};
}
});
var Qb = [], Rb = /(=)\?(?=&|$)|\?\?/;
r.ajaxSetup({
jsonp: 'callback',
jsonpCallback: function () {
var a = Qb.pop() || r.expando + '_' + rb++;
return this[a] = !0, a;
}
}), r.ajaxPrefilter('json jsonp', function (b, c, d) {
var e, f, g, h = b.jsonp !== !1 && (Rb.test(b.url) ? 'url' : 'string' == typeof b.data && 0 === (b.contentType || '').indexOf('application/x-www-form-urlencoded') && Rb.test(b.data) && 'data');
return h || 'jsonp' === b.dataTypes[0] ? (e = b.jsonpCallback = r.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Rb, '$1' + e) : b.jsonp !== !1 && (b.url += (sb.test(b.url) ? '&' : '?') + b.jsonp + '=' + e), b.converters['script json'] = function () {
return g || r.error(e + ' was not called'), g[0];
}, b.dataTypes[0] = 'json', f = a[e], a[e] = function () {
g = arguments;
}, d.always(function () {
void 0 === f ? r(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Qb.push(e)), g && r.isFunction(f) && f(g[0]), g = f = void 0;
}), 'script') : void 0;
}), o.createHTMLDocument = function () {
var a = d.implementation.createHTMLDocument('').body;
return a.innerHTML = '<form></form><form></form>', 2 === a.childNodes.length;
}(), r.parseHTML = function (a, b, c) {
if ('string' != typeof a)
return [];
'boolean' == typeof b && (c = b, b = !1);
var e, f, g;
return b || (o.createHTMLDocument ? (b = d.implementation.createHTMLDocument(''), e = b.createElement('base'), e.href = d.location.href, b.head.appendChild(e)) : b = d), f = B.exec(a), g = !c && [], f ? [b.createElement(f[1])] : (f = oa([a], b, g), g && g.length && r(g).remove(), r.merge([], f.childNodes));
}, r.fn.load = function (a, b, c) {
var d, e, f, g = this, h = a.indexOf(' ');
return h > -1 && (d = r.trim(a.slice(h)), a = a.slice(0, h)), r.isFunction(b) ? (c = b, b = void 0) : b && 'object' == typeof b && (e = 'POST'), g.length > 0 && r.ajax({
url: a,
type: e || 'GET',
dataType: 'html',
data: b
}).done(function (a) {
f = arguments, g.html(d ? r('<div>').append(r.parseHTML(a)).find(d) : a);
}).always(c && function (a, b) {
g.each(function () {
c.apply(this, f || [
a.responseText,
b,
a
]);
});
}), this;
}, r.each([
'ajaxStart',
'ajaxStop',
'ajaxComplete',
'ajaxError',
'ajaxSuccess',
'ajaxSend'
], function (a, b) {
r.fn[b] = function (a) {
return this.on(b, a);
};
}), r.expr.pseudos.animated = function (a) {
return r.grep(r.timers, function (b) {
return a === b.elem;
}).length;
};
function Sb(a) {
return r.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;
}
r.offset = {
setOffset: function (a, b, c) {
var d, e, f, g, h, i, j, k = r.css(a, 'position'), l = r(a), m = {};
'static' === k && (a.style.position = 'relative'), h = l.offset(), f = r.css(a, 'top'), i = r.css(a, 'left'), j = ('absolute' === k || 'fixed' === k) && (f + i).indexOf('auto') > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), r.isFunction(b) && (b = b.call(a, c, r.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), 'using' in b ? b.using.call(a, m) : l.css(m);
}
}, r.fn.extend({
offset: function (a) {
if (arguments.length)
return void 0 === a ? this : this.each(function (b) {
r.offset.setOffset(this, a, b);
});
var b, c, d, e, f = this[0];
if (f)
return f.getClientRects().length ? (d = f.getBoundingClientRect(), d.width || d.height ? (e = f.ownerDocument, c = Sb(e), b = e.documentElement, {
top: d.top + c.pageYOffset - b.clientTop,
left: d.left + c.pageXOffset - b.clientLeft
}) : d) : {
top: 0,
left: 0
};
},
position: function () {
if (this[0]) {
var a, b, c = this[0], d = {
top: 0,
left: 0
};
return 'fixed' === r.css(c, 'position') ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), r.nodeName(a[0], 'html') || (d = a.offset()), d = {
top: d.top + r.css(a[0], 'borderTopWidth', !0),
left: d.left + r.css(a[0], 'borderLeftWidth', !0)
}), {
top: b.top - d.top - r.css(c, 'marginTop', !0),
left: b.left - d.left - r.css(c, 'marginLeft', !0)
};
}
},
offsetParent: function () {
return this.map(function () {
var a = this.offsetParent;
while (a && 'static' === r.css(a, 'position'))
a = a.offsetParent;
return a || pa;
});
}
}), r.each({
scrollLeft: 'pageXOffset',
scrollTop: 'pageYOffset'
}, function (a, b) {
var c = 'pageYOffset' === b;
r.fn[a] = function (d) {
return S(this, function (a, d, e) {
var f = Sb(a);
return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);
}, a, d, arguments.length);
};
}), r.each([
'top',
'left'
], function (a, b) {
r.cssHooks[b] = Na(o.pixelPosition, function (a, c) {
return c ? (c = Ma(a, b), Ka.test(c) ? r(a).position()[b] + 'px' : c) : void 0;
});
}), r.each({
Height: 'height',
Width: 'width'
}, function (a, b) {
r.each({
padding: 'inner' + a,
content: b,
'': 'outer' + a
}, function (c, d) {
r.fn[d] = function (e, f) {
var g = arguments.length && (c || 'boolean' != typeof e), h = c || (e === !0 || f === !0 ? 'margin' : 'border');
return S(this, function (b, c, e) {
var f;
return r.isWindow(b) ? 0 === d.indexOf('outer') ? b['inner' + a] : b.document.documentElement['client' + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body['scroll' + a], f['scroll' + a], b.body['offset' + a], f['offset' + a], f['client' + a])) : void 0 === e ? r.css(b, c, h) : r.style(b, c, e, h);
}, b, g ? e : void 0, g);
};
});
}), r.fn.extend({
bind: function (a, b, c) {
return this.on(a, null, b, c);
},
unbind: function (a, b) {
return this.off(a, null, b);
},
delegate: function (a, b, c, d) {
return this.on(b, a, c, d);
},
undelegate: function (a, b, c) {
return 1 === arguments.length ? this.off(a, '**') : this.off(b, a || '**', c);
}
}), r.parseJSON = JSON.parse, 'function' == typeof define && define.amd && define('jquery', [], function () {
return r;
});
var Tb = a.jQuery, Ub = a.$;
return r.noConflict = function (b) {
return a.$ === r && (a.$ = Ub), b && a.jQuery === r && (a.jQuery = Tb), r;
}, b || (a.jQuery = a.$ = r), r;
});
Polymer({ is: 'app-toolbar' });
Polymer.IronScrollTargetBehavior = {
properties: {
scrollTarget: {
type: Object,
value: function () {
return this._defaultScrollTarget;
}
}
},
observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],
_shouldHaveListener: true,
_scrollTargetChanged: function (scrollTarget, isAttached) {
var eventTarget;
if (this._oldScrollTarget) {
this._toggleScrollListener(false, this._oldScrollTarget);
this._oldScrollTarget = null;
}
if (!isAttached) {
return;
}
if (scrollTarget === 'document') {
this.scrollTarget = this._doc;
} else if (typeof scrollTarget === 'string') {
this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
} else if (this._isValidScrollTarget()) {
this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
this._oldScrollTarget = scrollTarget;
this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
}
},
_scrollHandler: function scrollHandler() {
},
get _defaultScrollTarget() {
return this._doc;
},
get _doc() {
return this.ownerDocument.documentElement;
},
get _scrollTop() {
if (this._isValidScrollTarget()) {
return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
}
return 0;
},
get _scrollLeft() {
if (this._isValidScrollTarget()) {
return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
}
return 0;
},
set _scrollTop(top) {
if (this.scrollTarget === this._doc) {
window.scrollTo(window.pageXOffset, top);
} else if (this._isValidScrollTarget()) {
this.scrollTarget.scrollTop = top;
}
},
set _scrollLeft(left) {
if (this.scrollTarget === this._doc) {
window.scrollTo(left, window.pageYOffset);
} else if (this._isValidScrollTarget()) {
this.scrollTarget.scrollLeft = left;
}
},
scroll: function (left, top) {
if (this.scrollTarget === this._doc) {
window.scrollTo(left, top);
} else if (this._isValidScrollTarget()) {
this.scrollTarget.scrollLeft = left;
this.scrollTarget.scrollTop = top;
}
},
get _scrollTargetWidth() {
if (this._isValidScrollTarget()) {
return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
}
return 0;
},
get _scrollTargetHeight() {
if (this._isValidScrollTarget()) {
return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
}
return 0;
},
_isValidScrollTarget: function () {
return this.scrollTarget instanceof HTMLElement;
},
_toggleScrollListener: function (yes, scrollTarget) {
if (!this._boundScrollHandler) {
return;
}
var eventTarget = scrollTarget === this._doc ? window : scrollTarget;
if (yes) {
eventTarget.addEventListener('scroll', this._boundScrollHandler);
} else {
eventTarget.removeEventListener('scroll', this._boundScrollHandler);
}
},
toggleScrollListener: function (yes) {
this._shouldHaveListener = yes;
this._toggleScrollListener(yes, this.scrollTarget);
}
};
Polymer.AppLayout = Polymer.AppLayout || {};
Polymer.AppLayout.scrollEffects = Polymer.AppLayout.scrollEffects || {};
Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
t /= d;
return -c * t * (t - 2) + b;
};
Polymer.AppLayout.scroll = function scroll(options) {
options = options || {};
var docEl = document.documentElement;
var target = options.target || docEl;
var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
var scrollClassName = 'app-layout-silent-scroll';
var scrollTop = options.top || 0;
var scrollLeft = options.left || 0;
var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
target.scrollLeft = scrollLeft;
target.scrollTop = scrollTop;
};
if (options.behavior === 'smooth') {
if (hasNativeScrollBehavior) {
target.scroll(options);
} else {
var timingFn = Polymer.AppLayout.scrollTimingFunction;
var startTime = Date.now();
var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
var deltaScrollTop = scrollTop - currentScrollTop;
var deltaScrollLeft = scrollLeft - currentScrollLeft;
var duration = 300;
(function updateFrame() {
var now = Date.now();
var elapsedTime = now - startTime;
if (elapsedTime < duration) {
scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
requestAnimationFrame(updateFrame.bind(this));
}
}.call(this));
}
} else if (options.behavior === 'silent') {
docEl.classList.add(scrollClassName);
clearInterval(Polymer.AppLayout._scrollTimer);
Polymer.AppLayout._scrollTimer = setTimeout(function () {
docEl.classList.remove(scrollClassName);
Polymer.AppLayout._scrollTimer = null;
}, 100);
scrollTo(scrollLeft, scrollTop);
} else {
scrollTo(scrollLeft, scrollTop);
}
};
Polymer.AppScrollEffectsBehavior = [
Polymer.IronScrollTargetBehavior,
{
properties: {
effects: {
type: String,
value: ''
},
effectsConfig: {
type: Object,
value: function () {
return {};
}
},
disabled: {
type: Boolean,
reflectToAttribute: true,
value: false
}
},
observers: ['_effectsChanged(effects, effectsConfig)'],
_updateScrollState: function () {
},
isOnScreen: function () {
return false;
},
isContentBelow: function () {
return false;
},
_effectsRunFn: null,
_effects: null,
get _clampedScrollTop() {
return Math.max(0, this._scrollTop);
},
created: function () {
this._effectsRunFn = [];
this._effects = [];
},
detached: function () {
this._tearDownEffects();
},
createEffect: function (effectName, effectConfig) {
var effectDef = Polymer.AppLayout.scrollEffects[effectName];
if (!effectDef) {
throw new ReferenceError(this._getUndefinedMsg(effectName));
return;
}
var prop = this._boundEffect(effectDef, effectConfig || {});
prop.setUp();
return prop;
},
_effectsChanged: function (effects, effectsConfig) {
this._tearDownEffects();
if (effects === '') {
return;
}
effects.split(' ').forEach(function (effectName) {
var effectDef;
if (effectName !== '') {
if (effectDef = Polymer.AppLayout.scrollEffects[effectName]) {
this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
} else {
this._warn(this._logf('_effectsChanged', this._getUndefinedMsg(effectName)));
}
}
}, this);
this._setUpEffect();
},
_layoutIfDirty: function () {
return this.offsetWidth;
},
_boundEffect: function (effectDef, effectsConfig) {
effectsConfig = effectsConfig || {};
var startsAt = parseFloat(effectsConfig.startsAt || 0);
var endsAt = parseFloat(effectsConfig.endsAt || 1);
var deltaS = endsAt - startsAt;
var noop = Function();
var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
};
return {
setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
run: effectDef.run ? runFn.bind(this) : noop,
tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
};
},
_setUpEffect: function () {
if (this.isAttached) {
this._effectsRunFn = [];
this._effects.forEach(function (effectDef) {
if (effectDef.setUp() !== false) {
this._effectsRunFn.push(effectDef.run);
}
}, this);
}
},
_tearDownEffects: function () {
this._effects.forEach(function (effectDef) {
effectDef.tearDown();
});
this._effectsRunFn = [];
this._effects = [];
},
_runEffects: function (p, y) {
this._effectsRunFn.forEach(function (run) {
run(p, y);
});
},
_scrollHandler: function () {
if (!this.disabled) {
this._updateScrollState(this._clampedScrollTop);
}
},
_getUndefinedMsg: function (effectName) {
return 'Scroll effect `' + effectName + '` is undefined. Did you forget to import the effects?';
}
}
];
Polymer({
is: 'app-header',
behaviors: [
Polymer.AppScrollEffectsBehavior,
Polymer.IronResizableBehavior
],
properties: {
condenses: {
type: Boolean,
value: false
},
fixed: {
type: Boolean,
value: false
},
reveals: {
type: Boolean,
value: false
},
shadow: {
type: Boolean,
reflectToAttribute: true,
value: false
}
},
observers: ['resetLayout(isAttached, condenses, fixed)'],
listeners: { 'iron-resize': '_resizeHandler' },
_height: 0,
_dHeight: 0,
_primaryElTop: 0,
_primaryEl: null,
_top: 0,
_progress: 0,
_wasScrollingDown: false,
_initScrollTop: 0,
_initTimestamp: 0,
_lastTimestamp: 0,
_lastScrollTop: 0,
get _maxHeaderTop() {
return this.fixed ? this._dHeight : this._height + 5;
},
_getPrimaryEl: function () {
var primaryEl;
var nodes = Polymer.dom(this.$.content).getDistributedNodes();
for (var i = 0; i < nodes.length; i++) {
if (nodes[i].nodeType === Node.ELEMENT_NODE) {
if (nodes[i].hasAttribute('primary')) {
return nodes[i];
} else if (!primaryEl) {
primaryEl = nodes[i];
}
}
}
return primaryEl;
},
resetLayout: function () {
this.fire('app-header-reset-layout');
this.debounce('_resetLayout', function () {
if (this.offsetWidth === 0 && this.offsetHeight === 0) {
return;
}
var scrollTop = this._clampedScrollTop;
var firstSetup = this._height === 0 || scrollTop === 0;
var currentDisabled = this.disabled;
this._height = this.offsetHeight;
this._primaryEl = this._getPrimaryEl();
this.disabled = true;
if (!firstSetup) {
this._updateScrollState(0, true);
}
if (this._mayMove()) {
this._dHeight = this._primaryEl ? this._height - this._primaryEl.offsetHeight : 0;
} else {
this._dHeight = 0;
}
this._primaryElTop = this._primaryEl ? this._primaryEl.offsetTop : 0;
this._setUpEffect();
if (firstSetup) {
this._updateScrollState(scrollTop, true);
} else {
this._updateScrollState(this._lastScrollTop, true);
this._layoutIfDirty();
}
this.disabled = currentDisabled;
});
},
_updateScrollState: function (scrollTop, forceUpdate) {
if (this._height === 0) {
return;
}
var progress = 0;
var top = 0;
var lastTop = this._top;
var lastScrollTop = this._lastScrollTop;
var maxHeaderTop = this._maxHeaderTop;
var dScrollTop = scrollTop - this._lastScrollTop;
var absDScrollTop = Math.abs(dScrollTop);
var isScrollingDown = scrollTop > this._lastScrollTop;
var now = Date.now();
if (this._mayMove()) {
top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
}
if (scrollTop >= this._dHeight) {
top = this.condenses ? Math.max(this._dHeight, top) : top;
this.style.transitionDuration = '0ms';
}
if (this.reveals && !this.disabled && absDScrollTop < 100) {
if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
this._initScrollTop = scrollTop;
this._initTimestamp = now;
}
if (scrollTop >= maxHeaderTop) {
if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
if (isScrollingDown && scrollTop >= maxHeaderTop) {
top = maxHeaderTop;
} else if (!isScrollingDown && scrollTop >= this._dHeight) {
top = this.condenses ? this._dHeight : 0;
}
var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
} else {
top = this._top;
}
}
}
if (this._dHeight === 0) {
progress = scrollTop > 0 ? 1 : 0;
} else {
progress = top / this._dHeight;
}
if (!forceUpdate) {
this._lastScrollTop = scrollTop;
this._top = top;
this._wasScrollingDown = isScrollingDown;
this._lastTimestamp = now;
}
if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
this._progress = progress;
this._runEffects(progress, top);
this._transformHeader(top);
}
},
_mayMove: function () {
return this.condenses || !this.fixed;
},
willCondense: function () {
return this._dHeight > 0 && this.condenses;
},
isOnScreen: function () {
return this._height !== 0 && this._top < this._height;
},
isContentBelow: function () {
if (this._top === 0) {
return this._clampedScrollTop > 0;
}
return this._clampedScrollTop - this._maxHeaderTop >= 0;
},
_transformHeader: function (y) {
this.translate3d(0, -y + 'px', 0);
if (this._primaryEl && this.condenses && y >= this._primaryElTop) {
this.translate3d(0, Math.min(y, this._dHeight) - this._primaryElTop + 'px', 0, this._primaryEl);
}
},
_resizeHandler: function () {
this.resetLayout();
},
_clamp: function (v, min, max) {
return Math.min(max, Math.max(min, v));
},
getScrollState: function () {
return {
progress: this._progress,
top: this._top
};
}
});
Polymer({
is: 'iron-media-query',
properties: {
queryMatches: {
type: Boolean,
value: false,
readOnly: true,
notify: true
},
query: {
type: String,
observer: 'queryChanged'
},
full: {
type: Boolean,
value: false
},
_boundMQHandler: {
value: function () {
return this.queryHandler.bind(this);
}
},
_mq: { value: null }
},
attached: function () {
this.style.display = 'none';
this.queryChanged();
},
detached: function () {
this._remove();
},
_add: function () {
if (this._mq) {
this._mq.addListener(this._boundMQHandler);
}
},
_remove: function () {
if (this._mq) {
this._mq.removeListener(this._boundMQHandler);
}
this._mq = null;
},
queryChanged: function () {
this._remove();
var query = this.query;
if (!query) {
return;
}
if (!this.full && query[0] !== '(') {
query = '(' + query + ')';
}
this._mq = window.matchMedia(query);
this._add();
this.queryHandler(this._mq);
},
queryHandler: function (mq) {
this._setQueryMatches(mq.matches);
}
});
Polymer({
is: 'app-drawer',
properties: {
opened: {
type: Boolean,
value: false,
notify: true,
reflectToAttribute: true
},
persistent: {
type: Boolean,
value: false,
reflectToAttribute: true
},
align: {
type: String,
value: 'start'
},
position: {
type: String,
readOnly: true,
value: 'left',
reflectToAttribute: true
},
swipeOpen: {
type: Boolean,
value: false,
reflectToAttribute: true
}
},
listeners: { track: '_track' },
observers: [
'resetLayout(position)',
'_resetFocusedContent(persistent)',
'_resetPosition(align, isAttached)'
],
_translateOffset: 0,
_trackDetails: null,
_isDrawerFlinging: false,
_boundFocusHandler: null,
_boundKeydownHandler: null,
ready: function () {
this.setScrollDirection('y');
this._setTransitionDuration('0s');
this._boundFocusHandler = this._focusHandler.bind(this);
this._boundKeydownHandler = this._keydownHandler.bind(this);
},
attached: function () {
requestAnimationFrame(this._setTransitionDuration.bind(this, ''));
},
detached: function () {
document.removeEventListener('focus', this._boundFocusHandler, true);
document.removeEventListener('keydown', this._boundKeydownHandler);
},
open: function () {
this.opened = true;
},
close: function () {
this.opened = false;
},
toggle: function () {
this.opened = !this.opened;
},
getWidth: function () {
return this.$.contentContainer.offsetWidth;
},
resetLayout: function () {
this.debounce('_resetLayout', function () {
this.fire('app-drawer-reset-layout');
}, 1);
},
_isRTL: function () {
return window.getComputedStyle(this).direction === 'rtl';
},
_resetPosition: function () {
switch (this.align) {
case 'start':
this._setPosition(this._isRTL() ? 'right' : 'left');
return;
case 'end':
this._setPosition(this._isRTL() ? 'left' : 'right');
return;
}
this._setPosition(this.align);
},
_focusHandler: function (event) {
if (Polymer.dom(event).path.indexOf(this.$.contentContainer) === -1) {
this.$.contentContainer.focus();
}
},
_keydownHandler: function (event) {
var ESC_KEYCODE = 27;
if (event.keyCode === ESC_KEYCODE) {
event.preventDefault();
event.stopImmediatePropagation();
this.close();
}
},
_track: function (event) {
if (this.persistent) {
return;
}
event.preventDefault();
switch (event.detail.state) {
case 'start':
this._trackStart(event);
break;
case 'track':
this._trackMove(event);
break;
case 'end':
this._trackEnd(event);
break;
}
},
_trackStart: function (event) {
this._setTransitionDuration('0s');
this.style.visibility = 'visible';
var rect = this.$.contentContainer.getBoundingClientRect();
if (this.position === 'left') {
this._translateOffset = rect.left;
} else {
this._translateOffset = rect.right - window.innerWidth;
}
this._trackDetails = [];
},
_trackMove: function (event) {
this._translateDrawer(event.detail.dx + this._translateOffset);
this._trackDetails.push({
dx: event.detail.dx,
timeStamp: Date.now()
});
},
_trackEnd: function (event) {
var x = event.detail.dx + this._translateOffset;
var drawerWidth = this.getWidth();
var isPositionLeft = this.position === 'left';
var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;
var trackDetails = this._trackDetails;
this._trackDetails = null;
if (!isInEndState) {
this._flingDrawer(event, trackDetails);
if (this._isDrawerFlinging) {
return;
}
}
var halfWidth = drawerWidth / 2;
if (event.detail.dx < -halfWidth) {
this.opened = this.position === 'right';
} else if (event.detail.dx > halfWidth) {
this.opened = this.position === 'left';
}
if (isInEndState) {
this._resetFocusedContent();
}
this._setTransitionDuration('');
this._resetDrawerTranslate();
this.style.visibility = '';
},
_calculateVelocity: function (event, trackDetails) {
var now = Date.now();
var timeLowerBound = now - 100;
var trackDetail;
var min = 0;
var max = trackDetails.length - 1;
while (min <= max) {
var mid = min + max >> 1;
var d = trackDetails[mid];
if (d.timeStamp >= timeLowerBound) {
trackDetail = d;
max = mid - 1;
} else {
min = mid + 1;
}
}
if (trackDetail) {
var dx = event.detail.dx - trackDetail.dx;
var dt = now - trackDetail.timeStamp || 1;
return dx / dt;
}
return 0;
},
_flingDrawer: function (event, trackDetails) {
var velocity = this._calculateVelocity(event, trackDetails);
if (Math.abs(velocity) < this.MIN_FLING_VELOCITY) {
return;
}
var x = event.detail.dx + this._translateOffset;
var drawerWidth = this.getWidth();
var isPositionLeft = this.position === 'left';
var isVelocityPositive = velocity > 0;
var isClosingLeft = !isVelocityPositive && isPositionLeft;
var isClosingRight = isVelocityPositive && !isPositionLeft;
var dx;
if (isClosingLeft) {
dx = -(x + drawerWidth);
} else if (isClosingRight) {
dx = drawerWidth - x;
} else {
dx = -x;
}
if (isVelocityPositive) {
velocity = Math.max(velocity, this.MIN_TRANSITION_VELOCITY);
this.opened = this.position === 'left';
} else {
velocity = Math.min(velocity, -this.MIN_TRANSITION_VELOCITY);
this.opened = this.position === 'right';
}
this._setTransitionDuration(this.FLING_INITIAL_SLOPE * dx / velocity + 'ms');
this._setTransitionTimingFunction(this.FLING_TIMING_FUNCTION);
this._resetDrawerTranslate();
this._isDrawerFlinging = true;
},
_scrimTransitionend: function (event) {
if (this._isDrawerFlinging) {
this._isDrawerFlinging = false;
this._setTransitionDuration('');
this._setTransitionTimingFunction('');
this.style.visibility = '';
}
this._resetFocusedContent();
},
_setTransitionDuration: function (duration) {
this.$.contentContainer.style.transitionDuration = duration;
this.$.scrim.style.transitionDuration = duration;
},
_setTransitionTimingFunction: function (timingFunction) {
this.$.contentContainer.style.transitionTimingFunction = timingFunction;
this.$.scrim.style.transitionTimingFunction = timingFunction;
},
_translateDrawer: function (x) {
var drawerWidth = this.getWidth();
if (this.position === 'left') {
x = Math.max(-drawerWidth, Math.min(x, 0));
this.$.scrim.style.opacity = 1 + x / drawerWidth;
} else {
x = Math.max(0, Math.min(x, drawerWidth));
this.$.scrim.style.opacity = 1 - x / drawerWidth;
}
this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
},
_resetDrawerTranslate: function () {
this.$.scrim.style.opacity = '';
this.transform('', this.$.contentContainer);
},
_resetFocusedContent: function () {
if (this.opened && !this.persistent) {
this.$.contentContainer.focus();
document.addEventListener('focus', this._boundFocusHandler, true);
document.addEventListener('keydown', this._boundKeydownHandler);
document.body.style.overflow = 'hidden';
} else {
document.removeEventListener('focus', this._boundFocusHandler, true);
document.removeEventListener('keydown', this._boundKeydownHandler);
document.body.style.overflow = '';
}
},
MIN_FLING_VELOCITY: 0.2,
MIN_TRANSITION_VELOCITY: 1.2,
FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',
FLING_INITIAL_SLOPE: 1.5
});
Polymer({
is: 'app-drawer-layout',
properties: {
narrow: {
type: Boolean,
readOnly: true,
notify: true,
reflectToAttribute: true,
value: false
},
forceNarrow: {
type: Boolean,
value: false,
observer: '_responsiveChange'
},
responsiveWidth: {
type: String,
value: '640px'
}
},
listeners: {
'tap': '_tapHandler',
'app-drawer-reset-layout': 'resetLayout'
},
attached: function () {
this.resetLayout();
},
get drawer() {
return Polymer.dom(this.$.drawerContent).getDistributedNodes()[0];
},
_tapHandler: function (e) {
var target = Polymer.dom(e).localTarget;
if (target && target.hasAttribute('drawer-toggle')) {
this.drawer.toggle();
}
},
_responsiveChange: function (narrow) {
this._setNarrow(narrow);
this.resetLayout();
},
resetLayout: function () {
this.debounce('_resetLayout', function () {
if (!this.isAttached) {
return;
}
this.drawer.opened = !this.narrow;
this.drawer.persistent = !this.narrow;
if (this.narrow) {
this.$.contentContainer.style.marginLeft = '';
this.$.contentContainer.style.marginRight = '';
} else if (this.drawer.position == 'right') {
this.$.contentContainer.style.marginLeft = '';
this.$.contentContainer.style.marginRight = this.drawer.getWidth() + 'px';
} else {
this.$.contentContainer.style.marginLeft = this.drawer.getWidth() + 'px';
this.$.contentContainer.style.marginRight = '';
}
});
},
_onQueryMatchesChanged: function (event) {
this._responsiveChange(event.detail.value);
},
_computeMediaQuery: function (forceNarrow, responsiveWidth) {
return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
},
_computeClass: function (narrow) {
return narrow ? 'narrow' : '';
}
});
(function (scrollEffects) {
function interpolate(progress, points, fn, ctx) {
fn.apply(ctx, points.map(function (point) {
return point[0] + (point[1] - point[0]) * progress;
}));
}
scrollEffects['blend-background'] = {
setUp: function setUp() {
this.$.backgroundFrontLayer.style.willChange = 'opacity';
this.$.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
this.$.backgroundRearLayer.style.willChange = 'opacity';
this.$.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
this.$.backgroundRearLayer.style.opacity = 0;
},
run: function run(p, y) {
this.$.backgroundFrontLayer.style.opacity = 1 - p;
this.$.backgroundRearLayer.style.opacity = p;
}
};
scrollEffects['fade-background'] = {
setUp: function setUp(config) {
var duration = config.duration || '0.5s';
this.$.backgroundFrontLayer.style.willChange = 'opacity';
this.$.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
this.$.backgroundFrontLayer.style.transitionProperty = 'opacity';
this.$.backgroundFrontLayer.style.transitionDuration = duration;
this.$.backgroundRearLayer.style.willChange = 'opacity';
this.$.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
this.$.backgroundRearLayer.style.transitionProperty = 'opacity';
this.$.backgroundRearLayer.style.transitionDuration = duration;
},
run: function run(p, y) {
if (p >= 1) {
this.$.backgroundFrontLayer.style.opacity = 0;
this.$.backgroundRearLayer.style.opacity = 1;
} else {
this.$.backgroundFrontLayer.style.opacity = 1;
this.$.backgroundRearLayer.style.opacity = 0;
}
}
};
scrollEffects['parallax-background'] = {
setUp: function setUp(config) {
var scalar = parseFloat(config.scalar);
this._deltaBg = this.$.backgroundFrontLayer.offsetHeight - this.$.background.offsetHeight;
if (this._deltaBg === 0) {
if (isNaN(scalar)) {
scalar = 0.8;
}
this._deltaBg = this._deltaHeight * scalar;
} else {
if (isNaN(scalar)) {
scalar = 1;
}
this._deltaBg = this._deltaBg * scalar;
}
},
tearDown: function () {
delete this._deltaBg;
},
run: function run(p, y) {
this.transform('translate3d(0px, ' + this._deltaBg * Math.min(1, p) + 'px, 0px)', this.$.backgroundFrontLayer);
if (this.$.backgroundRearLayer) {
this.transform('translate3d(0px, ' + this._deltaBg * Math.min(1, p) + 'px, 0px)', this.$.backgroundRearLayer);
}
}
};
scrollEffects['resize-title'] = {
setUp: function setUp() {
var title = Polymer.dom(this).querySelector('[title]');
var condensedTitle = Polymer.dom(this).querySelector('[condensed-title]');
if (!condensedTitle) {
this._warn(this._logf('effects[resize-title]', 'undefined `condensed-title`'));
return false;
}
if (!title) {
this._warn(this._logf('effects[resize-title]', 'undefined `title`'));
return false;
}
condensedTitle.style.willChange = 'opacity';
title.style.willChange = 'opacity';
condensedTitle.style.webkitTransform = 'translateZ(0)';
title.style.webkitTransform = 'translateZ(0)';
var titleClientRect = title.getBoundingClientRect();
var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
var fx = {};
fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
fx.condensedTitle = condensedTitle;
fx.title = title;
this._fxResizeTitle = fx;
},
tearDown: function tearDown() {
delete this._fxResizeTitle;
},
run: function run(p, y) {
var fx = this._fxResizeTitle;
if (!this.condenses) {
y = 0;
}
if (p >= 1) {
fx.title.style.opacity = 0;
fx.condensedTitle.style.opacity = 1;
} else {
fx.title.style.opacity = 1;
fx.condensedTitle.style.opacity = 0;
}
interpolate(Math.min(1, p), [
[
1,
fx.scale
],
[
0,
-fx.titleDX
],
[
y,
y - fx.titleDY
]
], function (scale, translateX, translateY) {
this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
}, this);
}
};
scrollEffects['resize-snapped-title'] = {
setUp: function setUp(config) {
var title = Polymer.dom(this).querySelector('[title]');
var condensedTitle = Polymer.dom(this).querySelector('[condensed-title]');
var duration = config.duration || '0.2s';
var fx = {};
if (!condensedTitle) {
this._warn(this._logf('effects[resize-snapped-title]', 'undefined `condensed-title`'));
return false;
}
if (!title) {
this._warn(this._logf('effects[resize-snapped-title]', 'undefined `title`'));
return false;
}
title.style.transitionProperty = 'opacity';
title.style.transitionDuration = duration;
condensedTitle.style.transitionProperty = 'opacity';
condensedTitle.style.transitionDuration = duration;
fx.condensedTitle = condensedTitle;
fx.title = title;
this._fxResizeSnappedTitle = fx;
},
tearDown: function tearDown() {
var fx = this._fxResizeSnappedTitle;
fx.title.style.transition = '';
fx.condensedTitle.style.transition = '';
delete this._fxResizeSnappedTitle;
},
run: function run(p, y) {
var fx = this._fxResizeSnappedTitle;
if (p > 0) {
fx.title.style.opacity = 0;
fx.condensedTitle.style.opacity = 1;
} else {
fx.title.style.opacity = 1;
fx.condensedTitle.style.opacity = 0;
}
}
};
scrollEffects.waterfall = {
run: function run(p, y) {
this.shadow = this.isOnScreen() && this.isContentBelow();
}
};
scrollEffects.material = {
setUp: function () {
this.effects = 'waterfall resize-title blend-background parallax-background';
return false;
}
};
}(Polymer.AppLayout.scrollEffects));
Polymer({
is: 'app-header-layout',
behaviors: [Polymer.IronResizableBehavior],
properties: {
hasScrollingRegion: {
type: Boolean,
value: false,
reflectToAttribute: true
}
},
listeners: {
'iron-resize': '_resizeHandler',
'app-header-reset-layout': 'resetLayout'
},
observers: ['resetLayout(isAttached, hasScrollingRegion)'],
get header() {
return Polymer.dom(this.$.header).getDistributedNodes()[0];
},
resetLayout: function () {
this._updateScroller();
this.debounce('_resetLayout', function () {
this._updateContentPosition();
this._updateFixedNodesPosition();
});
},
_getFixedNodes: function () {
return Polymer.dom(this.$.header).getDistributedNodes().concat(Polymer.dom(this.$.underlayContent).getDistributedNodes());
},
_updateContentPosition: function () {
var header = this.header;
var containerStyle = this.$.contentContainer.style;
if (!this.isAttached || !header) {
return;
}
this._headerHeight = header.offsetHeight;
if (header.fixed && !header.willCondense() && this.hasScrollingRegion) {
containerStyle.marginTop = this._headerHeight + 'px';
containerStyle.paddingTop = '';
} else {
containerStyle.paddingTop = this._headerHeight + 'px';
containerStyle.marginTop = '';
}
},
_updateFixedNodesPosition: function () {
var rect = this.getBoundingClientRect();
var rightOffset = document.documentElement.clientWidth - rect.right;
this._getFixedNodes().forEach(function (node) {
node.style.left = this.hasScrollingRegion ? '' : rect.left + 'px';
node.style.right = this.hasScrollingRegion ? '' : rightOffset + 'px';
}.bind(this));
},
_updateScroller: function () {
if (!this.isAttached) {
return;
}
var header = this.header;
if (header) {
header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
}
},
_resizeHandler: function () {
this.resetLayout();
}
});
'use strict';
Polymer({
is: 'carbon-route',
properties: {
route: {
type: Object,
notify: true
},
pattern: { type: String },
data: {
type: Object,
value: function () {
return {};
},
notify: true
},
queryParams: {
type: Object,
value: function () {
return {};
},
notify: true
},
tail: {
type: Object,
value: function () {
return {
path: null,
prefix: null,
__queryParams: null
};
},
notify: true
},
active: {
type: Boolean,
notify: true,
readOnly: true
},
_queryParamsUpdating: {
type: Boolean,
value: false
},
_matched: {
type: String,
value: ''
}
},
observers: [
'__tryToMatch(route.path, pattern)',
'__updatePathOnDataChange(data.*)',
'__tailPathChanged(tail.path)',
'__routeQueryParamsChanged(route.__queryParams)',
'__tailQueryParamsChanged(tail.__queryParams)',
'__queryParamsChanged(queryParams.*)'
],
created: function () {
this.linkPaths('route.__queryParams', 'tail.__queryParams');
this.linkPaths('tail.__queryParams', 'route.__queryParams');
},
__assign: function (target, source) {
if (Object.assign) {
return Object.assign(target, source);
}
if (source != null) {
for (var key in source) {
target[key] = source[key];
}
}
return target;
},
__routeQueryParamsChanged: function (queryParams) {
if (queryParams && this.tail) {
this.set('tail.__queryParams', queryParams);
if (!this.active || this._queryParamsUpdating) {
return;
}
this._queryParamsUpdating = true;
this.set('queryParams', this.__assign({}, queryParams));
this._queryParamsUpdating = false;
}
},
__tailQueryParamsChanged: function (queryParams) {
if (queryParams && this.route) {
this.set('route.__queryParams', queryParams);
}
},
__queryParamsChanged: function (changes) {
if (!this.active || this._queryParamsUpdating) {
return;
}
this.set('route.__' + changes.path, changes.value);
},
__resetProperties: function () {
this._setActive(false);
this._matched = null;
},
__tryToMatch: function () {
if (!this.route) {
return;
}
var path = this.route.path;
var pattern = this.pattern;
if (!pattern) {
return;
}
if (!path) {
this.__resetProperties();
return;
}
var remainingPieces = path.split('/');
var patternPieces = pattern.split('/');
var matched = [];
var namedMatches = {};
for (var i = 0; i < patternPieces.length; i++) {
var patternPiece = patternPieces[i];
if (!patternPiece && patternPiece !== '') {
break;
}
var pathPiece = remainingPieces.shift();
if (!pathPiece && pathPiece !== '') {
this.__resetProperties();
return;
}
matched.push(pathPiece);
if (patternPiece.charAt(0) == ':') {
namedMatches[patternPiece.slice(1)] = pathPiece;
} else if (patternPiece !== pathPiece) {
this.__resetProperties();
return;
}
}
this._matched = matched.join('/');
var propertyUpdates = {};
propertyUpdates.active = true;
var tailPrefix = this.route.prefix + this._matched;
var tailPath = remainingPieces.join('/');
if (remainingPieces.length > 0) {
tailPath = '/' + tailPath;
}
if (!this.tail || this.tail.prefix !== tailPrefix || this.tail.path !== tailPath) {
propertyUpdates.tail = {
prefix: tailPrefix,
path: tailPath,
__queryParams: this.route.__queryParams
};
}
propertyUpdates.data = namedMatches;
this._dataInUrl = {};
for (var key in namedMatches) {
this._dataInUrl[key] = namedMatches[key];
}
this.__setMulti(propertyUpdates);
},
__tailPathChanged: function () {
if (!this.active) {
return;
}
var tailPath = this.tail.path;
var newPath = this._matched;
if (tailPath) {
if (tailPath.charAt(0) !== '/') {
tailPath = '/' + tailPath;
}
newPath += tailPath;
}
this.set('route.path', newPath);
},
__updatePathOnDataChange: function () {
if (!this.route || !this.active) {
return;
}
var newPath = this.__getLink({});
var oldPath = this.__getLink(this._dataInUrl);
if (newPath === oldPath) {
return;
}
this.set('route.path', newPath);
},
__getLink: function (overrideValues) {
var values = { tail: null };
for (var key in this.data) {
values[key] = this.data[key];
}
for (var key in overrideValues) {
values[key] = overrideValues[key];
}
var patternPieces = this.pattern.split('/');
var interp = patternPieces.map(function (value) {
if (value[0] == ':') {
value = values[value.slice(1)];
}
return value;
}, this);
if (values.tail && values.tail.path) {
if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
interp.push(values.tail.path.slice(1));
} else {
interp.push(values.tail.path);
}
}
return interp.join('/');
},
__setMulti: function (setObj) {
for (var property in setObj) {
this._propertySetter(property, setObj[property]);
}
for (var property in setObj) {
this._pathEffector(property, this[property]);
this._notifyPathUp(property, this[property]);
}
}
});
(function () {
'use strict';
Polymer({
is: 'iron-location',
properties: {
path: {
type: String,
notify: true,
value: function () {
return window.decodeURIComponent(window.location.pathname);
}
},
query: {
type: String,
notify: true,
value: function () {
return window.location.search.slice(1);
}
},
hash: {
type: String,
notify: true,
value: function () {
return window.decodeURIComponent(window.location.hash.slice(1));
}
},
dwellTime: {
type: Number,
value: 2000
},
urlSpaceRegex: {
type: String,
value: ''
},
_urlSpaceRegExp: { computed: '_makeRegExp(urlSpaceRegex)' },
_lastChangedAt: { type: Number },
_initialized: {
type: Boolean,
value: false
}
},
hostAttributes: { hidden: true },
observers: ['_updateUrl(path, query, hash)'],
attached: function () {
this.listen(window, 'hashchange', '_hashChanged');
this.listen(window, 'location-changed', '_urlChanged');
this.listen(window, 'popstate', '_urlChanged');
this.listen(document.body, 'click', '_globalOnClick');
this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);
this._initialized = true;
this._urlChanged();
},
detached: function () {
this.unlisten(window, 'hashchange', '_hashChanged');
this.unlisten(window, 'location-changed', '_urlChanged');
this.unlisten(window, 'popstate', '_urlChanged');
this.unlisten(document.body, 'click', '_globalOnClick');
this._initialized = false;
},
_hashChanged: function () {
this.hash = window.decodeURIComponent(window.location.hash.substring(1));
},
_urlChanged: function () {
this._dontUpdateUrl = true;
this._hashChanged();
this.path = window.decodeURIComponent(window.location.pathname);
this.query = window.location.search.substring(1);
this._dontUpdateUrl = false;
this._updateUrl();
},
_getUrl: function () {
var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
var partiallyEncodedQuery = '';
if (this.query) {
partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
}
var partiallyEncodedHash = '';
if (this.hash) {
partiallyEncodedHash = '#' + window.encodeURI(this.hash);
}
return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;
},
_updateUrl: function () {
if (this._dontUpdateUrl || !this._initialized) {
return;
}
if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
return;
}
var newUrl = this._getUrl();
var fullNewUrl = new URL(newUrl, window.location.protocol + '//' + window.location.host).href;
var now = window.performance.now();
var shouldReplace = this._lastChangedAt + this.dwellTime > now;
this._lastChangedAt = now;
if (shouldReplace) {
window.history.replaceState({}, '', fullNewUrl);
} else {
window.history.pushState({}, '', fullNewUrl);
}
this.fire('location-changed', {}, { node: window });
},
_globalOnClick: function (event) {
if (event.defaultPrevented) {
return;
}
var href = this._getSameOriginLinkHref(event);
if (!href) {
return;
}
event.preventDefault();
if (href === window.location.href) {
return;
}
window.history.pushState({}, '', href);
this.fire('location-changed', {}, { node: window });
},
_getSameOriginLinkHref: function (event) {
if (event.button !== 0) {
return null;
}
if (event.metaKey || event.ctrlKey) {
return null;
}
var eventPath = Polymer.dom(event).path;
var anchor = null;
for (var i = 0; i < eventPath.length; i++) {
var element = eventPath[i];
if (element.tagName === 'A' && element.href) {
anchor = element;
break;
}
}
if (!anchor) {
return null;
}
if (anchor.target === '_blank') {
return null;
}
if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {
return null;
}
var href = anchor.href;
var url;
if (document.baseURI != null) {
url = new URL(href, document.baseURI);
} else {
url = new URL(href);
}
var origin;
if (window.location.origin) {
origin = window.location.origin;
} else {
origin = window.location.protocol + '//' + window.location.hostname;
if (window.location.port) {
origin += ':' + window.location.port;
}
}
if (url.origin !== origin) {
return null;
}
var normalizedHref = url.pathname + url.search + url.hash;
if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
return null;
}
var fullNormalizedHref = new URL(normalizedHref, window.location.href).href;
return fullNormalizedHref;
},
_makeRegExp: function (urlSpaceRegex) {
return RegExp(urlSpaceRegex);
}
});
}());
'use strict';
Polymer({
is: 'iron-query-params',
properties: {
paramsString: {
type: String,
notify: true,
observer: 'paramsStringChanged'
},
paramsObject: {
type: Object,
notify: true,
value: function () {
return {};
}
},
_dontReact: {
type: Boolean,
value: false
}
},
hostAttributes: { hidden: true },
observers: ['paramsObjectChanged(paramsObject.*)'],
paramsStringChanged: function () {
this._dontReact = true;
this.paramsObject = this._decodeParams(this.paramsString);
this._dontReact = false;
},
paramsObjectChanged: function () {
if (this._dontReact) {
return;
}
this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
},
_encodeParams: function (params) {
var encodedParams = [];
for (var key in params) {
var value = params[key];
if (value === '') {
encodedParams.push(encodeURIComponent(key));
} else if (value) {
encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));
}
}
return encodedParams.join('&');
},
_decodeParams: function (paramString) {
var params = {};
paramString = (paramString || '').replace(/\+/g, '%20');
var paramList = paramString.split('&');
for (var i = 0; i < paramList.length; i++) {
var param = paramList[i].split('=');
if (param[0]) {
params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');
}
}
return params;
}
});
'use strict';
Polymer({
is: 'carbon-route-converter',
properties: {
route: {
type: Object,
notify: true
},
queryParams: {
type: Object,
notify: true
},
path: {
type: String,
notify: true
}
},
observers: [
'_locationChanged(path, queryParams)',
'_routeChanged(route.prefix, route.path)',
'_routeQueryParamsChanged(route.__queryParams)'
],
created: function () {
this.linkPaths('route.__queryParams', 'queryParams');
this.linkPaths('queryParams', 'route.__queryParams');
},
_locationChanged: function () {
if (this.route && this.route.path === this.path && this.queryParams === this.route.__queryParams) {
return;
}
this.route = {
prefix: '',
path: this.path,
__queryParams: this.queryParams
};
},
_routeChanged: function () {
if (!this.route) {
return;
}
this.path = this.route.prefix + this.route.path;
},
_routeQueryParamsChanged: function (queryParams) {
if (!this.route) {
return;
}
this.queryParams = queryParams;
}
});
'use strict';
Polymer({
is: 'carbon-location',
properties: {
route: {
type: Object,
notify: true
},
useHashAsPath: {
type: Boolean,
value: false
},
urlSpaceRegex: {
type: String,
notify: true
},
__queryParams: { type: Object },
__path: { type: String },
__query: { type: String },
__hash: { type: String }
},
__computeRoutePath: function () {
return this.useHashAsPath ? this.__hash : this.__path;
},
__onPathChanged: function (event) {
if (!this._readied) {
return;
}
var path = event.detail.value;
if (this.useHashAsPath) {
this.__hash = path;
} else {
this.__path = path;
}
}
});
Polymer({
is: 'iron-image',
properties: {
src: {
observer: '_srcChanged',
type: String,
value: ''
},
alt: {
type: String,
value: null
},
preventLoad: {
type: Boolean,
value: false,
observer: '_preventLoadChanged'
},
sizing: {
type: String,
value: null,
reflectToAttribute: true
},
position: {
type: String,
value: 'center'
},
preload: {
type: Boolean,
value: false
},
placeholder: {
type: String,
value: null,
observer: '_placeholderChanged'
},
fade: {
type: Boolean,
value: false
},
loaded: {
notify: true,
readOnly: true,
type: Boolean,
value: false
},
loading: {
notify: true,
readOnly: true,
type: Boolean,
value: false
},
error: {
notify: true,
readOnly: true,
type: Boolean,
value: false
},
width: {
observer: '_widthChanged',
type: Number,
value: null
},
height: {
observer: '_heightChanged',
type: Number,
value: null
}
},
observers: ['_transformChanged(sizing, position)'],
ready: function () {
var img = this.$.img;
img.onload = function () {
if (this.$.img.src !== this._resolveSrc(this.src))
return;
this._setLoading(false);
this._setLoaded(true);
this._setError(false);
}.bind(this);
img.onerror = function () {
if (this.$.img.src !== this._resolveSrc(this.src))
return;
this._reset();
this._setLoading(false);
this._setLoaded(false);
this._setError(true);
}.bind(this);
this._resolvedSrc = '';
},
_load: function (src) {
if (src) {
this.$.img.src = src;
} else {
this.$.img.removeAttribute('src');
}
this.$.sizedImgDiv.style.backgroundImage = src ? 'url("' + src + '")' : '';
this._setLoading(!!src);
this._setLoaded(false);
this._setError(false);
},
_reset: function () {
this.$.img.removeAttribute('src');
this.$.sizedImgDiv.style.backgroundImage = '';
this._setLoading(false);
this._setLoaded(false);
this._setError(false);
},
_computePlaceholderHidden: function () {
return !this.preload || !this.fade && !this.loading && this.loaded;
},
_computePlaceholderClassName: function () {
return this.preload && this.fade && !this.loading && this.loaded ? 'faded-out' : '';
},
_computeImgDivHidden: function () {
return !this.sizing;
},
_computeImgDivARIAHidden: function () {
return this.alt === '' ? 'true' : undefined;
},
_computeImgDivARIALabel: function () {
if (this.alt !== null) {
return this.alt;
}
if (this.src === '') {
return '';
}
var pathComponents = new URL(this._resolveSrc(this.src)).pathname.split('/');
return pathComponents[pathComponents.length - 1];
},
_computeImgHidden: function () {
return !!this.sizing;
},
_widthChanged: function () {
this.style.width = isNaN(this.width) ? this.width : this.width + 'px';
},
_heightChanged: function () {
this.style.height = isNaN(this.height) ? this.height : this.height + 'px';
},
_preventLoadChanged: function () {
if (this.preventLoad || this.loaded)
return;
this._reset();
this._load(this.src);
},
_srcChanged: function (newSrc, oldSrc) {
var newResolvedSrc = this._resolveSrc(newSrc);
if (newResolvedSrc === this._resolvedSrc)
return;
this._resolvedSrc = newResolvedSrc;
this._reset();
if (!this.preventLoad) {
this._load(newSrc);
}
},
_placeholderChanged: function () {
this.$.placeholder.style.backgroundImage = this.placeholder ? 'url("' + this.placeholder + '")' : '';
},
_transformChanged: function () {
var sizedImgDivStyle = this.$.sizedImgDiv.style;
var placeholderStyle = this.$.placeholder.style;
sizedImgDivStyle.backgroundSize = placeholderStyle.backgroundSize = this.sizing;
sizedImgDivStyle.backgroundPosition = placeholderStyle.backgroundPosition = this.sizing ? this.position : '';
sizedImgDivStyle.backgroundRepeat = placeholderStyle.backgroundRepeat = this.sizing ? 'no-repeat' : '';
},
_resolveSrc: function (testSrc) {
var baseURI = this.ownerDocument.baseURI;
return new URL(Polymer.ResolveUrl.resolveUrl(testSrc, baseURI), baseURI).href;
}
});
Polymer({
is: 'paper-card',
properties: {
heading: {
type: String,
value: '',
observer: '_headingChanged'
},
image: {
type: String,
value: ''
},
alt: { type: String },
preloadImage: {
type: Boolean,
value: false
},
fadeImage: {
type: Boolean,
value: false
},
placeholderImage: {
type: String,
value: null
},
elevation: {
type: Number,
value: 1,
reflectToAttribute: true
},
animatedShadow: {
type: Boolean,
value: false
},
animated: {
type: Boolean,
reflectToAttribute: true,
readOnly: true,
computed: '_computeAnimated(animatedShadow)'
}
},
_isHidden: function (image) {
return image ? 'false' : 'true';
},
_headingChanged: function (heading) {
var currentHeading = this.getAttribute('heading'), currentLabel = this.getAttribute('aria-label');
if (typeof currentLabel !== 'string' || currentLabel === currentHeading) {
this.setAttribute('aria-label', heading);
}
},
_computeHeadingClass: function (image) {
return image ? ' over-image' : '';
},
_computeAnimated: function (animatedShadow) {
return animatedShadow;
}
});
(function () {
'use strict';
Polymer({
is: 'login-page',
properties: {
username: {
type: String,
value: '',
notify: true
},
currentPage: {
type: String,
notify: true,
observer: '_stopVideo'
}
},
signin: function (e) {
document.cookie = 'username=' + this.username;
this.fire('navigate', 'graph');
},
_checkForEnter: function (e) {
if (e.keyCode == 13) {
this.signin(e);
}
},
_stopVideo: function () {
if (this.currentPage == '') {
this.$.bgvid.play();
} else {
this.$.bgvid.pause();
}
},
_restartVideo: function (e) {
this.$.bgvid.load();
this.$.bgvid.play();
}
});
}());
Polymer.IronCheckedElementBehaviorImpl = {
properties: {
checked: {
type: Boolean,
value: false,
reflectToAttribute: true,
notify: true,
observer: '_checkedChanged'
},
toggles: {
type: Boolean,
value: true,
reflectToAttribute: true
},
value: {
type: String,
value: 'on',
observer: '_valueChanged'
}
},
observers: ['_requiredChanged(required)'],
created: function () {
this._hasIronCheckedElementBehavior = true;
},
_getValidity: function (_value) {
return this.disabled || !this.required || this.checked;
},
_requiredChanged: function () {
if (this.required) {
this.setAttribute('aria-required', 'true');
} else {
this.removeAttribute('aria-required');
}
},
_checkedChanged: function () {
this.active = this.checked;
this.fire('iron-change');
},
_valueChanged: function () {
if (this.value === undefined || this.value === null) {
this.value = 'on';
}
}
};
Polymer.IronCheckedElementBehavior = [
Polymer.IronFormElementBehavior,
Polymer.IronValidatableBehavior,
Polymer.IronCheckedElementBehaviorImpl
];
Polymer.PaperCheckedElementBehaviorImpl = {
_checkedChanged: function () {
Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
if (this.hasRipple()) {
if (this.checked) {
this._ripple.setAttribute('checked', '');
} else {
this._ripple.removeAttribute('checked');
}
}
},
_buttonStateChanged: function () {
Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
if (this.disabled) {
return;
}
if (this.isAttached) {
this.checked = this.active;
}
}
};
Polymer.PaperCheckedElementBehavior = [
Polymer.PaperInkyFocusBehavior,
Polymer.IronCheckedElementBehavior,
Polymer.PaperCheckedElementBehaviorImpl
];
Polymer({
is: 'paper-toggle-button',
behaviors: [Polymer.PaperCheckedElementBehavior],
hostAttributes: {
role: 'button',
'aria-pressed': 'false',
tabindex: 0
},
properties: {},
listeners: { track: '_ontrack' },
attached: function () {
Polymer.RenderStatus.afterNextRender(this, function () {
this.setScrollDirection('y');
});
},
_ontrack: function (event) {
var track = event.detail;
if (track.state === 'start') {
this._trackStart(track);
} else if (track.state === 'track') {
this._trackMove(track);
} else if (track.state === 'end') {
this._trackEnd(track);
}
},
_trackStart: function (track) {
this._width = this.$.toggleBar.offsetWidth / 2;
this._trackChecked = this.checked;
this.$.toggleButton.classList.add('dragging');
},
_trackMove: function (track) {
var dx = track.dx;
this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + dx : dx));
this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
this._userActivate(this._x > this._width / 2);
},
_trackEnd: function (track) {
this.$.toggleButton.classList.remove('dragging');
this.transform('', this.$.toggleButton);
},
_createRipple: function () {
this._rippleContainer = this.$.toggleButton;
var ripple = Polymer.PaperRippleBehavior._createRipple();
ripple.id = 'ink';
ripple.setAttribute('recenters', '');
ripple.classList.add('circle', 'toggle-ink');
return ripple;
}
});
Polymer({
is: 'paper-checkbox',
behaviors: [Polymer.PaperCheckedElementBehavior],
hostAttributes: {
role: 'checkbox',
'aria-checked': false,
tabindex: 0
},
properties: {
ariaActiveAttribute: {
type: String,
value: 'aria-checked'
}
},
attached: function () {
var inkSize = this.getComputedStyleValue('--calculated-paper-checkbox-ink-size').trim();
if (inkSize === '-1px') {
var checkboxSize = parseFloat(this.getComputedStyleValue('--calculated-paper-checkbox-size').trim());
var defaultInkSize = Math.floor(8 / 3 * checkboxSize);
if (defaultInkSize % 2 !== checkboxSize % 2) {
defaultInkSize++;
}
this.customStyle['--paper-checkbox-ink-size'] = defaultInkSize + 'px';
this.updateStyles();
}
},
_computeCheckboxClass: function (checked, invalid) {
var className = '';
if (checked) {
className += 'checked ';
}
if (invalid) {
className += 'invalid';
}
return className;
},
_computeCheckmarkClass: function (checked) {
return checked ? '' : 'hidden';
},
_createRipple: function () {
this._rippleContainer = this.$.checkboxContainer;
return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
}
});
Polymer({
is: 'paper-icon-item',
behaviors: [Polymer.PaperItemBehavior]
});
Polymer({
is: 'paper-input-chip',
properties: {
label: String,
allowRemove: Boolean
},
remove: function (event) {
if (!this.allowRemove) {
return;
}
this.fire('remove', this.label);
event.stopPropagation();
}
});
Polymer({
is: 'paper-chips-input',
properties: {
_selected: {
type: Number,
value: 0
},
_hovered: {
type: Boolean,
value: false
},
noLabelFloat: { type: Boolean },
label: String,
input: {
type: String,
notify: true,
value: ''
},
suggestions: {
type: Array,
computed: '_computeSuggestions(input, values.*, selectedValues.*)'
},
values: {
type: Array,
value: function () {
return [];
}
},
selectedValues: {
type: Array,
notify: true,
value: function () {
return [];
}
}
},
_computeLabel: function (id, values) {
var arr = values.filter(function (obj) {
return obj.id == id;
});
return arr[0].label;
},
_control: function (event) {
if (event.keyCode === 40) {
this.$.menu.selectNext();
this.selectedItem.scrollIntoView();
return;
}
if (event.keyCode === 38) {
this.$.menu.selectPrevious();
this.selectedItem.scrollIntoView();
return;
}
if (event.keyCode === 13) {
this._addElement(true);
}
if (!this.input && event.keyCode === 8) {
this.pop('selectedValues');
this.$.dropdown.close();
this.$.dropdown.open();
}
this.set('_selected', 0);
},
_computeSuggestions: function (input, valuesRecord, selectedValuesRecord) {
var values = valuesRecord.base;
var selectedValues = selectedValuesRecord.base;
values.sort();
if (selectedValues) {
values = values.filter(function (o) {
return selectedValues.indexOf(o.id) === -1;
});
}
if (!input) {
return values;
}
var startMatch = values.filter(function (o) {
return o.label.toLowerCase().startsWith(input.toLowerCase());
});
var contains = values.filter(function (o) {
return startMatch.indexOf(o) == -1;
}).filter(function (o) {
return o.label.toLowerCase().indexOf(input.toLowerCase()) != -1;
});
return startMatch.concat(contains);
},
_removeChip: function (e) {
var pos = this.selectedValues.indexOf(e.model.item);
if (pos === -1) {
return;
}
this.splice('selectedValues', pos, 1);
},
_addElement: function (reopen) {
if (!this.suggestions || this.suggestions.length === 0) {
return;
}
this.push('selectedValues', JSON.parse(this.selectedItem.getAttribute('item')).id);
this.$.dropdown.close();
if (reopen) {
this.$.dropdown.open();
}
this.set('input', '');
},
_hasSuggestion: function (suggestions) {
return suggestions.length > 0;
},
_onHover: function (event) {
this._hovered = true;
},
_onUnHover: function (event) {
this._hovered = false;
},
_opened: function (focused, hover) {
return focused || hover;
},
_selectByClick: function (e) {
this.selectedItem = e.target;
this._addElement(false);
this.set('_selected', 0);
}
});
(function () {
'use strict';
Polymer({
is: 'graph-settings',
properties: {
airlines: {
type: Array,
notify: true
},
markets: {
type: Array,
notify: true
},
dataFilter: {
type: Object,
value: {
name: '',
shareable: false,
rangeFrom: '2015-01-01',
rangeTo: '2015-12-01',
axis: {
x: 'TIME',
y: 'FLIGHTS'
},
filter: {
timestep: 'MONTH',
airlines: [],
destinations: []
}
}
}
},
_computeIsAvailable: function (selected) {
if (selected === 'PASSENGERS') {
this.set('dataFilter.filter.timestep', 'MONTH');
return false;
}
return true;
},
_applySetting: function (event) {
var setting = this._getSettingFromForm();
if (setting) {
this.fire('apply-setting', setting);
}
},
_saveSettings: function () {
if (this.$.settingsNameInput.invalid) {
return;
}
var setting = this._getSettingFromForm();
if (setting) {
this.fire('save-setting', setting);
}
},
_getSettingFromForm: function () {
var inputFrom = this.$.inputFrom;
var inputTo = this.$.inputTo;
var fromDate = new Date(inputFrom.value);
var toDate = new Date(inputTo.value);
var now = new Date();
if (fromDate < now && toDate < now && fromDate < toDate) {
inputFrom.invalid = false;
inputTo.invalid = false;
return this.dataFilter;
} else if (fromDate > now) {
inputFrom.errorMessage = 'Needs to be in the past.';
inputFrom.invalid = true;
} else if (toDate > now) {
inputTo.errorMessage = 'Needs to be in the past.';
inputTo.invalid = true;
} else if (fromDate > toDate) {
inputFrom.errorMessage = 'Needs to be before To-Date';
inputTo.errorMessage = 'Needs to be after From-Date';
inputFrom.invalid = true;
inputTo.invalid = true;
}
console.error('Invalid date input');
return null;
},
_computeForChips: function (elements) {
return elements.map(function (e) {
e.label = e.name;
return e;
});
}
});
}());
(function (f) {
if (typeof exports === 'object' && typeof module !== 'undefined') {
module.exports = f();
} else if (typeof define === 'function' && define.amd) {
define([], f);
} else {
var g;
if (typeof window !== 'undefined') {
g = window;
} else if (typeof global !== 'undefined') {
g = global;
} else if (typeof self !== 'undefined') {
g = self;
} else {
g = this;
}
g.Chart = f();
}
}(function () {
var define, module, exports;
return function e(t, n, r) {
function s(o, u) {
if (!n[o]) {
if (!t[o]) {
var a = typeof require == 'function' && require;
if (!u && a)
return a(o, !0);
if (i)
return i(o, !0);
var f = new Error('Cannot find module \'' + o + '\'');
throw f.code = 'MODULE_NOT_FOUND', f;
}
var l = n[o] = { exports: {} };
t[o][0].call(l.exports, function (e) {
var n = t[o][1][e];
return s(n ? n : e);
}, l, l.exports, e, t, n, r);
}
return n[o].exports;
}
var i = typeof require == 'function' && require;
for (var o = 0; o < r.length; o++)
s(r[o]);
return s;
}({
1: [
function (require, module, exports) {
},
{}
],
2: [
function (require, module, exports) {
var colorNames = require(6);
module.exports = {
getRgba: getRgba,
getHsla: getHsla,
getRgb: getRgb,
getHsl: getHsl,
getHwb: getHwb,
getAlpha: getAlpha,
hexString: hexString,
rgbString: rgbString,
rgbaString: rgbaString,
percentString: percentString,
percentaString: percentaString,
hslString: hslString,
hslaString: hslaString,
hwbString: hwbString,
keyword: keyword
};
function getRgba(string) {
if (!string) {
return;
}
var abbr = /^#([a-fA-F0-9]{3})$/i, hex = /^#([a-fA-F0-9]{6})$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword = /(\w+)/;
var rgb = [
0,
0,
0
], a = 1, match = string.match(abbr);
if (match) {
match = match[1];
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match[i] + match[i], 16);
}
} else if (match = string.match(hex)) {
match = match[1];
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
}
} else if (match = string.match(rgba)) {
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match[i + 1]);
}
a = parseFloat(match[4]);
} else if (match = string.match(per)) {
for (var i = 0; i < rgb.length; i++) {
rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
}
a = parseFloat(match[4]);
} else if (match = string.match(keyword)) {
if (match[1] == 'transparent') {
return [
0,
0,
0,
0
];
}
rgb = colorNames[match[1]];
if (!rgb) {
return;
}
}
for (var i = 0; i < rgb.length; i++) {
rgb[i] = scale(rgb[i], 0, 255);
}
if (!a && a != 0) {
a = 1;
} else {
a = scale(a, 0, 1);
}
rgb[3] = a;
return rgb;
}
function getHsla(string) {
if (!string) {
return;
}
var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
var match = string.match(hsl);
if (match) {
var alpha = parseFloat(match[4]);
var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
return [
h,
s,
l,
a
];
}
}
function getHwb(string) {
if (!string) {
return;
}
var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
var match = string.match(hwb);
if (match) {
var alpha = parseFloat(match[4]);
var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
return [
h,
w,
b,
a
];
}
}
function getRgb(string) {
var rgba = getRgba(string);
return rgba && rgba.slice(0, 3);
}
function getHsl(string) {
var hsla = getHsla(string);
return hsla && hsla.slice(0, 3);
}
function getAlpha(string) {
var vals = getRgba(string);
if (vals) {
return vals[3];
} else if (vals = getHsla(string)) {
return vals[3];
} else if (vals = getHwb(string)) {
return vals[3];
}
}
function hexString(rgb) {
return '#' + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
}
function rgbString(rgba, alpha) {
if (alpha < 1 || rgba[3] && rgba[3] < 1) {
return rgbaString(rgba, alpha);
}
return 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')';
}
function rgbaString(rgba, alpha) {
if (alpha === undefined) {
alpha = rgba[3] !== undefined ? rgba[3] : 1;
}
return 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + alpha + ')';
}
function percentString(rgba, alpha) {
if (alpha < 1 || rgba[3] && rgba[3] < 1) {
return percentaString(rgba, alpha);
}
var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
return 'rgb(' + r + '%, ' + g + '%, ' + b + '%)';
}
function percentaString(rgba, alpha) {
var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
return 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + (alpha || rgba[3] || 1) + ')';
}
function hslString(hsla, alpha) {
if (alpha < 1 || hsla[3] && hsla[3] < 1) {
return hslaString(hsla, alpha);
}
return 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)';
}
function hslaString(hsla, alpha) {
if (alpha === undefined) {
alpha = hsla[3] !== undefined ? hsla[3] : 1;
}
return 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + alpha + ')';
}
function hwbString(hwb, alpha) {
if (alpha === undefined) {
alpha = hwb[3] !== undefined ? hwb[3] : 1;
}
return 'hwb(' + hwb[0] + ', ' + hwb[1] + '%, ' + hwb[2] + '%' + (alpha !== undefined && alpha !== 1 ? ', ' + alpha : '') + ')';
}
function keyword(rgb) {
return reverseNames[rgb.slice(0, 3)];
}
function scale(num, min, max) {
return Math.min(Math.max(min, num), max);
}
function hexDouble(num) {
var str = num.toString(16).toUpperCase();
return str.length < 2 ? '0' + str : str;
}
var reverseNames = {};
for (var name in colorNames) {
reverseNames[colorNames[name]] = name;
}
},
{ '6': 6 }
],
3: [
function (require, module, exports) {
var convert = require(5);
var string = require(2);
var Color = function (obj) {
if (obj instanceof Color) {
return obj;
}
if (!(this instanceof Color)) {
return new Color(obj);
}
this.valid = false;
this.values = {
rgb: [
0,
0,
0
],
hsl: [
0,
0,
0
],
hsv: [
0,
0,
0
],
hwb: [
0,
0,
0
],
cmyk: [
0,
0,
0,
0
],
alpha: 1
};
var vals;
if (typeof obj === 'string') {
vals = string.getRgba(obj);
if (vals) {
this.setValues('rgb', vals);
} else if (vals = string.getHsla(obj)) {
this.setValues('hsl', vals);
} else if (vals = string.getHwb(obj)) {
this.setValues('hwb', vals);
}
} else if (typeof obj === 'object') {
vals = obj;
if (vals.r !== undefined || vals.red !== undefined) {
this.setValues('rgb', vals);
} else if (vals.l !== undefined || vals.lightness !== undefined) {
this.setValues('hsl', vals);
} else if (vals.v !== undefined || vals.value !== undefined) {
this.setValues('hsv', vals);
} else if (vals.w !== undefined || vals.whiteness !== undefined) {
this.setValues('hwb', vals);
} else if (vals.c !== undefined || vals.cyan !== undefined) {
this.setValues('cmyk', vals);
}
}
};
Color.prototype = {
isValid: function () {
return this.valid;
},
rgb: function () {
return this.setSpace('rgb', arguments);
},
hsl: function () {
return this.setSpace('hsl', arguments);
},
hsv: function () {
return this.setSpace('hsv', arguments);
},
hwb: function () {
return this.setSpace('hwb', arguments);
},
cmyk: function () {
return this.setSpace('cmyk', arguments);
},
rgbArray: function () {
return this.values.rgb;
},
hslArray: function () {
return this.values.hsl;
},
hsvArray: function () {
return this.values.hsv;
},
hwbArray: function () {
var values = this.values;
if (values.alpha !== 1) {
return values.hwb.concat([values.alpha]);
}
return values.hwb;
},
cmykArray: function () {
return this.values.cmyk;
},
rgbaArray: function () {
var values = this.values;
return values.rgb.concat([values.alpha]);
},
hslaArray: function () {
var values = this.values;
return values.hsl.concat([values.alpha]);
},
alpha: function (val) {
if (val === undefined) {
return this.values.alpha;
}
this.setValues('alpha', val);
return this;
},
red: function (val) {
return this.setChannel('rgb', 0, val);
},
green: function (val) {
return this.setChannel('rgb', 1, val);
},
blue: function (val) {
return this.setChannel('rgb', 2, val);
},
hue: function (val) {
if (val) {
val %= 360;
val = val < 0 ? 360 + val : val;
}
return this.setChannel('hsl', 0, val);
},
saturation: function (val) {
return this.setChannel('hsl', 1, val);
},
lightness: function (val) {
return this.setChannel('hsl', 2, val);
},
saturationv: function (val) {
return this.setChannel('hsv', 1, val);
},
whiteness: function (val) {
return this.setChannel('hwb', 1, val);
},
blackness: function (val) {
return this.setChannel('hwb', 2, val);
},
value: function (val) {
return this.setChannel('hsv', 2, val);
},
cyan: function (val) {
return this.setChannel('cmyk', 0, val);
},
magenta: function (val) {
return this.setChannel('cmyk', 1, val);
},
yellow: function (val) {
return this.setChannel('cmyk', 2, val);
},
black: function (val) {
return this.setChannel('cmyk', 3, val);
},
hexString: function () {
return string.hexString(this.values.rgb);
},
rgbString: function () {
return string.rgbString(this.values.rgb, this.values.alpha);
},
rgbaString: function () {
return string.rgbaString(this.values.rgb, this.values.alpha);
},
percentString: function () {
return string.percentString(this.values.rgb, this.values.alpha);
},
hslString: function () {
return string.hslString(this.values.hsl, this.values.alpha);
},
hslaString: function () {
return string.hslaString(this.values.hsl, this.values.alpha);
},
hwbString: function () {
return string.hwbString(this.values.hwb, this.values.alpha);
},
keyword: function () {
return string.keyword(this.values.rgb, this.values.alpha);
},
rgbNumber: function () {
var rgb = this.values.rgb;
return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
},
luminosity: function () {
var rgb = this.values.rgb;
var lum = [];
for (var i = 0; i < rgb.length; i++) {
var chan = rgb[i] / 255;
lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
}
return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
},
contrast: function (color2) {
var lum1 = this.luminosity();
var lum2 = color2.luminosity();
if (lum1 > lum2) {
return (lum1 + 0.05) / (lum2 + 0.05);
}
return (lum2 + 0.05) / (lum1 + 0.05);
},
level: function (color2) {
var contrastRatio = this.contrast(color2);
if (contrastRatio >= 7.1) {
return 'AAA';
}
return contrastRatio >= 4.5 ? 'AA' : '';
},
dark: function () {
var rgb = this.values.rgb;
var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
return yiq < 128;
},
light: function () {
return !this.dark();
},
negate: function () {
var rgb = [];
for (var i = 0; i < 3; i++) {
rgb[i] = 255 - this.values.rgb[i];
}
this.setValues('rgb', rgb);
return this;
},
lighten: function (ratio) {
var hsl = this.values.hsl;
hsl[2] += hsl[2] * ratio;
this.setValues('hsl', hsl);
return this;
},
darken: function (ratio) {
var hsl = this.values.hsl;
hsl[2] -= hsl[2] * ratio;
this.setValues('hsl', hsl);
return this;
},
saturate: function (ratio) {
var hsl = this.values.hsl;
hsl[1] += hsl[1] * ratio;
this.setValues('hsl', hsl);
return this;
},
desaturate: function (ratio) {
var hsl = this.values.hsl;
hsl[1] -= hsl[1] * ratio;
this.setValues('hsl', hsl);
return this;
},
whiten: function (ratio) {
var hwb = this.values.hwb;
hwb[1] += hwb[1] * ratio;
this.setValues('hwb', hwb);
return this;
},
blacken: function (ratio) {
var hwb = this.values.hwb;
hwb[2] += hwb[2] * ratio;
this.setValues('hwb', hwb);
return this;
},
greyscale: function () {
var rgb = this.values.rgb;
var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
this.setValues('rgb', [
val,
val,
val
]);
return this;
},
clearer: function (ratio) {
var alpha = this.values.alpha;
this.setValues('alpha', alpha - alpha * ratio);
return this;
},
opaquer: function (ratio) {
var alpha = this.values.alpha;
this.setValues('alpha', alpha + alpha * ratio);
return this;
},
rotate: function (degrees) {
var hsl = this.values.hsl;
var hue = (hsl[0] + degrees) % 360;
hsl[0] = hue < 0 ? 360 + hue : hue;
this.setValues('hsl', hsl);
return this;
},
mix: function (mixinColor, weight) {
var color1 = this;
var color2 = mixinColor;
var p = weight === undefined ? 0.5 : weight;
var w = 2 * p - 1;
var a = color1.alpha() - color2.alpha();
var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
var w2 = 1 - w1;
return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
},
toJSON: function () {
return this.rgb();
},
clone: function () {
var result = new Color();
var source = this.values;
var target = result.values;
var value, type;
for (var prop in source) {
if (source.hasOwnProperty(prop)) {
value = source[prop];
type = {}.toString.call(value);
if (type === '[object Array]') {
target[prop] = value.slice(0);
} else if (type === '[object Number]') {
target[prop] = value;
} else {
console.error('unexpected color value:', value);
}
}
}
return result;
}
};
Color.prototype.spaces = {
rgb: [
'red',
'green',
'blue'
],
hsl: [
'hue',
'saturation',
'lightness'
],
hsv: [
'hue',
'saturation',
'value'
],
hwb: [
'hue',
'whiteness',
'blackness'
],
cmyk: [
'cyan',
'magenta',
'yellow',
'black'
]
};
Color.prototype.maxes = {
rgb: [
255,
255,
255
],
hsl: [
360,
100,
100
],
hsv: [
360,
100,
100
],
hwb: [
360,
100,
100
],
cmyk: [
100,
100,
100,
100
]
};
Color.prototype.getValues = function (space) {
var values = this.values;
var vals = {};
for (var i = 0; i < space.length; i++) {
vals[space.charAt(i)] = values[space][i];
}
if (values.alpha !== 1) {
vals.a = values.alpha;
}
return vals;
};
Color.prototype.setValues = function (space, vals) {
var values = this.values;
var spaces = this.spaces;
var maxes = this.maxes;
var alpha = 1;
var i;
this.valid = true;
if (space === 'alpha') {
alpha = vals;
} else if (vals.length) {
values[space] = vals.slice(0, space.length);
alpha = vals[space.length];
} else if (vals[space.charAt(0)] !== undefined) {
for (i = 0; i < space.length; i++) {
values[space][i] = vals[space.charAt(i)];
}
alpha = vals.a;
} else if (vals[spaces[space][0]] !== undefined) {
var chans = spaces[space];
for (i = 0; i < space.length; i++) {
values[space][i] = vals[chans[i]];
}
alpha = vals.alpha;
}
values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));
if (space === 'alpha') {
return false;
}
var capped;
for (i = 0; i < space.length; i++) {
capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
values[space][i] = Math.round(capped);
}
for (var sname in spaces) {
if (sname !== space) {
values[sname] = convert[space][sname](values[space]);
}
}
return true;
};
Color.prototype.setSpace = function (space, args) {
var vals = args[0];
if (vals === undefined) {
return this.getValues(space);
}
if (typeof vals === 'number') {
vals = Array.prototype.slice.call(args);
}
this.setValues(space, vals);
return this;
};
Color.prototype.setChannel = function (space, index, val) {
var svalues = this.values[space];
if (val === undefined) {
return svalues[index];
} else if (val === svalues[index]) {
return this;
}
svalues[index] = val;
this.setValues(space, svalues);
return this;
};
if (typeof window !== 'undefined') {
window.Color = Color;
}
module.exports = Color;
},
{
'2': 2,
'5': 5
}
],
4: [
function (require, module, exports) {
module.exports = {
rgb2hsl: rgb2hsl,
rgb2hsv: rgb2hsv,
rgb2hwb: rgb2hwb,
rgb2cmyk: rgb2cmyk,
rgb2keyword: rgb2keyword,
rgb2xyz: rgb2xyz,
rgb2lab: rgb2lab,
rgb2lch: rgb2lch,
hsl2rgb: hsl2rgb,
hsl2hsv: hsl2hsv,
hsl2hwb: hsl2hwb,
hsl2cmyk: hsl2cmyk,
hsl2keyword: hsl2keyword,
hsv2rgb: hsv2rgb,
hsv2hsl: hsv2hsl,
hsv2hwb: hsv2hwb,
hsv2cmyk: hsv2cmyk,
hsv2keyword: hsv2keyword,
hwb2rgb: hwb2rgb,
hwb2hsl: hwb2hsl,
hwb2hsv: hwb2hsv,
hwb2cmyk: hwb2cmyk,
hwb2keyword: hwb2keyword,
cmyk2rgb: cmyk2rgb,
cmyk2hsl: cmyk2hsl,
cmyk2hsv: cmyk2hsv,
cmyk2hwb: cmyk2hwb,
cmyk2keyword: cmyk2keyword,
keyword2rgb: keyword2rgb,
keyword2hsl: keyword2hsl,
keyword2hsv: keyword2hsv,
keyword2hwb: keyword2hwb,
keyword2cmyk: keyword2cmyk,
keyword2lab: keyword2lab,
keyword2xyz: keyword2xyz,
xyz2rgb: xyz2rgb,
xyz2lab: xyz2lab,
xyz2lch: xyz2lch,
lab2xyz: lab2xyz,
lab2rgb: lab2rgb,
lab2lch: lab2lch,
lch2lab: lch2lab,
lch2xyz: lch2xyz,
lch2rgb: lch2rgb
};
function rgb2hsl(rgb) {
var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
if (max == min)
h = 0;
else if (r == max)
h = (g - b) / delta;
else if (g == max)
h = 2 + (b - r) / delta;
else if (b == max)
h = 4 + (r - g) / delta;
h = Math.min(h * 60, 360);
if (h < 0)
h += 360;
l = (min + max) / 2;
if (max == min)
s = 0;
else if (l <= 0.5)
s = delta / (max + min);
else
s = delta / (2 - max - min);
return [
h,
s * 100,
l * 100
];
}
function rgb2hsv(rgb) {
var r = rgb[0], g = rgb[1], b = rgb[2], min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, v;
if (max == 0)
s = 0;
else
s = delta / max * 1000 / 10;
if (max == min)
h = 0;
else if (r == max)
h = (g - b) / delta;
else if (g == max)
h = 2 + (b - r) / delta;
else if (b == max)
h = 4 + (r - g) / delta;
h = Math.min(h * 60, 360);
if (h < 0)
h += 360;
v = max / 255 * 1000 / 10;
return [
h,
s,
v
];
}
function rgb2hwb(rgb) {
var r = rgb[0], g = rgb[1], b = rgb[2], h = rgb2hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b)), b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
return [
h,
w * 100,
b * 100
];
}
function rgb2cmyk(rgb) {
var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, c, m, y, k;
k = Math.min(1 - r, 1 - g, 1 - b);
c = (1 - r - k) / (1 - k) || 0;
m = (1 - g - k) / (1 - k) || 0;
y = (1 - b - k) / (1 - k) || 0;
return [
c * 100,
m * 100,
y * 100,
k * 100
];
}
function rgb2keyword(rgb) {
return reverseKeywords[JSON.stringify(rgb)];
}
function rgb2xyz(rgb) {
var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
return [
x * 100,
y * 100,
z * 100
];
}
function rgb2lab(rgb) {
var xyz = rgb2xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
x /= 95.047;
y /= 100;
z /= 108.883;
x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
l = 116 * y - 16;
a = 500 * (x - y);
b = 200 * (y - z);
return [
l,
a,
b
];
}
function rgb2lch(args) {
return lab2lch(rgb2lab(args));
}
function hsl2rgb(hsl) {
var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
if (s == 0) {
val = l * 255;
return [
val,
val,
val
];
}
if (l < 0.5)
t2 = l * (1 + s);
else
t2 = l + s - l * s;
t1 = 2 * l - t2;
rgb = [
0,
0,
0
];
for (var i = 0; i < 3; i++) {
t3 = h + 1 / 3 * -(i - 1);
t3 < 0 && t3++;
t3 > 1 && t3--;
if (6 * t3 < 1)
val = t1 + (t2 - t1) * 6 * t3;
else if (2 * t3 < 1)
val = t2;
else if (3 * t3 < 2)
val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
else
val = t1;
rgb[i] = val * 255;
}
return rgb;
}
function hsl2hsv(hsl) {
var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, sv, v;
if (l === 0) {
return [
0,
0,
0
];
}
l *= 2;
s *= l <= 1 ? l : 2 - l;
v = (l + s) / 2;
sv = 2 * s / (l + s);
return [
h,
sv * 100,
v * 100
];
}
function hsl2hwb(args) {
return rgb2hwb(hsl2rgb(args));
}
function hsl2cmyk(args) {
return rgb2cmyk(hsl2rgb(args));
}
function hsl2keyword(args) {
return rgb2keyword(hsl2rgb(args));
}
function hsv2rgb(hsv) {
var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6;
var f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f)), v = 255 * v;
switch (hi) {
case 0:
return [
v,
t,
p
];
case 1:
return [
q,
v,
p
];
case 2:
return [
p,
v,
t
];
case 3:
return [
p,
q,
v
];
case 4:
return [
t,
p,
v
];
case 5:
return [
v,
p,
q
];
}
}
function hsv2hsl(hsv) {
var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, sl, l;
l = (2 - s) * v;
sl = s * v;
sl /= l <= 1 ? l : 2 - l;
sl = sl || 0;
l /= 2;
return [
h,
sl * 100,
l * 100
];
}
function hsv2hwb(args) {
return rgb2hwb(hsv2rgb(args));
}
function hsv2cmyk(args) {
return rgb2cmyk(hsv2rgb(args));
}
function hsv2keyword(args) {
return rgb2keyword(hsv2rgb(args));
}
function hwb2rgb(hwb) {
var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, i, v, f, n;
if (ratio > 1) {
wh /= ratio;
bl /= ratio;
}
i = Math.floor(6 * h);
v = 1 - bl;
f = 6 * h - i;
if ((i & 1) != 0) {
f = 1 - f;
}
n = wh + f * (v - wh);
switch (i) {
default:
case 6:
case 0:
r = v;
g = n;
b = wh;
break;
case 1:
r = n;
g = v;
b = wh;
break;
case 2:
r = wh;
g = v;
b = n;
break;
case 3:
r = wh;
g = n;
b = v;
break;
case 4:
r = n;
g = wh;
b = v;
break;
case 5:
r = v;
g = wh;
b = n;
break;
}
return [
r * 255,
g * 255,
b * 255
];
}
function hwb2hsl(args) {
return rgb2hsl(hwb2rgb(args));
}
function hwb2hsv(args) {
return rgb2hsv(hwb2rgb(args));
}
function hwb2cmyk(args) {
return rgb2cmyk(hwb2rgb(args));
}
function hwb2keyword(args) {
return rgb2keyword(hwb2rgb(args));
}
function cmyk2rgb(cmyk) {
var c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r, g, b;
r = 1 - Math.min(1, c * (1 - k) + k);
g = 1 - Math.min(1, m * (1 - k) + k);
b = 1 - Math.min(1, y * (1 - k) + k);
return [
r * 255,
g * 255,
b * 255
];
}
function cmyk2hsl(args) {
return rgb2hsl(cmyk2rgb(args));
}
function cmyk2hsv(args) {
return rgb2hsv(cmyk2rgb(args));
}
function cmyk2hwb(args) {
return rgb2hwb(cmyk2rgb(args));
}
function cmyk2keyword(args) {
return rgb2keyword(cmyk2rgb(args));
}
function xyz2rgb(xyz) {
var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
r = x * 3.2406 + y * -1.5372 + z * -0.4986;
g = x * -0.9689 + y * 1.8758 + z * 0.0415;
b = x * 0.0557 + y * -0.204 + z * 1.057;
r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
r = Math.min(Math.max(0, r), 1);
g = Math.min(Math.max(0, g), 1);
b = Math.min(Math.max(0, b), 1);
return [
r * 255,
g * 255,
b * 255
];
}
function xyz2lab(xyz) {
var x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
x /= 95.047;
y /= 100;
z /= 108.883;
x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
l = 116 * y - 16;
a = 500 * (x - y);
b = 200 * (y - z);
return [
l,
a,
b
];
}
function xyz2lch(args) {
return lab2lch(xyz2lab(args));
}
function lab2xyz(lab) {
var l = lab[0], a = lab[1], b = lab[2], x, y, z, y2;
if (l <= 8) {
y = l * 100 / 903.3;
y2 = 7.787 * (y / 100) + 16 / 116;
} else {
y = 100 * Math.pow((l + 16) / 116, 3);
y2 = Math.pow(y / 100, 1 / 3);
}
x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
return [
x,
y,
z
];
}
function lab2lch(lab) {
var l = lab[0], a = lab[1], b = lab[2], hr, h, c;
hr = Math.atan2(b, a);
h = hr * 360 / 2 / Math.PI;
if (h < 0) {
h += 360;
}
c = Math.sqrt(a * a + b * b);
return [
l,
c,
h
];
}
function lab2rgb(args) {
return xyz2rgb(lab2xyz(args));
}
function lch2lab(lch) {
var l = lch[0], c = lch[1], h = lch[2], a, b, hr;
hr = h / 360 * 2 * Math.PI;
a = c * Math.cos(hr);
b = c * Math.sin(hr);
return [
l,
a,
b
];
}
function lch2xyz(args) {
return lab2xyz(lch2lab(args));
}
function lch2rgb(args) {
return lab2rgb(lch2lab(args));
}
function keyword2rgb(keyword) {
return cssKeywords[keyword];
}
function keyword2hsl(args) {
return rgb2hsl(keyword2rgb(args));
}
function keyword2hsv(args) {
return rgb2hsv(keyword2rgb(args));
}
function keyword2hwb(args) {
return rgb2hwb(keyword2rgb(args));
}
function keyword2cmyk(args) {
return rgb2cmyk(keyword2rgb(args));
}
function keyword2lab(args) {
return rgb2lab(keyword2rgb(args));
}
function keyword2xyz(args) {
return rgb2xyz(keyword2rgb(args));
}
var cssKeywords = {
aliceblue: [
240,
248,
255
],
antiquewhite: [
250,
235,
215
],
aqua: [
0,
255,
255
],
aquamarine: [
127,
255,
212
],
azure: [
240,
255,
255
],
beige: [
245,
245,
220
],
bisque: [
255,
228,
196
],
black: [
0,
0,
0
],
blanchedalmond: [
255,
235,
205
],
blue: [
0,
0,
255
],
blueviolet: [
138,
43,
226
],
brown: [
165,
42,
42
],
burlywood: [
222,
184,
135
],
cadetblue: [
95,
158,
160
],
chartreuse: [
127,
255,
0
],
chocolate: [
210,
105,
30
],
coral: [
255,
127,
80
],
cornflowerblue: [
100,
149,
237
],
cornsilk: [
255,
248,
220
],
crimson: [
220,
20,
60
],
cyan: [
0,
255,
255
],
darkblue: [
0,
0,
139
],
darkcyan: [
0,
139,
139
],
darkgoldenrod: [
184,
134,
11
],
darkgray: [
169,
169,
169
],
darkgreen: [
0,
100,
0
],
darkgrey: [
169,
169,
169
],
darkkhaki: [
189,
183,
107
],
darkmagenta: [
139,
0,
139
],
darkolivegreen: [
85,
107,
47
],
darkorange: [
255,
140,
0
],
darkorchid: [
153,
50,
204
],
darkred: [
139,
0,
0
],
darksalmon: [
233,
150,
122
],
darkseagreen: [
143,
188,
143
],
darkslateblue: [
72,
61,
139
],
darkslategray: [
47,
79,
79
],
darkslategrey: [
47,
79,
79
],
darkturquoise: [
0,
206,
209
],
darkviolet: [
148,
0,
211
],
deeppink: [
255,
20,
147
],
deepskyblue: [
0,
191,
255
],
dimgray: [
105,
105,
105
],
dimgrey: [
105,
105,
105
],
dodgerblue: [
30,
144,
255
],
firebrick: [
178,
34,
34
],
floralwhite: [
255,
250,
240
],
forestgreen: [
34,
139,
34
],
fuchsia: [
255,
0,
255
],
gainsboro: [
220,
220,
220
],
ghostwhite: [
248,
248,
255
],
gold: [
255,
215,
0
],
goldenrod: [
218,
165,
32
],
gray: [
128,
128,
128
],
green: [
0,
128,
0
],
greenyellow: [
173,
255,
47
],
grey: [
128,
128,
128
],
honeydew: [
240,
255,
240
],
hotpink: [
255,
105,
180
],
indianred: [
205,
92,
92
],
indigo: [
75,
0,
130
],
ivory: [
255,
255,
240
],
khaki: [
240,
230,
140
],
lavender: [
230,
230,
250
],
lavenderblush: [
255,
240,
245
],
lawngreen: [
124,
252,
0
],
lemonchiffon: [
255,
250,
205
],
lightblue: [
173,
216,
230
],
lightcoral: [
240,
128,
128
],
lightcyan: [
224,
255,
255
],
lightgoldenrodyellow: [
250,
250,
210
],
lightgray: [
211,
211,
211
],
lightgreen: [
144,
238,
144
],
lightgrey: [
211,
211,
211
],
lightpink: [
255,
182,
193
],
lightsalmon: [
255,
160,
122
],
lightseagreen: [
32,
178,
170
],
lightskyblue: [
135,
206,
250
],
lightslategray: [
119,
136,
153
],
lightslategrey: [
119,
136,
153
],
lightsteelblue: [
176,
196,
222
],
lightyellow: [
255,
255,
224
],
lime: [
0,
255,
0
],
limegreen: [
50,
205,
50
],
linen: [
250,
240,
230
],
magenta: [
255,
0,
255
],
maroon: [
128,
0,
0
],
mediumaquamarine: [
102,
205,
170
],
mediumblue: [
0,
0,
205
],
mediumorchid: [
186,
85,
211
],
mediumpurple: [
147,
112,
219
],
mediumseagreen: [
60,
179,
113
],
mediumslateblue: [
123,
104,
238
],
mediumspringgreen: [
0,
250,
154
],
mediumturquoise: [
72,
209,
204
],
mediumvioletred: [
199,
21,
133
],
midnightblue: [
25,
25,
112
],
mintcream: [
245,
255,
250
],
mistyrose: [
255,
228,
225
],
moccasin: [
255,
228,
181
],
navajowhite: [
255,
222,
173
],
navy: [
0,
0,
128
],
oldlace: [
253,
245,
230
],
olive: [
128,
128,
0
],
olivedrab: [
107,
142,
35
],
orange: [
255,
165,
0
],
orangered: [
255,
69,
0
],
orchid: [
218,
112,
214
],
palegoldenrod: [
238,
232,
170
],
palegreen: [
152,
251,
152
],
paleturquoise: [
175,
238,
238
],
palevioletred: [
219,
112,
147
],
papayawhip: [
255,
239,
213
],
peachpuff: [
255,
218,
185
],
peru: [
205,
133,
63
],
pink: [
255,
192,
203
],
plum: [
221,
160,
221
],
powderblue: [
176,
224,
230
],
purple: [
128,
0,
128
],
rebeccapurple: [
102,
51,
153
],
red: [
255,
0,
0
],
rosybrown: [
188,
143,
143
],
royalblue: [
65,
105,
225
],
saddlebrown: [
139,
69,
19
],
salmon: [
250,
128,
114
],
sandybrown: [
244,
164,
96
],
seagreen: [
46,
139,
87
],
seashell: [
255,
245,
238
],
sienna: [
160,
82,
45
],
silver: [
192,
192,
192
],
skyblue: [
135,
206,
235
],
slateblue: [
106,
90,
205
],
slategray: [
112,
128,
144
],
slategrey: [
112,
128,
144
],
snow: [
255,
250,
250
],
springgreen: [
0,
255,
127
],
steelblue: [
70,
130,
180
],
tan: [
210,
180,
140
],
teal: [
0,
128,
128
],
thistle: [
216,
191,
216
],
tomato: [
255,
99,
71
],
turquoise: [
64,
224,
208
],
violet: [
238,
130,
238
],
wheat: [
245,
222,
179
],
white: [
255,
255,
255
],
whitesmoke: [
245,
245,
245
],
yellow: [
255,
255,
0
],
yellowgreen: [
154,
205,
50
]
};
var reverseKeywords = {};
for (var key in cssKeywords) {
reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}
},
{}
],
5: [
function (require, module, exports) {
var conversions = require(4);
var convert = function () {
return new Converter();
};
for (var func in conversions) {
convert[func + 'Raw'] = function (func) {
return function (arg) {
if (typeof arg == 'number')
arg = Array.prototype.slice.call(arguments);
return conversions[func](arg);
};
}(func);
var pair = /(\w+)2(\w+)/.exec(func), from = pair[1], to = pair[2];
convert[from] = convert[from] || {};
convert[from][to] = convert[func] = function (func) {
return function (arg) {
if (typeof arg == 'number')
arg = Array.prototype.slice.call(arguments);
var val = conversions[func](arg);
if (typeof val == 'string' || val === undefined)
return val;
for (var i = 0; i < val.length; i++)
val[i] = Math.round(val[i]);
return val;
};
}(func);
}
var Converter = function () {
this.convs = {};
};
Converter.prototype.routeSpace = function (space, args) {
var values = args[0];
if (values === undefined) {
return this.getValues(space);
}
if (typeof values == 'number') {
values = Array.prototype.slice.call(args);
}
return this.setValues(space, values);
};
Converter.prototype.setValues = function (space, values) {
this.space = space;
this.convs = {};
this.convs[space] = values;
return this;
};
Converter.prototype.getValues = function (space) {
var vals = this.convs[space];
if (!vals) {
var fspace = this.space, from = this.convs[fspace];
vals = convert[fspace][space](from);
this.convs[space] = vals;
}
return vals;
};
[
'rgb',
'hsl',
'hsv',
'cmyk',
'keyword'
].forEach(function (space) {
Converter.prototype[space] = function (vals) {
return this.routeSpace(space, arguments);
};
});
module.exports = convert;
},
{ '4': 4 }
],
6: [
function (require, module, exports) {
'use strict';
module.exports = {
'aliceblue': [
240,
248,
255
],
'antiquewhite': [
250,
235,
215
],
'aqua': [
0,
255,
255
],
'aquamarine': [
127,
255,
212
],
'azure': [
240,
255,
255
],
'beige': [
245,
245,
220
],
'bisque': [
255,
228,
196
],
'black': [
0,
0,
0
],
'blanchedalmond': [
255,
235,
205
],
'blue': [
0,
0,
255
],
'blueviolet': [
138,
43,
226
],
'brown': [
165,
42,
42
],
'burlywood': [
222,
184,
135
],
'cadetblue': [
95,
158,
160
],
'chartreuse': [
127,
255,
0
],
'chocolate': [
210,
105,
30
],
'coral': [
255,
127,
80
],
'cornflowerblue': [
100,
149,
237
],
'cornsilk': [
255,
248,
220
],
'crimson': [
220,
20,
60
],
'cyan': [
0,
255,
255
],
'darkblue': [
0,
0,
139
],
'darkcyan': [
0,
139,
139
],
'darkgoldenrod': [
184,
134,
11
],
'darkgray': [
169,
169,
169
],
'darkgreen': [
0,
100,
0
],
'darkgrey': [
169,
169,
169
],
'darkkhaki': [
189,
183,
107
],
'darkmagenta': [
139,
0,
139
],
'darkolivegreen': [
85,
107,
47
],
'darkorange': [
255,
140,
0
],
'darkorchid': [
153,
50,
204
],
'darkred': [
139,
0,
0
],
'darksalmon': [
233,
150,
122
],
'darkseagreen': [
143,
188,
143
],
'darkslateblue': [
72,
61,
139
],
'darkslategray': [
47,
79,
79
],
'darkslategrey': [
47,
79,
79
],
'darkturquoise': [
0,
206,
209
],
'darkviolet': [
148,
0,
211
],
'deeppink': [
255,
20,
147
],
'deepskyblue': [
0,
191,
255
],
'dimgray': [
105,
105,
105
],
'dimgrey': [
105,
105,
105
],
'dodgerblue': [
30,
144,
255
],
'firebrick': [
178,
34,
34
],
'floralwhite': [
255,
250,
240
],
'forestgreen': [
34,
139,
34
],
'fuchsia': [
255,
0,
255
],
'gainsboro': [
220,
220,
220
],
'ghostwhite': [
248,
248,
255
],
'gold': [
255,
215,
0
],
'goldenrod': [
218,
165,
32
],
'gray': [
128,
128,
128
],
'green': [
0,
128,
0
],
'greenyellow': [
173,
255,
47
],
'grey': [
128,
128,
128
],
'honeydew': [
240,
255,
240
],
'hotpink': [
255,
105,
180
],
'indianred': [
205,
92,
92
],
'indigo': [
75,
0,
130
],
'ivory': [
255,
255,
240
],
'khaki': [
240,
230,
140
],
'lavender': [
230,
230,
250
],
'lavenderblush': [
255,
240,
245
],
'lawngreen': [
124,
252,
0
],
'lemonchiffon': [
255,
250,
205
],
'lightblue': [
173,
216,
230
],
'lightcoral': [
240,
128,
128
],
'lightcyan': [
224,
255,
255
],
'lightgoldenrodyellow': [
250,
250,
210
],
'lightgray': [
211,
211,
211
],
'lightgreen': [
144,
238,
144
],
'lightgrey': [
211,
211,
211
],
'lightpink': [
255,
182,
193
],
'lightsalmon': [
255,
160,
122
],
'lightseagreen': [
32,
178,
170
],
'lightskyblue': [
135,
206,
250
],
'lightslategray': [
119,
136,
153
],
'lightslategrey': [
119,
136,
153
],
'lightsteelblue': [
176,
196,
222
],
'lightyellow': [
255,
255,
224
],
'lime': [
0,
255,
0
],
'limegreen': [
50,
205,
50
],
'linen': [
250,
240,
230
],
'magenta': [
255,
0,
255
],
'maroon': [
128,
0,
0
],
'mediumaquamarine': [
102,
205,
170
],
'mediumblue': [
0,
0,
205
],
'mediumorchid': [
186,
85,
211
],
'mediumpurple': [
147,
112,
219
],
'mediumseagreen': [
60,
179,
113
],
'mediumslateblue': [
123,
104,
238
],
'mediumspringgreen': [
0,
250,
154
],
'mediumturquoise': [
72,
209,
204
],
'mediumvioletred': [
199,
21,
133
],
'midnightblue': [
25,
25,
112
],
'mintcream': [
245,
255,
250
],
'mistyrose': [
255,
228,
225
],
'moccasin': [
255,
228,
181
],
'navajowhite': [
255,
222,
173
],
'navy': [
0,
0,
128
],
'oldlace': [
253,
245,
230
],
'olive': [
128,
128,
0
],
'olivedrab': [
107,
142,
35
],
'orange': [
255,
165,
0
],
'orangered': [
255,
69,
0
],
'orchid': [
218,
112,
214
],
'palegoldenrod': [
238,
232,
170
],
'palegreen': [
152,
251,
152
],
'paleturquoise': [
175,
238,
238
],
'palevioletred': [
219,
112,
147
],
'papayawhip': [
255,
239,
213
],
'peachpuff': [
255,
218,
185
],
'peru': [
205,
133,
63
],
'pink': [
255,
192,
203
],
'plum': [
221,
160,
221
],
'powderblue': [
176,
224,
230
],
'purple': [
128,
0,
128
],
'rebeccapurple': [
102,
51,
153
],
'red': [
255,
0,
0
],
'rosybrown': [
188,
143,
143
],
'royalblue': [
65,
105,
225
],
'saddlebrown': [
139,
69,
19
],
'salmon': [
250,
128,
114
],
'sandybrown': [
244,
164,
96
],
'seagreen': [
46,
139,
87
],
'seashell': [
255,
245,
238
],
'sienna': [
160,
82,
45
],
'silver': [
192,
192,
192
],
'skyblue': [
135,
206,
235
],
'slateblue': [
106,
90,
205
],
'slategray': [
112,
128,
144
],
'slategrey': [
112,
128,
144
],
'snow': [
255,
250,
250
],
'springgreen': [
0,
255,
127
],
'steelblue': [
70,
130,
180
],
'tan': [
210,
180,
140
],
'teal': [
0,
128,
128
],
'thistle': [
216,
191,
216
],
'tomato': [
255,
99,
71
],
'turquoise': [
64,
224,
208
],
'violet': [
238,
130,
238
],
'wheat': [
245,
222,
179
],
'white': [
255,
255,
255
],
'whitesmoke': [
245,
245,
245
],
'yellow': [
255,
255,
0
],
'yellowgreen': [
154,
205,
50
]
};
},
{}
],
7: [
function (require, module, exports) {
var Chart = require(29)();
Chart.helpers = require(45);
require(27)(Chart);
Chart.defaults = require(25);
Chart.Element = require(26);
Chart.elements = require(40);
Chart.Interaction = require(28);
Chart.platform = require(48);
require(31)(Chart);
require(22)(Chart);
require(23)(Chart);
require(24)(Chart);
require(30)(Chart);
require(33)(Chart);
require(32)(Chart);
require(35)(Chart);
require(54)(Chart);
require(52)(Chart);
require(53)(Chart);
require(55)(Chart);
require(56)(Chart);
require(57)(Chart);
require(15)(Chart);
require(16)(Chart);
require(17)(Chart);
require(18)(Chart);
require(19)(Chart);
require(20)(Chart);
require(21)(Chart);
require(8)(Chart);
require(9)(Chart);
require(10)(Chart);
require(11)(Chart);
require(12)(Chart);
require(13)(Chart);
require(14)(Chart);
var plugins = [];
plugins.push(require(49)(Chart), require(50)(Chart), require(51)(Chart));
Chart.plugins.register(plugins);
Chart.platform.initialize();
module.exports = Chart;
if (typeof window !== 'undefined') {
window.Chart = Chart;
}
Chart.canvasHelpers = Chart.helpers.canvas;
},
{
'10': 10,
'11': 11,
'12': 12,
'13': 13,
'14': 14,
'15': 15,
'16': 16,
'17': 17,
'18': 18,
'19': 19,
'20': 20,
'21': 21,
'22': 22,
'23': 23,
'24': 24,
'25': 25,
'26': 26,
'27': 27,
'28': 28,
'29': 29,
'30': 30,
'31': 31,
'32': 32,
'33': 33,
'35': 35,
'40': 40,
'45': 45,
'48': 48,
'49': 49,
'50': 50,
'51': 51,
'52': 52,
'53': 53,
'54': 54,
'55': 55,
'56': 56,
'57': 57,
'8': 8,
'9': 9
}
],
8: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Bar = function (context, config) {
config.type = 'bar';
return new Chart(context, config);
};
};
},
{}
],
9: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Bubble = function (context, config) {
config.type = 'bubble';
return new Chart(context, config);
};
};
},
{}
],
10: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Doughnut = function (context, config) {
config.type = 'doughnut';
return new Chart(context, config);
};
};
},
{}
],
11: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Line = function (context, config) {
config.type = 'line';
return new Chart(context, config);
};
};
},
{}
],
12: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.PolarArea = function (context, config) {
config.type = 'polarArea';
return new Chart(context, config);
};
};
},
{}
],
13: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Radar = function (context, config) {
config.type = 'radar';
return new Chart(context, config);
};
};
},
{}
],
14: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
Chart.Scatter = function (context, config) {
config.type = 'scatter';
return new Chart(context, config);
};
};
},
{}
],
15: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('bar', {
hover: { mode: 'label' },
scales: {
xAxes: [{
type: 'category',
categoryPercentage: 0.8,
barPercentage: 0.9,
offset: true,
gridLines: { offsetGridLines: true }
}],
yAxes: [{ type: 'linear' }]
}
});
defaults._set('horizontalBar', {
hover: {
mode: 'index',
axis: 'y'
},
scales: {
xAxes: [{
type: 'linear',
position: 'bottom'
}],
yAxes: [{
position: 'left',
type: 'category',
categoryPercentage: 0.8,
barPercentage: 0.9,
offset: true,
gridLines: { offsetGridLines: true }
}]
},
elements: { rectangle: { borderSkipped: 'left' } },
tooltips: {
callbacks: {
title: function (item, data) {
var title = '';
if (item.length > 0) {
if (item[0].yLabel) {
title = item[0].yLabel;
} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
title = data.labels[item[0].index];
}
}
return title;
},
label: function (item, data) {
var datasetLabel = data.datasets[item.datasetIndex].label || '';
return datasetLabel + ': ' + item.xLabel;
}
},
mode: 'index',
axis: 'y'
}
});
module.exports = function (Chart) {
Chart.controllers.bar = Chart.DatasetController.extend({
dataElementType: elements.Rectangle,
initialize: function () {
var me = this;
var meta;
Chart.DatasetController.prototype.initialize.apply(me, arguments);
meta = me.getMeta();
meta.stack = me.getDataset().stack;
meta.bar = true;
},
update: function (reset) {
var me = this;
var rects = me.getMeta().data;
var i, ilen;
me._ruler = me.getRuler();
for (i = 0, ilen = rects.length; i < ilen; ++i) {
me.updateElement(rects[i], i, reset);
}
},
updateElement: function (rectangle, index, reset) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var dataset = me.getDataset();
var custom = rectangle.custom || {};
var rectangleOptions = chart.options.elements.rectangle;
rectangle._xScale = me.getScaleForId(meta.xAxisID);
rectangle._yScale = me.getScaleForId(meta.yAxisID);
rectangle._datasetIndex = me.index;
rectangle._index = index;
rectangle._model = {
datasetLabel: dataset.label,
label: chart.data.labels[index],
borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
};
me.updateElementGeometry(rectangle, index, reset);
rectangle.pivot();
},
updateElementGeometry: function (rectangle, index, reset) {
var me = this;
var model = rectangle._model;
var vscale = me.getValueScale();
var base = vscale.getBasePixel();
var horizontal = vscale.isHorizontal();
var ruler = me._ruler || me.getRuler();
var vpixels = me.calculateBarValuePixels(me.index, index);
var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
model.horizontal = horizontal;
model.base = reset ? base : vpixels.base;
model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
model.height = horizontal ? ipixels.size : undefined;
model.width = horizontal ? undefined : ipixels.size;
},
getValueScaleId: function () {
return this.getMeta().yAxisID;
},
getIndexScaleId: function () {
return this.getMeta().xAxisID;
},
getValueScale: function () {
return this.getScaleForId(this.getValueScaleId());
},
getIndexScale: function () {
return this.getScaleForId(this.getIndexScaleId());
},
getStackCount: function (last) {
var me = this;
var chart = me.chart;
var scale = me.getIndexScale();
var stacked = scale.options.stacked;
var ilen = last === undefined ? chart.data.datasets.length : last + 1;
var stacks = [];
var i, meta;
for (i = 0; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
stacks.push(meta.stack);
}
}
return stacks.length;
},
getStackIndex: function (datasetIndex) {
return this.getStackCount(datasetIndex) - 1;
},
getRuler: function () {
var me = this;
var scale = me.getIndexScale();
var stackCount = me.getStackCount();
var datasetIndex = me.index;
var pixels = [];
var isHorizontal = scale.isHorizontal();
var start = isHorizontal ? scale.left : scale.top;
var end = start + (isHorizontal ? scale.width : scale.height);
var i, ilen;
for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
pixels.push(scale.getPixelForValue(null, i, datasetIndex));
}
return {
pixels: pixels,
start: start,
end: end,
stackCount: stackCount,
scale: scale
};
},
calculateBarValuePixels: function (datasetIndex, index) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var scale = me.getValueScale();
var datasets = chart.data.datasets;
var value = scale.getRightValue(datasets[datasetIndex].data[index]);
var stacked = scale.options.stacked;
var stack = meta.stack;
var start = 0;
var i, imeta, ivalue, base, head, size;
if (stacked || stacked === undefined && stack !== undefined) {
for (i = 0; i < datasetIndex; ++i) {
imeta = chart.getDatasetMeta(i);
if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
ivalue = scale.getRightValue(datasets[i].data[index]);
if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
start += ivalue;
}
}
}
}
base = scale.getPixelForValue(start);
head = scale.getPixelForValue(start + value);
size = (head - base) / 2;
return {
size: size,
base: base,
head: head,
center: head + size / 2
};
},
calculateBarIndexPixels: function (datasetIndex, index, ruler) {
var me = this;
var options = ruler.scale.options;
var stackIndex = me.getStackIndex(datasetIndex);
var pixels = ruler.pixels;
var base = pixels[index];
var length = pixels.length;
var start = ruler.start;
var end = ruler.end;
var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;
if (length === 1) {
leftSampleSize = base > start ? base - start : end - base;
rightSampleSize = base < end ? end - base : base - start;
} else {
if (index > 0) {
leftSampleSize = (base - pixels[index - 1]) / 2;
if (index === length - 1) {
rightSampleSize = leftSampleSize;
}
}
if (index < length - 1) {
rightSampleSize = (pixels[index + 1] - base) / 2;
if (index === 0) {
leftSampleSize = rightSampleSize;
}
}
}
leftCategorySize = leftSampleSize * options.categoryPercentage;
rightCategorySize = rightSampleSize * options.categoryPercentage;
fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
size = fullBarSize * options.barPercentage;
size = Math.min(helpers.valueOrDefault(options.barThickness, size), helpers.valueOrDefault(options.maxBarThickness, Infinity));
base -= leftCategorySize;
base += fullBarSize * stackIndex;
base += (fullBarSize - size) / 2;
return {
size: size,
base: base,
head: base + size,
center: base + size / 2
};
},
draw: function () {
var me = this;
var chart = me.chart;
var scale = me.getValueScale();
var rects = me.getMeta().data;
var dataset = me.getDataset();
var ilen = rects.length;
var i = 0;
helpers.canvas.clipArea(chart.ctx, chart.chartArea);
for (; i < ilen; ++i) {
if (!isNaN(scale.getRightValue(dataset.data[i]))) {
rects[i].draw();
}
}
helpers.canvas.unclipArea(chart.ctx);
},
setHoverStyle: function (rectangle) {
var dataset = this.chart.data.datasets[rectangle._datasetIndex];
var index = rectangle._index;
var custom = rectangle.custom || {};
var model = rectangle._model;
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function (rectangle) {
var dataset = this.chart.data.datasets[rectangle._datasetIndex];
var index = rectangle._index;
var custom = rectangle.custom || {};
var model = rectangle._model;
var rectangleElementOptions = this.chart.options.elements.rectangle;
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
}
});
Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
getValueScaleId: function () {
return this.getMeta().xAxisID;
},
getIndexScaleId: function () {
return this.getMeta().yAxisID;
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
16: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('bubble', {
hover: { mode: 'single' },
scales: {
xAxes: [{
type: 'linear',
position: 'bottom',
id: 'x-axis-0'
}],
yAxes: [{
type: 'linear',
position: 'left',
id: 'y-axis-0'
}]
},
tooltips: {
callbacks: {
title: function () {
return '';
},
label: function (item, data) {
var datasetLabel = data.datasets[item.datasetIndex].label || '';
var dataPoint = data.datasets[item.datasetIndex].data[item.index];
return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
}
}
}
});
module.exports = function (Chart) {
Chart.controllers.bubble = Chart.DatasetController.extend({
dataElementType: elements.Point,
update: function (reset) {
var me = this;
var meta = me.getMeta();
var points = meta.data;
helpers.each(points, function (point, index) {
me.updateElement(point, index, reset);
});
},
updateElement: function (point, index, reset) {
var me = this;
var meta = me.getMeta();
var custom = point.custom || {};
var xScale = me.getScaleForId(meta.xAxisID);
var yScale = me.getScaleForId(meta.yAxisID);
var options = me._resolveElementOptions(point, index);
var data = me.getDataset().data[index];
var dsIndex = me.index;
var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
point._xScale = xScale;
point._yScale = yScale;
point._options = options;
point._datasetIndex = dsIndex;
point._index = index;
point._model = {
backgroundColor: options.backgroundColor,
borderColor: options.borderColor,
borderWidth: options.borderWidth,
hitRadius: options.hitRadius,
pointStyle: options.pointStyle,
radius: reset ? 0 : options.radius,
skip: custom.skip || isNaN(x) || isNaN(y),
x: x,
y: y
};
point.pivot();
},
setHoverStyle: function (point) {
var model = point._model;
var options = point._options;
model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
model.radius = options.radius + options.hoverRadius;
},
removeHoverStyle: function (point) {
var model = point._model;
var options = point._options;
model.backgroundColor = options.backgroundColor;
model.borderColor = options.borderColor;
model.borderWidth = options.borderWidth;
model.radius = options.radius;
},
_resolveElementOptions: function (point, index) {
var me = this;
var chart = me.chart;
var datasets = chart.data.datasets;
var dataset = datasets[me.index];
var custom = point.custom || {};
var options = chart.options.elements.point;
var resolve = helpers.options.resolve;
var data = dataset.data[index];
var values = {};
var i, ilen, key;
var context = {
chart: chart,
dataIndex: index,
dataset: dataset,
datasetIndex: me.index
};
var keys = [
'backgroundColor',
'borderColor',
'borderWidth',
'hoverBackgroundColor',
'hoverBorderColor',
'hoverBorderWidth',
'hoverRadius',
'hitRadius',
'pointStyle'
];
for (i = 0, ilen = keys.length; i < ilen; ++i) {
key = keys[i];
values[key] = resolve([
custom[key],
dataset[key],
options[key]
], context, index);
}
values.radius = resolve([
custom.radius,
data ? data.r : undefined,
dataset.radius,
options.radius
], context, index);
return values;
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
17: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('doughnut', {
animation: {
animateRotate: true,
animateScale: false
},
hover: { mode: 'single' },
legendCallback: function (chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
var data = chart.data;
var datasets = data.datasets;
var labels = data.labels;
if (datasets.length) {
for (var i = 0; i < datasets[0].data.length; ++i) {
text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
if (labels[i]) {
text.push(labels[i]);
}
text.push('</li>');
}
}
text.push('</ul>');
return text.join('');
},
legend: {
labels: {
generateLabels: function (chart) {
var data = chart.data;
if (data.labels.length && data.datasets.length) {
return data.labels.map(function (label, i) {
var meta = chart.getDatasetMeta(0);
var ds = data.datasets[0];
var arc = meta.data[i];
var custom = arc && arc.custom || {};
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
var arcOpts = chart.options.elements.arc;
var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
return {
text: label,
fillStyle: fill,
strokeStyle: stroke,
lineWidth: bw,
hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
index: i
};
});
}
return [];
}
},
onClick: function (e, legendItem) {
var index = legendItem.index;
var chart = this.chart;
var i, ilen, meta;
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
if (meta.data[index]) {
meta.data[index].hidden = !meta.data[index].hidden;
}
}
chart.update();
}
},
cutoutPercentage: 50,
rotation: Math.PI * -0.5,
circumference: Math.PI * 2,
tooltips: {
callbacks: {
title: function () {
return '';
},
label: function (tooltipItem, data) {
var dataLabel = data.labels[tooltipItem.index];
var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
if (helpers.isArray(dataLabel)) {
dataLabel = dataLabel.slice();
dataLabel[0] += value;
} else {
dataLabel += value;
}
return dataLabel;
}
}
}
});
defaults._set('pie', helpers.clone(defaults.doughnut));
defaults._set('pie', { cutoutPercentage: 0 });
module.exports = function (Chart) {
Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
dataElementType: elements.Arc,
linkScales: helpers.noop,
getRingIndex: function (datasetIndex) {
var ringIndex = 0;
for (var j = 0; j < datasetIndex; ++j) {
if (this.chart.isDatasetVisible(j)) {
++ringIndex;
}
}
return ringIndex;
},
update: function (reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var opts = chart.options;
var arcOpts = opts.elements.arc;
var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
var minSize = Math.min(availableWidth, availableHeight);
var offset = {
x: 0,
y: 0
};
var meta = me.getMeta();
var cutoutPercentage = opts.cutoutPercentage;
var circumference = opts.circumference;
if (circumference < Math.PI * 2) {
var startAngle = opts.rotation % (Math.PI * 2);
startAngle += Math.PI * 2 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
var endAngle = startAngle + circumference;
var start = {
x: Math.cos(startAngle),
y: Math.sin(startAngle)
};
var end = {
x: Math.cos(endAngle),
y: Math.sin(endAngle)
};
var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2 && Math.PI * 2 <= endAngle;
var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
var cutout = cutoutPercentage / 100;
var min = {
x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
};
var max = {
x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
};
var size = {
width: (max.x - min.x) * 0.5,
height: (max.y - min.y) * 0.5
};
minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
offset = {
x: (max.x + min.x) * -0.5,
y: (max.y + min.y) * -0.5
};
}
chart.borderWidth = me.getMaxBorderWidth(meta.data);
chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
chart.offsetX = offset.x * chart.outerRadius;
chart.offsetY = offset.y * chart.outerRadius;
meta.total = me.calculateTotal();
me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
helpers.each(meta.data, function (arc, index) {
me.updateElement(arc, index, reset);
});
},
updateElement: function (arc, index, reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var opts = chart.options;
var animationOpts = opts.animation;
var centerX = (chartArea.left + chartArea.right) / 2;
var centerY = (chartArea.top + chartArea.bottom) / 2;
var startAngle = opts.rotation;
var endAngle = opts.rotation;
var dataset = me.getDataset();
var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2 * Math.PI));
var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
helpers.extend(arc, {
_datasetIndex: me.index,
_index: index,
_model: {
x: centerX + chart.offsetX,
y: centerY + chart.offsetY,
startAngle: startAngle,
endAngle: endAngle,
circumference: circumference,
outerRadius: outerRadius,
innerRadius: innerRadius,
label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
}
});
var model = arc._model;
this.removeHoverStyle(arc);
if (!reset || !animationOpts.animateRotate) {
if (index === 0) {
model.startAngle = opts.rotation;
} else {
model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
}
model.endAngle = model.startAngle + model.circumference;
}
arc.pivot();
},
removeHoverStyle: function (arc) {
Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
},
calculateTotal: function () {
var dataset = this.getDataset();
var meta = this.getMeta();
var total = 0;
var value;
helpers.each(meta.data, function (element, index) {
value = dataset.data[index];
if (!isNaN(value) && !element.hidden) {
total += Math.abs(value);
}
});
return total;
},
calculateCircumference: function (value) {
var total = this.getMeta().total;
if (total > 0 && !isNaN(value)) {
return Math.PI * 2 * (value / total);
}
return 0;
},
getMaxBorderWidth: function (arcs) {
var max = 0;
var index = this.index;
var length = arcs.length;
var borderWidth;
var hoverWidth;
for (var i = 0; i < length; i++) {
borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
max = borderWidth > max ? borderWidth : max;
max = hoverWidth > max ? hoverWidth : max;
}
return max;
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
18: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('line', {
showLines: true,
spanGaps: false,
hover: { mode: 'label' },
scales: {
xAxes: [{
type: 'category',
id: 'x-axis-0'
}],
yAxes: [{
type: 'linear',
id: 'y-axis-0'
}]
}
});
module.exports = function (Chart) {
function lineEnabled(dataset, options) {
return helpers.valueOrDefault(dataset.showLine, options.showLines);
}
Chart.controllers.line = Chart.DatasetController.extend({
datasetElementType: elements.Line,
dataElementType: elements.Point,
update: function (reset) {
var me = this;
var meta = me.getMeta();
var line = meta.dataset;
var points = meta.data || [];
var options = me.chart.options;
var lineElementOptions = options.elements.line;
var scale = me.getScaleForId(meta.yAxisID);
var i, ilen, custom;
var dataset = me.getDataset();
var showLine = lineEnabled(dataset, options);
if (showLine) {
custom = line.custom || {};
if (dataset.tension !== undefined && dataset.lineTension === undefined) {
dataset.lineTension = dataset.tension;
}
line._scale = scale;
line._datasetIndex = me.index;
line._children = points;
line._model = {
spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
};
line.pivot();
}
for (i = 0, ilen = points.length; i < ilen; ++i) {
me.updateElement(points[i], i, reset);
}
if (showLine && line._model.tension !== 0) {
me.updateBezierControlPoints();
}
for (i = 0, ilen = points.length; i < ilen; ++i) {
points[i].pivot();
}
},
getPointBackgroundColor: function (point, index) {
var backgroundColor = this.chart.options.elements.point.backgroundColor;
var dataset = this.getDataset();
var custom = point.custom || {};
if (custom.backgroundColor) {
backgroundColor = custom.backgroundColor;
} else if (dataset.pointBackgroundColor) {
backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
} else if (dataset.backgroundColor) {
backgroundColor = dataset.backgroundColor;
}
return backgroundColor;
},
getPointBorderColor: function (point, index) {
var borderColor = this.chart.options.elements.point.borderColor;
var dataset = this.getDataset();
var custom = point.custom || {};
if (custom.borderColor) {
borderColor = custom.borderColor;
} else if (dataset.pointBorderColor) {
borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
} else if (dataset.borderColor) {
borderColor = dataset.borderColor;
}
return borderColor;
},
getPointBorderWidth: function (point, index) {
var borderWidth = this.chart.options.elements.point.borderWidth;
var dataset = this.getDataset();
var custom = point.custom || {};
if (!isNaN(custom.borderWidth)) {
borderWidth = custom.borderWidth;
} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
} else if (!isNaN(dataset.borderWidth)) {
borderWidth = dataset.borderWidth;
}
return borderWidth;
},
updateElement: function (point, index, reset) {
var me = this;
var meta = me.getMeta();
var custom = point.custom || {};
var dataset = me.getDataset();
var datasetIndex = me.index;
var value = dataset.data[index];
var yScale = me.getScaleForId(meta.yAxisID);
var xScale = me.getScaleForId(meta.xAxisID);
var pointOptions = me.chart.options.elements.point;
var x, y;
if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
dataset.pointRadius = dataset.radius;
}
if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
dataset.pointHitRadius = dataset.hitRadius;
}
x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
point._xScale = xScale;
point._yScale = yScale;
point._datasetIndex = datasetIndex;
point._index = index;
point._model = {
x: x,
y: y,
skip: custom.skip || isNaN(x) || isNaN(y),
radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
backgroundColor: me.getPointBackgroundColor(point, index),
borderColor: me.getPointBorderColor(point, index),
borderWidth: me.getPointBorderWidth(point, index),
tension: meta.dataset._model ? meta.dataset._model.tension : 0,
steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
};
},
calculatePointY: function (value, index, datasetIndex) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var yScale = me.getScaleForId(meta.yAxisID);
var sumPos = 0;
var sumNeg = 0;
var i, ds, dsMeta;
if (yScale.options.stacked) {
for (i = 0; i < datasetIndex; i++) {
ds = chart.data.datasets[i];
dsMeta = chart.getDatasetMeta(i);
if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
if (stackedRightValue < 0) {
sumNeg += stackedRightValue || 0;
} else {
sumPos += stackedRightValue || 0;
}
}
}
var rightValue = Number(yScale.getRightValue(value));
if (rightValue < 0) {
return yScale.getPixelForValue(sumNeg + rightValue);
}
return yScale.getPixelForValue(sumPos + rightValue);
}
return yScale.getPixelForValue(value);
},
updateBezierControlPoints: function () {
var me = this;
var meta = me.getMeta();
var area = me.chart.chartArea;
var points = meta.data || [];
var i, ilen, point, model, controlPoints;
if (meta.dataset._model.spanGaps) {
points = points.filter(function (pt) {
return !pt._model.skip;
});
}
function capControlPoint(pt, min, max) {
return Math.max(Math.min(pt, max), min);
}
if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
helpers.splineCurveMonotone(points);
} else {
for (i = 0, ilen = points.length; i < ilen; ++i) {
point = points[i];
model = point._model;
controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
model.controlPointPreviousX = controlPoints.previous.x;
model.controlPointPreviousY = controlPoints.previous.y;
model.controlPointNextX = controlPoints.next.x;
model.controlPointNextY = controlPoints.next.y;
}
}
if (me.chart.options.elements.line.capBezierPoints) {
for (i = 0, ilen = points.length; i < ilen; ++i) {
model = points[i]._model;
model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
}
}
},
draw: function () {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var points = meta.data || [];
var area = chart.chartArea;
var ilen = points.length;
var i = 0;
helpers.canvas.clipArea(chart.ctx, area);
if (lineEnabled(me.getDataset(), chart.options)) {
meta.dataset.draw();
}
helpers.canvas.unclipArea(chart.ctx);
for (; i < ilen; ++i) {
points[i].draw(area);
}
},
setHoverStyle: function (point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var index = point._index;
var custom = point.custom || {};
var model = point._model;
model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function (point) {
var me = this;
var dataset = me.chart.data.datasets[point._datasetIndex];
var index = point._index;
var custom = point.custom || {};
var model = point._model;
if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
dataset.pointRadius = dataset.radius;
}
model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
model.backgroundColor = me.getPointBackgroundColor(point, index);
model.borderColor = me.getPointBorderColor(point, index);
model.borderWidth = me.getPointBorderWidth(point, index);
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
19: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('polarArea', {
scale: {
type: 'radialLinear',
angleLines: { display: false },
gridLines: { circular: true },
pointLabels: { display: false },
ticks: { beginAtZero: true }
},
animation: {
animateRotate: true,
animateScale: true
},
startAngle: -0.5 * Math.PI,
legendCallback: function (chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
var data = chart.data;
var datasets = data.datasets;
var labels = data.labels;
if (datasets.length) {
for (var i = 0; i < datasets[0].data.length; ++i) {
text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
if (labels[i]) {
text.push(labels[i]);
}
text.push('</li>');
}
}
text.push('</ul>');
return text.join('');
},
legend: {
labels: {
generateLabels: function (chart) {
var data = chart.data;
if (data.labels.length && data.datasets.length) {
return data.labels.map(function (label, i) {
var meta = chart.getDatasetMeta(0);
var ds = data.datasets[0];
var arc = meta.data[i];
var custom = arc.custom || {};
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
var arcOpts = chart.options.elements.arc;
var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
return {
text: label,
fillStyle: fill,
strokeStyle: stroke,
lineWidth: bw,
hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
index: i
};
});
}
return [];
}
},
onClick: function (e, legendItem) {
var index = legendItem.index;
var chart = this.chart;
var i, ilen, meta;
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
meta.data[index].hidden = !meta.data[index].hidden;
}
chart.update();
}
},
tooltips: {
callbacks: {
title: function () {
return '';
},
label: function (item, data) {
return data.labels[item.index] + ': ' + item.yLabel;
}
}
}
});
module.exports = function (Chart) {
Chart.controllers.polarArea = Chart.DatasetController.extend({
dataElementType: elements.Arc,
linkScales: helpers.noop,
update: function (reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var meta = me.getMeta();
var opts = chart.options;
var arcOpts = opts.elements.arc;
var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
me.innerRadius = me.outerRadius - chart.radiusLength;
meta.count = me.countVisibleElements();
helpers.each(meta.data, function (arc, index) {
me.updateElement(arc, index, reset);
});
},
updateElement: function (arc, index, reset) {
var me = this;
var chart = me.chart;
var dataset = me.getDataset();
var opts = chart.options;
var animationOpts = opts.animation;
var scale = chart.scale;
var labels = chart.data.labels;
var circumference = me.calculateCircumference(dataset.data[index]);
var centerX = scale.xCenter;
var centerY = scale.yCenter;
var visibleCount = 0;
var meta = me.getMeta();
for (var i = 0; i < index; ++i) {
if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
++visibleCount;
}
}
var datasetStartAngle = opts.startAngle;
var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
var startAngle = datasetStartAngle + circumference * visibleCount;
var endAngle = startAngle + (arc.hidden ? 0 : circumference);
var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
helpers.extend(arc, {
_datasetIndex: me.index,
_index: index,
_scale: scale,
_model: {
x: centerX,
y: centerY,
innerRadius: 0,
outerRadius: reset ? resetRadius : distance,
startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
}
});
me.removeHoverStyle(arc);
arc.pivot();
},
removeHoverStyle: function (arc) {
Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
},
countVisibleElements: function () {
var dataset = this.getDataset();
var meta = this.getMeta();
var count = 0;
helpers.each(meta.data, function (element, index) {
if (!isNaN(dataset.data[index]) && !element.hidden) {
count++;
}
});
return count;
},
calculateCircumference: function (value) {
var count = this.getMeta().count;
if (count > 0 && !isNaN(value)) {
return 2 * Math.PI / count;
}
return 0;
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
20: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('radar', {
scale: { type: 'radialLinear' },
elements: { line: { tension: 0 } }
});
module.exports = function (Chart) {
Chart.controllers.radar = Chart.DatasetController.extend({
datasetElementType: elements.Line,
dataElementType: elements.Point,
linkScales: helpers.noop,
update: function (reset) {
var me = this;
var meta = me.getMeta();
var line = meta.dataset;
var points = meta.data;
var custom = line.custom || {};
var dataset = me.getDataset();
var lineElementOptions = me.chart.options.elements.line;
var scale = me.chart.scale;
if (dataset.tension !== undefined && dataset.lineTension === undefined) {
dataset.lineTension = dataset.tension;
}
helpers.extend(meta.dataset, {
_datasetIndex: me.index,
_scale: scale,
_children: points,
_loop: true,
_model: {
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
}
});
meta.dataset.pivot();
helpers.each(points, function (point, index) {
me.updateElement(point, index, reset);
}, me);
me.updateBezierControlPoints();
},
updateElement: function (point, index, reset) {
var me = this;
var custom = point.custom || {};
var dataset = me.getDataset();
var scale = me.chart.scale;
var pointElementOptions = me.chart.options.elements.point;
var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
dataset.pointRadius = dataset.radius;
}
if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
dataset.pointHitRadius = dataset.hitRadius;
}
helpers.extend(point, {
_datasetIndex: me.index,
_index: index,
_scale: scale,
_model: {
x: reset ? scale.xCenter : pointPosition.x,
y: reset ? scale.yCenter : pointPosition.y,
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
}
});
point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
},
updateBezierControlPoints: function () {
var chartArea = this.chart.chartArea;
var meta = this.getMeta();
helpers.each(meta.data, function (point, index) {
var model = point._model;
var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);
model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
point.pivot();
});
},
setHoverStyle: function (point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var custom = point.custom || {};
var index = point._index;
var model = point._model;
model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function (point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var custom = point.custom || {};
var index = point._index;
var model = point._model;
var pointElementOptions = this.chart.options.elements.point;
model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
}
});
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
21: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
defaults._set('scatter', {
hover: { mode: 'single' },
scales: {
xAxes: [{
id: 'x-axis-1',
type: 'linear',
position: 'bottom'
}],
yAxes: [{
id: 'y-axis-1',
type: 'linear',
position: 'left'
}]
},
showLines: false,
tooltips: {
callbacks: {
title: function () {
return '';
},
label: function (item) {
return '(' + item.xLabel + ', ' + item.yLabel + ')';
}
}
}
});
module.exports = function (Chart) {
Chart.controllers.scatter = Chart.controllers.line;
};
},
{ '25': 25 }
],
22: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
animation: {
duration: 1000,
easing: 'easeOutQuart',
onProgress: helpers.noop,
onComplete: helpers.noop
}
});
module.exports = function (Chart) {
Chart.Animation = Element.extend({
chart: null,
currentStep: 0,
numSteps: 60,
easing: '',
render: null,
onAnimationProgress: null,
onAnimationComplete: null
});
Chart.animationService = {
frameDuration: 17,
animations: [],
dropFrames: 0,
request: null,
addAnimation: function (chart, animation, duration, lazy) {
var animations = this.animations;
var i, ilen;
animation.chart = chart;
if (!lazy) {
chart.animating = true;
}
for (i = 0, ilen = animations.length; i < ilen; ++i) {
if (animations[i].chart === chart) {
animations[i] = animation;
return;
}
}
animations.push(animation);
if (animations.length === 1) {
this.requestAnimationFrame();
}
},
cancelAnimation: function (chart) {
var index = helpers.findIndex(this.animations, function (animation) {
return animation.chart === chart;
});
if (index !== -1) {
this.animations.splice(index, 1);
chart.animating = false;
}
},
requestAnimationFrame: function () {
var me = this;
if (me.request === null) {
me.request = helpers.requestAnimFrame.call(window, function () {
me.request = null;
me.startDigest();
});
}
},
startDigest: function () {
var me = this;
var startTime = Date.now();
var framesToDrop = 0;
if (me.dropFrames > 1) {
framesToDrop = Math.floor(me.dropFrames);
me.dropFrames = me.dropFrames % 1;
}
me.advance(1 + framesToDrop);
var endTime = Date.now();
me.dropFrames += (endTime - startTime) / me.frameDuration;
if (me.animations.length > 0) {
me.requestAnimationFrame();
}
},
advance: function (count) {
var animations = this.animations;
var animation, chart;
var i = 0;
while (i < animations.length) {
animation = animations[i];
chart = animation.chart;
animation.currentStep = (animation.currentStep || 0) + count;
animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
helpers.callback(animation.render, [
chart,
animation
], chart);
helpers.callback(animation.onAnimationProgress, [animation], chart);
if (animation.currentStep >= animation.numSteps) {
helpers.callback(animation.onAnimationComplete, [animation], chart);
chart.animating = false;
animations.splice(i, 1);
} else {
++i;
}
}
}
};
Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
get: function () {
return this;
}
});
Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
get: function () {
return this.chart;
},
set: function (value) {
this.chart = value;
}
});
};
},
{
'25': 25,
'26': 26,
'45': 45
}
],
23: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var helpers = require(45);
var Interaction = require(28);
var platform = require(48);
module.exports = function (Chart) {
var plugins = Chart.plugins;
Chart.types = {};
Chart.instances = {};
Chart.controllers = {};
function initConfig(config) {
config = config || {};
var data = config.data = config.data || {};
data.datasets = data.datasets || [];
data.labels = data.labels || [];
config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});
return config;
}
function updateConfig(chart) {
var newOptions = chart.options;
if (newOptions.scale) {
chart.scale.options = newOptions.scale;
} else if (newOptions.scales) {
newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {
chart.scales[scaleOptions.id].options = scaleOptions;
});
}
chart.tooltip._options = newOptions.tooltips;
}
function positionIsHorizontal(position) {
return position === 'top' || position === 'bottom';
}
helpers.extend(Chart.prototype, {
construct: function (item, config) {
var me = this;
config = initConfig(config);
var context = platform.acquireContext(item, config);
var canvas = context && context.canvas;
var height = canvas && canvas.height;
var width = canvas && canvas.width;
me.id = helpers.uid();
me.ctx = context;
me.canvas = canvas;
me.config = config;
me.width = width;
me.height = height;
me.aspectRatio = height ? width / height : null;
me.options = config.options;
me._bufferedRender = false;
me.chart = me;
me.controller = me;
Chart.instances[me.id] = me;
Object.defineProperty(me, 'data', {
get: function () {
return me.config.data;
},
set: function (value) {
me.config.data = value;
}
});
if (!context || !canvas) {
console.error('Failed to create chart: can\'t acquire context from the given item');
return;
}
me.initialize();
me.update();
},
initialize: function () {
var me = this;
plugins.notify(me, 'beforeInit');
helpers.retinaScale(me, me.options.devicePixelRatio);
me.bindEvents();
if (me.options.responsive) {
me.resize(true);
}
me.ensureScalesHaveIDs();
me.buildScales();
me.initToolTip();
plugins.notify(me, 'afterInit');
return me;
},
clear: function () {
helpers.canvas.clear(this);
return this;
},
stop: function () {
Chart.animationService.cancelAnimation(this);
return this;
},
resize: function (silent) {
var me = this;
var options = me.options;
var canvas = me.canvas;
var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;
var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));
if (me.width === newWidth && me.height === newHeight) {
return;
}
canvas.width = me.width = newWidth;
canvas.height = me.height = newHeight;
canvas.style.width = newWidth + 'px';
canvas.style.height = newHeight + 'px';
helpers.retinaScale(me, options.devicePixelRatio);
if (!silent) {
var newSize = {
width: newWidth,
height: newHeight
};
plugins.notify(me, 'resize', [newSize]);
if (me.options.onResize) {
me.options.onResize(me, newSize);
}
me.stop();
me.update(me.options.responsiveAnimationDuration);
}
},
ensureScalesHaveIDs: function () {
var options = this.options;
var scalesOptions = options.scales || {};
var scaleOptions = options.scale;
helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
});
helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
});
if (scaleOptions) {
scaleOptions.id = scaleOptions.id || 'scale';
}
},
buildScales: function () {
var me = this;
var options = me.options;
var scales = me.scales = {};
var items = [];
if (options.scales) {
items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
return {
options: xAxisOptions,
dtype: 'category',
dposition: 'bottom'
};
}), (options.scales.yAxes || []).map(function (yAxisOptions) {
return {
options: yAxisOptions,
dtype: 'linear',
dposition: 'left'
};
}));
}
if (options.scale) {
items.push({
options: options.scale,
dtype: 'radialLinear',
isDefault: true,
dposition: 'chartArea'
});
}
helpers.each(items, function (item) {
var scaleOptions = item.options;
var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
if (!scaleClass) {
return;
}
if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
scaleOptions.position = item.dposition;
}
var scale = new scaleClass({
id: scaleOptions.id,
options: scaleOptions,
ctx: me.ctx,
chart: me
});
scales[scale.id] = scale;
scale.mergeTicksOptions();
if (item.isDefault) {
me.scale = scale;
}
});
Chart.scaleService.addScalesToLayout(this);
},
buildOrUpdateControllers: function () {
var me = this;
var types = [];
var newControllers = [];
helpers.each(me.data.datasets, function (dataset, datasetIndex) {
var meta = me.getDatasetMeta(datasetIndex);
var type = dataset.type || me.config.type;
if (meta.type && meta.type !== type) {
me.destroyDatasetMeta(datasetIndex);
meta = me.getDatasetMeta(datasetIndex);
}
meta.type = type;
types.push(meta.type);
if (meta.controller) {
meta.controller.updateIndex(datasetIndex);
} else {
var ControllerClass = Chart.controllers[meta.type];
if (ControllerClass === undefined) {
throw new Error('"' + meta.type + '" is not a chart type.');
}
meta.controller = new ControllerClass(me, datasetIndex);
newControllers.push(meta.controller);
}
}, me);
return newControllers;
},
resetElements: function () {
var me = this;
helpers.each(me.data.datasets, function (dataset, datasetIndex) {
me.getDatasetMeta(datasetIndex).controller.reset();
}, me);
},
reset: function () {
this.resetElements();
this.tooltip.initialize();
},
update: function (config) {
var me = this;
if (!config || typeof config !== 'object') {
config = {
duration: config,
lazy: arguments[1]
};
}
updateConfig(me);
if (plugins.notify(me, 'beforeUpdate') === false) {
return;
}
me.tooltip._data = me.data;
var newControllers = me.buildOrUpdateControllers();
helpers.each(me.data.datasets, function (dataset, datasetIndex) {
me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
}, me);
me.updateLayout();
helpers.each(newControllers, function (controller) {
controller.reset();
});
me.updateDatasets();
me.tooltip.initialize();
me.lastActive = [];
plugins.notify(me, 'afterUpdate');
if (me._bufferedRender) {
me._bufferedRequest = {
duration: config.duration,
easing: config.easing,
lazy: config.lazy
};
} else {
me.render(config);
}
},
updateLayout: function () {
var me = this;
if (plugins.notify(me, 'beforeLayout') === false) {
return;
}
Chart.layoutService.update(this, this.width, this.height);
plugins.notify(me, 'afterScaleUpdate');
plugins.notify(me, 'afterLayout');
},
updateDatasets: function () {
var me = this;
if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
return;
}
for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
me.updateDataset(i);
}
plugins.notify(me, 'afterDatasetsUpdate');
},
updateDataset: function (index) {
var me = this;
var meta = me.getDatasetMeta(index);
var args = {
meta: meta,
index: index
};
if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
return;
}
meta.controller.update();
plugins.notify(me, 'afterDatasetUpdate', [args]);
},
render: function (config) {
var me = this;
if (!config || typeof config !== 'object') {
config = {
duration: config,
lazy: arguments[1]
};
}
var duration = config.duration;
var lazy = config.lazy;
if (plugins.notify(me, 'beforeRender') === false) {
return;
}
var animationOptions = me.options.animation;
var onComplete = function (animation) {
plugins.notify(me, 'afterRender');
helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
};
if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
var animation = new Chart.Animation({
numSteps: (duration || animationOptions.duration) / 16.66,
easing: config.easing || animationOptions.easing,
render: function (chart, animationObject) {
var easingFunction = helpers.easing.effects[animationObject.easing];
var currentStep = animationObject.currentStep;
var stepDecimal = currentStep / animationObject.numSteps;
chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
},
onAnimationProgress: animationOptions.onProgress,
onAnimationComplete: onComplete
});
Chart.animationService.addAnimation(me, animation, duration, lazy);
} else {
me.draw();
onComplete(new Chart.Animation({
numSteps: 0,
chart: me
}));
}
return me;
},
draw: function (easingValue) {
var me = this;
me.clear();
if (helpers.isNullOrUndef(easingValue)) {
easingValue = 1;
}
me.transition(easingValue);
if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
return;
}
helpers.each(me.boxes, function (box) {
box.draw(me.chartArea);
}, me);
if (me.scale) {
me.scale.draw();
}
me.drawDatasets(easingValue);
me._drawTooltip(easingValue);
plugins.notify(me, 'afterDraw', [easingValue]);
},
transition: function (easingValue) {
var me = this;
for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
if (me.isDatasetVisible(i)) {
me.getDatasetMeta(i).controller.transition(easingValue);
}
}
me.tooltip.transition(easingValue);
},
drawDatasets: function (easingValue) {
var me = this;
if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
return;
}
for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
if (me.isDatasetVisible(i)) {
me.drawDataset(i, easingValue);
}
}
plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
},
drawDataset: function (index, easingValue) {
var me = this;
var meta = me.getDatasetMeta(index);
var args = {
meta: meta,
index: index,
easingValue: easingValue
};
if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
return;
}
meta.controller.draw(easingValue);
plugins.notify(me, 'afterDatasetDraw', [args]);
},
_drawTooltip: function (easingValue) {
var me = this;
var tooltip = me.tooltip;
var args = {
tooltip: tooltip,
easingValue: easingValue
};
if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
return;
}
tooltip.draw();
plugins.notify(me, 'afterTooltipDraw', [args]);
},
getElementAtEvent: function (e) {
return Interaction.modes.single(this, e);
},
getElementsAtEvent: function (e) {
return Interaction.modes.label(this, e, { intersect: true });
},
getElementsAtXAxis: function (e) {
return Interaction.modes['x-axis'](this, e, { intersect: true });
},
getElementsAtEventForMode: function (e, mode, options) {
var method = Interaction.modes[mode];
if (typeof method === 'function') {
return method(this, e, options);
}
return [];
},
getDatasetAtEvent: function (e) {
return Interaction.modes.dataset(this, e, { intersect: true });
},
getDatasetMeta: function (datasetIndex) {
var me = this;
var dataset = me.data.datasets[datasetIndex];
if (!dataset._meta) {
dataset._meta = {};
}
var meta = dataset._meta[me.id];
if (!meta) {
meta = dataset._meta[me.id] = {
type: null,
data: [],
dataset: null,
controller: null,
hidden: null,
xAxisID: null,
yAxisID: null
};
}
return meta;
},
getVisibleDatasetCount: function () {
var count = 0;
for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
if (this.isDatasetVisible(i)) {
count++;
}
}
return count;
},
isDatasetVisible: function (datasetIndex) {
var meta = this.getDatasetMeta(datasetIndex);
return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
},
generateLegend: function () {
return this.options.legendCallback(this);
},
destroyDatasetMeta: function (datasetIndex) {
var id = this.id;
var dataset = this.data.datasets[datasetIndex];
var meta = dataset._meta && dataset._meta[id];
if (meta) {
meta.controller.destroy();
delete dataset._meta[id];
}
},
destroy: function () {
var me = this;
var canvas = me.canvas;
var i, ilen;
me.stop();
for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
me.destroyDatasetMeta(i);
}
if (canvas) {
me.unbindEvents();
helpers.canvas.clear(me);
platform.releaseContext(me.ctx);
me.canvas = null;
me.ctx = null;
}
plugins.notify(me, 'destroy');
delete Chart.instances[me.id];
},
toBase64Image: function () {
return this.canvas.toDataURL.apply(this.canvas, arguments);
},
initToolTip: function () {
var me = this;
me.tooltip = new Chart.Tooltip({
_chart: me,
_chartInstance: me,
_data: me.data,
_options: me.options.tooltips
}, me);
},
bindEvents: function () {
var me = this;
var listeners = me._listeners = {};
var listener = function () {
me.eventHandler.apply(me, arguments);
};
helpers.each(me.options.events, function (type) {
platform.addEventListener(me, type, listener);
listeners[type] = listener;
});
if (me.options.responsive) {
listener = function () {
me.resize();
};
platform.addEventListener(me, 'resize', listener);
listeners.resize = listener;
}
},
unbindEvents: function () {
var me = this;
var listeners = me._listeners;
if (!listeners) {
return;
}
delete me._listeners;
helpers.each(listeners, function (listener, type) {
platform.removeEventListener(me, type, listener);
});
},
updateHoverStyle: function (elements, mode, enabled) {
var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
var element, i, ilen;
for (i = 0, ilen = elements.length; i < ilen; ++i) {
element = elements[i];
if (element) {
this.getDatasetMeta(element._datasetIndex).controller[method](element);
}
}
},
eventHandler: function (e) {
var me = this;
var tooltip = me.tooltip;
if (plugins.notify(me, 'beforeEvent', [e]) === false) {
return;
}
me._bufferedRender = true;
me._bufferedRequest = null;
var changed = me.handleEvent(e);
changed |= tooltip && tooltip.handleEvent(e);
plugins.notify(me, 'afterEvent', [e]);
var bufferedRequest = me._bufferedRequest;
if (bufferedRequest) {
me.render(bufferedRequest);
} else if (changed && !me.animating) {
me.stop();
me.render(me.options.hover.animationDuration, true);
}
me._bufferedRender = false;
me._bufferedRequest = null;
return me;
},
handleEvent: function (e) {
var me = this;
var options = me.options || {};
var hoverOptions = options.hover;
var changed = false;
me.lastActive = me.lastActive || [];
if (e.type === 'mouseout') {
me.active = [];
} else {
me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
}
helpers.callback(options.onHover || options.hover.onHover, [
e.native,
me.active
], me);
if (e.type === 'mouseup' || e.type === 'click') {
if (options.onClick) {
options.onClick.call(me, e.native, me.active);
}
}
if (me.lastActive.length) {
me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
}
if (me.active.length && hoverOptions.mode) {
me.updateHoverStyle(me.active, hoverOptions.mode, true);
}
changed = !helpers.arrayEquals(me.active, me.lastActive);
me.lastActive = me.active;
return changed;
}
});
Chart.Controller = Chart;
};
},
{
'25': 25,
'28': 28,
'45': 45,
'48': 48
}
],
24: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
module.exports = function (Chart) {
var arrayEvents = [
'push',
'pop',
'shift',
'splice',
'unshift'
];
function listenArrayEvents(array, listener) {
if (array._chartjs) {
array._chartjs.listeners.push(listener);
return;
}
Object.defineProperty(array, '_chartjs', {
configurable: true,
enumerable: false,
value: { listeners: [listener] }
});
arrayEvents.forEach(function (key) {
var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
var base = array[key];
Object.defineProperty(array, key, {
configurable: true,
enumerable: false,
value: function () {
var args = Array.prototype.slice.call(arguments);
var res = base.apply(this, args);
helpers.each(array._chartjs.listeners, function (object) {
if (typeof object[method] === 'function') {
object[method].apply(object, args);
}
});
return res;
}
});
});
}
function unlistenArrayEvents(array, listener) {
var stub = array._chartjs;
if (!stub) {
return;
}
var listeners = stub.listeners;
var index = listeners.indexOf(listener);
if (index !== -1) {
listeners.splice(index, 1);
}
if (listeners.length > 0) {
return;
}
arrayEvents.forEach(function (key) {
delete array[key];
});
delete array._chartjs;
}
Chart.DatasetController = function (chart, datasetIndex) {
this.initialize(chart, datasetIndex);
};
helpers.extend(Chart.DatasetController.prototype, {
datasetElementType: null,
dataElementType: null,
initialize: function (chart, datasetIndex) {
var me = this;
me.chart = chart;
me.index = datasetIndex;
me.linkScales();
me.addElements();
},
updateIndex: function (datasetIndex) {
this.index = datasetIndex;
},
linkScales: function () {
var me = this;
var meta = me.getMeta();
var dataset = me.getDataset();
if (meta.xAxisID === null) {
meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
}
if (meta.yAxisID === null) {
meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
}
},
getDataset: function () {
return this.chart.data.datasets[this.index];
},
getMeta: function () {
return this.chart.getDatasetMeta(this.index);
},
getScaleForId: function (scaleID) {
return this.chart.scales[scaleID];
},
reset: function () {
this.update(true);
},
destroy: function () {
if (this._data) {
unlistenArrayEvents(this._data, this);
}
},
createMetaDataset: function () {
var me = this;
var type = me.datasetElementType;
return type && new type({
_chart: me.chart,
_datasetIndex: me.index
});
},
createMetaData: function (index) {
var me = this;
var type = me.dataElementType;
return type && new type({
_chart: me.chart,
_datasetIndex: me.index,
_index: index
});
},
addElements: function () {
var me = this;
var meta = me.getMeta();
var data = me.getDataset().data || [];
var metaData = meta.data;
var i, ilen;
for (i = 0, ilen = data.length; i < ilen; ++i) {
metaData[i] = metaData[i] || me.createMetaData(i);
}
meta.dataset = meta.dataset || me.createMetaDataset();
},
addElementAndReset: function (index) {
var element = this.createMetaData(index);
this.getMeta().data.splice(index, 0, element);
this.updateElement(element, index, true);
},
buildOrUpdateElements: function () {
var me = this;
var dataset = me.getDataset();
var data = dataset.data || (dataset.data = []);
if (me._data !== data) {
if (me._data) {
unlistenArrayEvents(me._data, me);
}
listenArrayEvents(data, me);
me._data = data;
}
me.resyncElements();
},
update: helpers.noop,
transition: function (easingValue) {
var meta = this.getMeta();
var elements = meta.data || [];
var ilen = elements.length;
var i = 0;
for (; i < ilen; ++i) {
elements[i].transition(easingValue);
}
if (meta.dataset) {
meta.dataset.transition(easingValue);
}
},
draw: function () {
var meta = this.getMeta();
var elements = meta.data || [];
var ilen = elements.length;
var i = 0;
if (meta.dataset) {
meta.dataset.draw();
}
for (; i < ilen; ++i) {
elements[i].draw();
}
},
removeHoverStyle: function (element, elementOpts) {
var dataset = this.chart.data.datasets[element._datasetIndex];
var index = element._index;
var custom = element.custom || {};
var valueOrDefault = helpers.valueAtIndexOrDefault;
var model = element._model;
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
},
setHoverStyle: function (element) {
var dataset = this.chart.data.datasets[element._datasetIndex];
var index = element._index;
var custom = element.custom || {};
var valueOrDefault = helpers.valueAtIndexOrDefault;
var getHoverColor = helpers.getHoverColor;
var model = element._model;
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
},
resyncElements: function () {
var me = this;
var meta = me.getMeta();
var data = me.getDataset().data;
var numMeta = meta.data.length;
var numData = data.length;
if (numData < numMeta) {
meta.data.splice(numData, numMeta - numData);
} else if (numData > numMeta) {
me.insertElements(numMeta, numData - numMeta);
}
},
insertElements: function (start, count) {
for (var i = 0; i < count; ++i) {
this.addElementAndReset(start + i);
}
},
onDataPush: function () {
this.insertElements(this.getDataset().data.length - 1, arguments.length);
},
onDataPop: function () {
this.getMeta().data.pop();
},
onDataShift: function () {
this.getMeta().data.shift();
},
onDataSplice: function (start, count) {
this.getMeta().data.splice(start, count);
this.insertElements(start, arguments.length - 2);
},
onDataUnshift: function () {
this.insertElements(0, arguments.length);
}
});
Chart.DatasetController.extend = helpers.inherits;
};
},
{ '45': 45 }
],
25: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
module.exports = {
_set: function (scope, values) {
return helpers.merge(this[scope] || (this[scope] = {}), values);
}
};
},
{ '45': 45 }
],
26: [
function (require, module, exports) {
'use strict';
var color = require(3);
var helpers = require(45);
function interpolate(start, view, model, ease) {
var keys = Object.keys(model);
var i, ilen, key, actual, origin, target, type, c0, c1;
for (i = 0, ilen = keys.length; i < ilen; ++i) {
key = keys[i];
target = model[key];
if (!view.hasOwnProperty(key)) {
view[key] = target;
}
actual = view[key];
if (actual === target || key[0] === '_') {
continue;
}
if (!start.hasOwnProperty(key)) {
start[key] = actual;
}
origin = start[key];
type = typeof target;
if (type === typeof origin) {
if (type === 'string') {
c0 = color(origin);
if (c0.valid) {
c1 = color(target);
if (c1.valid) {
view[key] = c1.mix(c0, ease).rgbString();
continue;
}
}
} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
view[key] = origin + (target - origin) * ease;
continue;
}
}
view[key] = target;
}
}
var Element = function (configuration) {
helpers.extend(this, configuration);
this.initialize.apply(this, arguments);
};
helpers.extend(Element.prototype, {
initialize: function () {
this.hidden = false;
},
pivot: function () {
var me = this;
if (!me._view) {
me._view = helpers.clone(me._model);
}
me._start = {};
return me;
},
transition: function (ease) {
var me = this;
var model = me._model;
var start = me._start;
var view = me._view;
if (!model || ease === 1) {
me._view = model;
me._start = null;
return me;
}
if (!view) {
view = me._view = {};
}
if (!start) {
start = me._start = {};
}
interpolate(start, view, model, ease);
return me;
},
tooltipPosition: function () {
return {
x: this._model.x,
y: this._model.y
};
},
hasValue: function () {
return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
}
});
Element.extend = helpers.inherits;
module.exports = Element;
},
{
'3': 3,
'45': 45
}
],
27: [
function (require, module, exports) {
'use strict';
var color = require(3);
var defaults = require(25);
var helpers = require(45);
module.exports = function (Chart) {
helpers.configMerge = function () {
return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
merger: function (key, target, source, options) {
var tval = target[key] || {};
var sval = source[key];
if (key === 'scales') {
target[key] = helpers.scaleMerge(tval, sval);
} else if (key === 'scale') {
target[key] = helpers.merge(tval, [
Chart.scaleService.getScaleDefaults(sval.type),
sval
]);
} else {
helpers._merger(key, target, source, options);
}
}
});
};
helpers.scaleMerge = function () {
return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
merger: function (key, target, source, options) {
if (key === 'xAxes' || key === 'yAxes') {
var slen = source[key].length;
var i, type, scale;
if (!target[key]) {
target[key] = [];
}
for (i = 0; i < slen; ++i) {
scale = source[key][i];
type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');
if (i >= target[key].length) {
target[key].push({});
}
if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
helpers.merge(target[key][i], [
Chart.scaleService.getScaleDefaults(type),
scale
]);
} else {
helpers.merge(target[key][i], scale);
}
}
} else {
helpers._merger(key, target, source, options);
}
}
});
};
helpers.where = function (collection, filterCallback) {
if (helpers.isArray(collection) && Array.prototype.filter) {
return collection.filter(filterCallback);
}
var filtered = [];
helpers.each(collection, function (item) {
if (filterCallback(item)) {
filtered.push(item);
}
});
return filtered;
};
helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
return array.findIndex(callback, scope);
} : function (array, callback, scope) {
scope = scope === undefined ? array : scope;
for (var i = 0, ilen = array.length; i < ilen; ++i) {
if (callback.call(scope, array[i], i, array)) {
return i;
}
}
return -1;
};
helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
if (helpers.isNullOrUndef(startIndex)) {
startIndex = -1;
}
for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
var currentItem = arrayToSearch[i];
if (filterCallback(currentItem)) {
return currentItem;
}
}
};
helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
if (helpers.isNullOrUndef(startIndex)) {
startIndex = arrayToSearch.length;
}
for (var i = startIndex - 1; i >= 0; i--) {
var currentItem = arrayToSearch[i];
if (filterCallback(currentItem)) {
return currentItem;
}
}
};
helpers.isNumber = function (n) {
return !isNaN(parseFloat(n)) && isFinite(n);
};
helpers.almostEquals = function (x, y, epsilon) {
return Math.abs(x - y) < epsilon;
};
helpers.almostWhole = function (x, epsilon) {
var rounded = Math.round(x);
return rounded - epsilon < x && rounded + epsilon > x;
};
helpers.max = function (array) {
return array.reduce(function (max, value) {
if (!isNaN(value)) {
return Math.max(max, value);
}
return max;
}, Number.NEGATIVE_INFINITY);
};
helpers.min = function (array) {
return array.reduce(function (min, value) {
if (!isNaN(value)) {
return Math.min(min, value);
}
return min;
}, Number.POSITIVE_INFINITY);
};
helpers.sign = Math.sign ? function (x) {
return Math.sign(x);
} : function (x) {
x = +x;
if (x === 0 || isNaN(x)) {
return x;
}
return x > 0 ? 1 : -1;
};
helpers.log10 = Math.log10 ? function (x) {
return Math.log10(x);
} : function (x) {
return Math.log(x) / Math.LN10;
};
helpers.toRadians = function (degrees) {
return degrees * (Math.PI / 180);
};
helpers.toDegrees = function (radians) {
return radians * (180 / Math.PI);
};
helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
var distanceFromXCenter = anglePoint.x - centrePoint.x;
var distanceFromYCenter = anglePoint.y - centrePoint.y;
var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
if (angle < -0.5 * Math.PI) {
angle += 2 * Math.PI;
}
return {
angle: angle,
distance: radialDistanceFromCenter
};
};
helpers.distanceBetweenPoints = function (pt1, pt2) {
return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
};
helpers.aliasPixel = function (pixelWidth) {
return pixelWidth % 2 === 0 ? 0 : 0.5;
};
helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
var previous = firstPoint.skip ? middlePoint : firstPoint;
var current = middlePoint;
var next = afterPoint.skip ? middlePoint : afterPoint;
var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
var s01 = d01 / (d01 + d12);
var s12 = d12 / (d01 + d12);
s01 = isNaN(s01) ? 0 : s01;
s12 = isNaN(s12) ? 0 : s12;
var fa = t * s01;
var fb = t * s12;
return {
previous: {
x: current.x - fa * (next.x - previous.x),
y: current.y - fa * (next.y - previous.y)
},
next: {
x: current.x + fb * (next.x - previous.x),
y: current.y + fb * (next.y - previous.y)
}
};
};
helpers.EPSILON = Number.EPSILON || 1e-14;
helpers.splineCurveMonotone = function (points) {
var pointsWithTangents = (points || []).map(function (point) {
return {
model: point._model,
deltaK: 0,
mK: 0
};
});
var pointsLen = pointsWithTangents.length;
var i, pointBefore, pointCurrent, pointAfter;
for (i = 0; i < pointsLen; ++i) {
pointCurrent = pointsWithTangents[i];
if (pointCurrent.model.skip) {
continue;
}
pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
if (pointAfter && !pointAfter.model.skip) {
var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
}
if (!pointBefore || pointBefore.model.skip) {
pointCurrent.mK = pointCurrent.deltaK;
} else if (!pointAfter || pointAfter.model.skip) {
pointCurrent.mK = pointBefore.deltaK;
} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
pointCurrent.mK = 0;
} else {
pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
}
}
var alphaK, betaK, tauK, squaredMagnitude;
for (i = 0; i < pointsLen - 1; ++i) {
pointCurrent = pointsWithTangents[i];
pointAfter = pointsWithTangents[i + 1];
if (pointCurrent.model.skip || pointAfter.model.skip) {
continue;
}
if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
pointCurrent.mK = pointAfter.mK = 0;
continue;
}
alphaK = pointCurrent.mK / pointCurrent.deltaK;
betaK = pointAfter.mK / pointCurrent.deltaK;
squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
if (squaredMagnitude <= 9) {
continue;
}
tauK = 3 / Math.sqrt(squaredMagnitude);
pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
}
var deltaX;
for (i = 0; i < pointsLen; ++i) {
pointCurrent = pointsWithTangents[i];
if (pointCurrent.model.skip) {
continue;
}
pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
if (pointBefore && !pointBefore.model.skip) {
deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
}
if (pointAfter && !pointAfter.model.skip) {
deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
}
}
};
helpers.nextItem = function (collection, index, loop) {
if (loop) {
return index >= collection.length - 1 ? collection[0] : collection[index + 1];
}
return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
};
helpers.previousItem = function (collection, index, loop) {
if (loop) {
return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
}
return index <= 0 ? collection[0] : collection[index - 1];
};
helpers.niceNum = function (range, round) {
var exponent = Math.floor(helpers.log10(range));
var fraction = range / Math.pow(10, exponent);
var niceFraction;
if (round) {
if (fraction < 1.5) {
niceFraction = 1;
} else if (fraction < 3) {
niceFraction = 2;
} else if (fraction < 7) {
niceFraction = 5;
} else {
niceFraction = 10;
}
} else if (fraction <= 1) {
niceFraction = 1;
} else if (fraction <= 2) {
niceFraction = 2;
} else if (fraction <= 5) {
niceFraction = 5;
} else {
niceFraction = 10;
}
return niceFraction * Math.pow(10, exponent);
};
helpers.requestAnimFrame = function () {
if (typeof window === 'undefined') {
return function (callback) {
callback();
};
}
return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
return window.setTimeout(callback, 1000 / 60);
};
}();
helpers.getRelativePosition = function (evt, chart) {
var mouseX, mouseY;
var e = evt.originalEvent || evt;
var canvas = evt.currentTarget || evt.srcElement;
var boundingRect = canvas.getBoundingClientRect();
var touches = e.touches;
if (touches && touches.length > 0) {
mouseX = touches[0].clientX;
mouseY = touches[0].clientY;
} else {
mouseX = e.clientX;
mouseY = e.clientY;
}
var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
return {
x: mouseX,
y: mouseY
};
};
function parseMaxStyle(styleValue, node, parentProperty) {
var valueInPixels;
if (typeof styleValue === 'string') {
valueInPixels = parseInt(styleValue, 10);
if (styleValue.indexOf('%') !== -1) {
valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
}
} else {
valueInPixels = styleValue;
}
return valueInPixels;
}
function isConstrainedValue(value) {
return value !== undefined && value !== null && value !== 'none';
}
function getConstraintDimension(domNode, maxStyle, percentageProperty) {
var view = document.defaultView;
var parentNode = domNode.parentNode;
var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
var hasCNode = isConstrainedValue(constrainedNode);
var hasCContainer = isConstrainedValue(constrainedContainer);
var infinity = Number.POSITIVE_INFINITY;
if (hasCNode || hasCContainer) {
return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
}
return 'none';
}
helpers.getConstraintWidth = function (domNode) {
return getConstraintDimension(domNode, 'max-width', 'clientWidth');
};
helpers.getConstraintHeight = function (domNode) {
return getConstraintDimension(domNode, 'max-height', 'clientHeight');
};
helpers.getMaximumWidth = function (domNode) {
var container = domNode.parentNode;
if (!container) {
return domNode.clientWidth;
}
var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
var w = container.clientWidth - paddingLeft - paddingRight;
var cw = helpers.getConstraintWidth(domNode);
return isNaN(cw) ? w : Math.min(w, cw);
};
helpers.getMaximumHeight = function (domNode) {
var container = domNode.parentNode;
if (!container) {
return domNode.clientHeight;
}
var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
var h = container.clientHeight - paddingTop - paddingBottom;
var ch = helpers.getConstraintHeight(domNode);
return isNaN(ch) ? h : Math.min(h, ch);
};
helpers.getStyle = function (el, property) {
return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
};
helpers.retinaScale = function (chart, forceRatio) {
var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
if (pixelRatio === 1) {
return;
}
var canvas = chart.canvas;
var height = chart.height;
var width = chart.width;
canvas.height = height * pixelRatio;
canvas.width = width * pixelRatio;
chart.ctx.scale(pixelRatio, pixelRatio);
canvas.style.height = height + 'px';
canvas.style.width = width + 'px';
};
helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
};
helpers.longestText = function (ctx, font, arrayOfThings, cache) {
cache = cache || {};
var data = cache.data = cache.data || {};
var gc = cache.garbageCollect = cache.garbageCollect || [];
if (cache.font !== font) {
data = cache.data = {};
gc = cache.garbageCollect = [];
cache.font = font;
}
ctx.font = font;
var longest = 0;
helpers.each(arrayOfThings, function (thing) {
if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
longest = helpers.measureText(ctx, data, gc, longest, thing);
} else if (helpers.isArray(thing)) {
helpers.each(thing, function (nestedThing) {
if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
}
});
}
});
var gcLen = gc.length / 2;
if (gcLen > arrayOfThings.length) {
for (var i = 0; i < gcLen; i++) {
delete data[gc[i]];
}
gc.splice(0, gcLen);
}
return longest;
};
helpers.measureText = function (ctx, data, gc, longest, string) {
var textWidth = data[string];
if (!textWidth) {
textWidth = data[string] = ctx.measureText(string).width;
gc.push(string);
}
if (textWidth > longest) {
longest = textWidth;
}
return longest;
};
helpers.numberOfLabelLines = function (arrayOfThings) {
var numberOfLines = 1;
helpers.each(arrayOfThings, function (thing) {
if (helpers.isArray(thing)) {
if (thing.length > numberOfLines) {
numberOfLines = thing.length;
}
}
});
return numberOfLines;
};
helpers.color = !color ? function (value) {
console.error('Color.js not found!');
return value;
} : function (value) {
if (value instanceof CanvasGradient) {
value = defaults.global.defaultColor;
}
return color(value);
};
helpers.getHoverColor = function (colorValue) {
return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
};
};
},
{
'25': 25,
'3': 3,
'45': 45
}
],
28: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
function getRelativePosition(e, chart) {
if (e.native) {
return {
x: e.x,
y: e.y
};
}
return helpers.getRelativePosition(e, chart);
}
function parseVisibleItems(chart, handler) {
var datasets = chart.data.datasets;
var meta, i, j, ilen, jlen;
for (i = 0, ilen = datasets.length; i < ilen; ++i) {
if (!chart.isDatasetVisible(i)) {
continue;
}
meta = chart.getDatasetMeta(i);
for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
var element = meta.data[j];
if (!element._view.skip) {
handler(element);
}
}
}
}
function getIntersectItems(chart, position) {
var elements = [];
parseVisibleItems(chart, function (element) {
if (element.inRange(position.x, position.y)) {
elements.push(element);
}
});
return elements;
}
function getNearestItems(chart, position, intersect, distanceMetric) {
var minDistance = Number.POSITIVE_INFINITY;
var nearestItems = [];
parseVisibleItems(chart, function (element) {
if (intersect && !element.inRange(position.x, position.y)) {
return;
}
var center = element.getCenterPoint();
var distance = distanceMetric(position, center);
if (distance < minDistance) {
nearestItems = [element];
minDistance = distance;
} else if (distance === minDistance) {
nearestItems.push(element);
}
});
return nearestItems;
}
function getDistanceMetricForAxis(axis) {
var useX = axis.indexOf('x') !== -1;
var useY = axis.indexOf('y') !== -1;
return function (pt1, pt2) {
var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
};
}
function indexMode(chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'x';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
var elements = [];
if (!items.length) {
return [];
}
chart.data.datasets.forEach(function (dataset, datasetIndex) {
if (chart.isDatasetVisible(datasetIndex)) {
var meta = chart.getDatasetMeta(datasetIndex);
var element = meta.data[items[0]._index];
if (element && !element._view.skip) {
elements.push(element);
}
}
});
return elements;
}
module.exports = {
modes: {
single: function (chart, e) {
var position = getRelativePosition(e, chart);
var elements = [];
parseVisibleItems(chart, function (element) {
if (element.inRange(position.x, position.y)) {
elements.push(element);
return elements;
}
});
return elements.slice(0, 1);
},
label: indexMode,
index: indexMode,
dataset: function (chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'xy';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
if (items.length > 0) {
items = chart.getDatasetMeta(items[0]._datasetIndex).data;
}
return items;
},
'x-axis': function (chart, e) {
return indexMode(chart, e, { intersect: false });
},
point: function (chart, e) {
var position = getRelativePosition(e, chart);
return getIntersectItems(chart, position);
},
nearest: function (chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'xy';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);
if (nearestItems.length > 1) {
nearestItems.sort(function (a, b) {
var sizeA = a.getArea();
var sizeB = b.getArea();
var ret = sizeA - sizeB;
if (ret === 0) {
ret = a._datasetIndex - b._datasetIndex;
}
return ret;
});
}
return nearestItems.slice(0, 1);
},
x: function (chart, e, options) {
var position = getRelativePosition(e, chart);
var items = [];
var intersectsItem = false;
parseVisibleItems(chart, function (element) {
if (element.inXRange(position.x)) {
items.push(element);
}
if (element.inRange(position.x, position.y)) {
intersectsItem = true;
}
});
if (options.intersect && !intersectsItem) {
items = [];
}
return items;
},
y: function (chart, e, options) {
var position = getRelativePosition(e, chart);
var items = [];
var intersectsItem = false;
parseVisibleItems(chart, function (element) {
if (element.inYRange(position.y)) {
items.push(element);
}
if (element.inRange(position.x, position.y)) {
intersectsItem = true;
}
});
if (options.intersect && !intersectsItem) {
items = [];
}
return items;
}
}
};
},
{ '45': 45 }
],
29: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
defaults._set('global', {
responsive: true,
responsiveAnimationDuration: 0,
maintainAspectRatio: true,
events: [
'mousemove',
'mouseout',
'click',
'touchstart',
'touchmove'
],
hover: {
onHover: null,
mode: 'nearest',
intersect: true,
animationDuration: 400
},
onClick: null,
defaultColor: 'rgba(0,0,0,0.1)',
defaultFontColor: '#666',
defaultFontFamily: '\'Helvetica Neue\', \'Helvetica\', \'Arial\', sans-serif',
defaultFontSize: 12,
defaultFontStyle: 'normal',
showLines: true,
elements: {},
layout: {
padding: {
top: 0,
right: 0,
bottom: 0,
left: 0
}
}
});
module.exports = function () {
var Chart = function (item, config) {
this.construct(item, config);
return this;
};
Chart.Chart = Chart;
return Chart;
};
},
{ '25': 25 }
],
30: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
module.exports = function (Chart) {
function filterByPosition(array, position) {
return helpers.where(array, function (v) {
return v.position === position;
});
}
function sortByWeight(array, reverse) {
array.forEach(function (v, i) {
v._tmpIndex_ = i;
return v;
});
array.sort(function (a, b) {
var v0 = reverse ? b : a;
var v1 = reverse ? a : b;
return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
});
array.forEach(function (v) {
delete v._tmpIndex_;
});
}
Chart.layoutService = {
defaults: {},
addBox: function (chart, item) {
if (!chart.boxes) {
chart.boxes = [];
}
item.fullWidth = item.fullWidth || false;
item.position = item.position || 'top';
item.weight = item.weight || 0;
chart.boxes.push(item);
},
removeBox: function (chart, layoutItem) {
var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
if (index !== -1) {
chart.boxes.splice(index, 1);
}
},
configure: function (chart, item, options) {
var props = [
'fullWidth',
'position',
'weight'
];
var ilen = props.length;
var i = 0;
var prop;
for (; i < ilen; ++i) {
prop = props[i];
if (options.hasOwnProperty(prop)) {
item[prop] = options[prop];
}
}
},
update: function (chart, width, height) {
if (!chart) {
return;
}
var layoutOptions = chart.options.layout || {};
var padding = helpers.options.toPadding(layoutOptions.padding);
var leftPadding = padding.left;
var rightPadding = padding.right;
var topPadding = padding.top;
var bottomPadding = padding.bottom;
var leftBoxes = filterByPosition(chart.boxes, 'left');
var rightBoxes = filterByPosition(chart.boxes, 'right');
var topBoxes = filterByPosition(chart.boxes, 'top');
var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');
sortByWeight(leftBoxes, true);
sortByWeight(rightBoxes, false);
sortByWeight(topBoxes, true);
sortByWeight(bottomBoxes, false);
var chartWidth = width - leftPadding - rightPadding;
var chartHeight = height - topPadding - bottomPadding;
var chartAreaWidth = chartWidth / 2;
var chartAreaHeight = chartHeight / 2;
var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
var maxChartAreaWidth = chartWidth;
var maxChartAreaHeight = chartHeight;
var minBoxSizes = [];
function getMinimumBoxSize(box) {
var minSize;
var isHorizontal = box.isHorizontal();
if (isHorizontal) {
minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
maxChartAreaHeight -= minSize.height;
} else {
minSize = box.update(verticalBoxWidth, chartAreaHeight);
maxChartAreaWidth -= minSize.width;
}
minBoxSizes.push({
horizontal: isHorizontal,
minSize: minSize,
box: box
});
}
helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
var maxHorizontalLeftPadding = 0;
var maxHorizontalRightPadding = 0;
var maxVerticalTopPadding = 0;
var maxVerticalBottomPadding = 0;
helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
if (horizontalBox.getPadding) {
var boxPadding = horizontalBox.getPadding();
maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
}
});
helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
if (verticalBox.getPadding) {
var boxPadding = verticalBox.getPadding();
maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
}
});
var totalLeftBoxesWidth = leftPadding;
var totalRightBoxesWidth = rightPadding;
var totalTopBoxesHeight = topPadding;
var totalBottomBoxesHeight = bottomPadding;
function fitBox(box) {
var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
return minBox.box === box;
});
if (minBoxSize) {
if (box.isHorizontal()) {
var scaleMargin = {
left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
top: 0,
bottom: 0
};
box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
} else {
box.update(minBoxSize.minSize.width, maxChartAreaHeight);
}
}
}
helpers.each(leftBoxes.concat(rightBoxes), fitBox);
helpers.each(leftBoxes, function (box) {
totalLeftBoxesWidth += box.width;
});
helpers.each(rightBoxes, function (box) {
totalRightBoxesWidth += box.width;
});
helpers.each(topBoxes.concat(bottomBoxes), fitBox);
helpers.each(topBoxes, function (box) {
totalTopBoxesHeight += box.height;
});
helpers.each(bottomBoxes, function (box) {
totalBottomBoxesHeight += box.height;
});
function finalFitVerticalBox(box) {
var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
return minSize.box === box;
});
var scaleMargin = {
left: 0,
right: 0,
top: totalTopBoxesHeight,
bottom: totalBottomBoxesHeight
};
if (minBoxSize) {
box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
}
}
helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
totalLeftBoxesWidth = leftPadding;
totalRightBoxesWidth = rightPadding;
totalTopBoxesHeight = topPadding;
totalBottomBoxesHeight = bottomPadding;
helpers.each(leftBoxes, function (box) {
totalLeftBoxesWidth += box.width;
});
helpers.each(rightBoxes, function (box) {
totalRightBoxesWidth += box.width;
});
helpers.each(topBoxes, function (box) {
totalTopBoxesHeight += box.height;
});
helpers.each(bottomBoxes, function (box) {
totalBottomBoxesHeight += box.height;
});
var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
totalLeftBoxesWidth += leftPaddingAddition;
totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
totalTopBoxesHeight += topPaddingAddition;
totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
helpers.each(leftBoxes, function (box) {
box.height = newMaxChartAreaHeight;
});
helpers.each(rightBoxes, function (box) {
box.height = newMaxChartAreaHeight;
});
helpers.each(topBoxes, function (box) {
if (!box.fullWidth) {
box.width = newMaxChartAreaWidth;
}
});
helpers.each(bottomBoxes, function (box) {
if (!box.fullWidth) {
box.width = newMaxChartAreaWidth;
}
});
maxChartAreaHeight = newMaxChartAreaHeight;
maxChartAreaWidth = newMaxChartAreaWidth;
}
var left = leftPadding + leftPaddingAddition;
var top = topPadding + topPaddingAddition;
function placeBox(box) {
if (box.isHorizontal()) {
box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
box.top = top;
box.bottom = top + box.height;
top = box.bottom;
} else {
box.left = left;
box.right = left + box.width;
box.top = totalTopBoxesHeight;
box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
left = box.right;
}
}
helpers.each(leftBoxes.concat(topBoxes), placeBox);
left += maxChartAreaWidth;
top += maxChartAreaHeight;
helpers.each(rightBoxes, placeBox);
helpers.each(bottomBoxes, placeBox);
chart.chartArea = {
left: totalLeftBoxesWidth,
top: totalTopBoxesHeight,
right: totalLeftBoxesWidth + maxChartAreaWidth,
bottom: totalTopBoxesHeight + maxChartAreaHeight
};
helpers.each(chartAreaBoxes, function (box) {
box.left = chart.chartArea.left;
box.top = chart.chartArea.top;
box.right = chart.chartArea.right;
box.bottom = chart.chartArea.bottom;
box.update(maxChartAreaWidth, maxChartAreaHeight);
});
}
};
};
},
{ '45': 45 }
],
31: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', { plugins: {} });
module.exports = function (Chart) {
Chart.plugins = {
_plugins: [],
_cacheId: 0,
register: function (plugins) {
var p = this._plugins;
[].concat(plugins).forEach(function (plugin) {
if (p.indexOf(plugin) === -1) {
p.push(plugin);
}
});
this._cacheId++;
},
unregister: function (plugins) {
var p = this._plugins;
[].concat(plugins).forEach(function (plugin) {
var idx = p.indexOf(plugin);
if (idx !== -1) {
p.splice(idx, 1);
}
});
this._cacheId++;
},
clear: function () {
this._plugins = [];
this._cacheId++;
},
count: function () {
return this._plugins.length;
},
getAll: function () {
return this._plugins;
},
notify: function (chart, hook, args) {
var descriptors = this.descriptors(chart);
var ilen = descriptors.length;
var i, descriptor, plugin, params, method;
for (i = 0; i < ilen; ++i) {
descriptor = descriptors[i];
plugin = descriptor.plugin;
method = plugin[hook];
if (typeof method === 'function') {
params = [chart].concat(args || []);
params.push(descriptor.options);
if (method.apply(plugin, params) === false) {
return false;
}
}
}
return true;
},
descriptors: function (chart) {
var cache = chart._plugins || (chart._plugins = {});
if (cache.id === this._cacheId) {
return cache.descriptors;
}
var plugins = [];
var descriptors = [];
var config = chart && chart.config || {};
var options = config.options && config.options.plugins || {};
this._plugins.concat(config.plugins || []).forEach(function (plugin) {
var idx = plugins.indexOf(plugin);
if (idx !== -1) {
return;
}
var id = plugin.id;
var opts = options[id];
if (opts === false) {
return;
}
if (opts === true) {
opts = helpers.clone(defaults.global.plugins[id]);
}
plugins.push(plugin);
descriptors.push({
plugin: plugin,
options: opts || {}
});
});
cache.descriptors = descriptors;
cache.id = this._cacheId;
return descriptors;
}
};
Chart.pluginService = Chart.plugins;
Chart.PluginBase = Element.extend({});
};
},
{
'25': 25,
'26': 26,
'45': 45
}
],
32: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var Ticks = require(34);
defaults._set('scale', {
display: true,
position: 'left',
offset: false,
gridLines: {
display: true,
color: 'rgba(0, 0, 0, 0.1)',
lineWidth: 1,
drawBorder: true,
drawOnChartArea: true,
drawTicks: true,
tickMarkLength: 10,
zeroLineWidth: 1,
zeroLineColor: 'rgba(0,0,0,0.25)',
zeroLineBorderDash: [],
zeroLineBorderDashOffset: 0,
offsetGridLines: false,
borderDash: [],
borderDashOffset: 0
},
scaleLabel: {
display: false,
labelString: '',
lineHeight: 1.2,
padding: {
top: 4,
bottom: 4
}
},
ticks: {
beginAtZero: false,
minRotation: 0,
maxRotation: 50,
mirror: false,
padding: 0,
reverse: false,
display: true,
autoSkip: true,
autoSkipPadding: 0,
labelOffset: 0,
callback: Ticks.formatters.values,
minor: {},
major: {}
}
});
function labelsFromTicks(ticks) {
var labels = [];
var i, ilen;
for (i = 0, ilen = ticks.length; i < ilen; ++i) {
labels.push(ticks[i].label);
}
return labels;
}
function getLineValue(scale, index, offsetGridLines) {
var lineValue = scale.getPixelForTick(index);
if (offsetGridLines) {
if (index === 0) {
lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
} else {
lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
}
}
return lineValue;
}
module.exports = function (Chart) {
function computeTextSize(context, tick, font) {
return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
}
function parseFontOptions(options) {
var valueOrDefault = helpers.valueOrDefault;
var globalDefaults = defaults.global;
var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
return {
size: size,
style: style,
family: family,
font: helpers.fontString(size, style, family)
};
}
function parseLineHeight(options) {
return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
}
Chart.Scale = Element.extend({
getPadding: function () {
var me = this;
return {
left: me.paddingLeft || 0,
top: me.paddingTop || 0,
right: me.paddingRight || 0,
bottom: me.paddingBottom || 0
};
},
getTicks: function () {
return this._ticks;
},
mergeTicksOptions: function () {
var ticks = this.options.ticks;
if (ticks.minor === false) {
ticks.minor = { display: false };
}
if (ticks.major === false) {
ticks.major = { display: false };
}
for (var key in ticks) {
if (key !== 'major' && key !== 'minor') {
if (typeof ticks.minor[key] === 'undefined') {
ticks.minor[key] = ticks[key];
}
if (typeof ticks.major[key] === 'undefined') {
ticks.major[key] = ticks[key];
}
}
}
},
beforeUpdate: function () {
helpers.callback(this.options.beforeUpdate, [this]);
},
update: function (maxWidth, maxHeight, margins) {
var me = this;
var i, ilen, labels, label, ticks, tick;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = helpers.extend({
left: 0,
right: 0,
top: 0,
bottom: 0
}, margins);
me.longestTextCache = me.longestTextCache || {};
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeDataLimits();
me.determineDataLimits();
me.afterDataLimits();
me.beforeBuildTicks();
ticks = me.buildTicks() || [];
me.afterBuildTicks();
me.beforeTickToLabelConversion();
labels = me.convertTicksToLabels(ticks) || me.ticks;
me.afterTickToLabelConversion();
me.ticks = labels;
for (i = 0, ilen = labels.length; i < ilen; ++i) {
label = labels[i];
tick = ticks[i];
if (!tick) {
ticks.push(tick = {
label: label,
major: false
});
} else {
tick.label = label;
}
}
me._ticks = ticks;
me.beforeCalculateTickRotation();
me.calculateTickRotation();
me.afterCalculateTickRotation();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: function () {
helpers.callback(this.options.afterUpdate, [this]);
},
beforeSetDimensions: function () {
helpers.callback(this.options.beforeSetDimensions, [this]);
},
setDimensions: function () {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
},
afterSetDimensions: function () {
helpers.callback(this.options.afterSetDimensions, [this]);
},
beforeDataLimits: function () {
helpers.callback(this.options.beforeDataLimits, [this]);
},
determineDataLimits: helpers.noop,
afterDataLimits: function () {
helpers.callback(this.options.afterDataLimits, [this]);
},
beforeBuildTicks: function () {
helpers.callback(this.options.beforeBuildTicks, [this]);
},
buildTicks: helpers.noop,
afterBuildTicks: function () {
helpers.callback(this.options.afterBuildTicks, [this]);
},
beforeTickToLabelConversion: function () {
helpers.callback(this.options.beforeTickToLabelConversion, [this]);
},
convertTicksToLabels: function () {
var me = this;
var tickOpts = me.options.ticks;
me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
},
afterTickToLabelConversion: function () {
helpers.callback(this.options.afterTickToLabelConversion, [this]);
},
beforeCalculateTickRotation: function () {
helpers.callback(this.options.beforeCalculateTickRotation, [this]);
},
calculateTickRotation: function () {
var me = this;
var context = me.ctx;
var tickOpts = me.options.ticks;
var labels = labelsFromTicks(me._ticks);
var tickFont = parseFontOptions(tickOpts);
context.font = tickFont.font;
var labelRotation = tickOpts.minRotation || 0;
if (labels.length && me.options.display && me.isHorizontal()) {
var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
var labelWidth = originalLabelWidth;
var cosRotation, sinRotation;
var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
var angleRadians = helpers.toRadians(labelRotation);
cosRotation = Math.cos(angleRadians);
sinRotation = Math.sin(angleRadians);
if (sinRotation * originalLabelWidth > me.maxHeight) {
labelRotation--;
break;
}
labelRotation++;
labelWidth = cosRotation * originalLabelWidth;
}
}
me.labelRotation = labelRotation;
},
afterCalculateTickRotation: function () {
helpers.callback(this.options.afterCalculateTickRotation, [this]);
},
beforeFit: function () {
helpers.callback(this.options.beforeFit, [this]);
},
fit: function () {
var me = this;
var minSize = me.minSize = {
width: 0,
height: 0
};
var labels = labelsFromTicks(me._ticks);
var opts = me.options;
var tickOpts = opts.ticks;
var scaleLabelOpts = opts.scaleLabel;
var gridLineOpts = opts.gridLines;
var display = opts.display;
var isHorizontal = me.isHorizontal();
var tickFont = parseFontOptions(tickOpts);
var tickMarkLength = opts.gridLines.tickMarkLength;
if (isHorizontal) {
minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
} else {
minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
}
if (isHorizontal) {
minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
} else {
minSize.height = me.maxHeight;
}
if (scaleLabelOpts.display && display) {
var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;
if (isHorizontal) {
minSize.height += deltaHeight;
} else {
minSize.width += deltaHeight;
}
}
if (tickOpts.display && display) {
var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
var lineSpace = tickFont.size * 0.5;
var tickPadding = me.options.ticks.padding;
if (isHorizontal) {
me.longestLabelWidth = largestTextWidth;
var angleRadians = helpers.toRadians(me.labelRotation);
var cosRotation = Math.cos(angleRadians);
var sinRotation = Math.sin(angleRadians);
var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace;
minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
me.ctx.font = tickFont.font;
var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);
if (me.labelRotation !== 0) {
me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3;
me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
} else {
me.paddingLeft = firstLabelWidth / 2 + 3;
me.paddingRight = lastLabelWidth / 2 + 3;
}
} else {
if (tickOpts.mirror) {
largestTextWidth = 0;
} else {
largestTextWidth += tickPadding + lineSpace;
}
minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
me.paddingTop = tickFont.size / 2;
me.paddingBottom = tickFont.size / 2;
}
}
me.handleMargins();
me.width = minSize.width;
me.height = minSize.height;
},
handleMargins: function () {
var me = this;
if (me.margins) {
me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
}
},
afterFit: function () {
helpers.callback(this.options.afterFit, [this]);
},
isHorizontal: function () {
return this.options.position === 'top' || this.options.position === 'bottom';
},
isFullWidth: function () {
return this.options.fullWidth;
},
getRightValue: function (rawValue) {
if (helpers.isNullOrUndef(rawValue)) {
return NaN;
}
if (typeof rawValue === 'number' && !isFinite(rawValue)) {
return NaN;
}
if (rawValue) {
if (this.isHorizontal()) {
if (rawValue.x !== undefined) {
return this.getRightValue(rawValue.x);
}
} else if (rawValue.y !== undefined) {
return this.getRightValue(rawValue.y);
}
}
return rawValue;
},
getLabelForIndex: helpers.noop,
getPixelForValue: helpers.noop,
getValueForPixel: helpers.noop,
getPixelForTick: function (index) {
var me = this;
var offset = me.options.offset;
if (me.isHorizontal()) {
var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
var pixel = tickWidth * index + me.paddingLeft;
if (offset) {
pixel += tickWidth / 2;
}
var finalVal = me.left + Math.round(pixel);
finalVal += me.isFullWidth() ? me.margins.left : 0;
return finalVal;
}
var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
return me.top + index * (innerHeight / (me._ticks.length - 1));
},
getPixelForDecimal: function (decimal) {
var me = this;
if (me.isHorizontal()) {
var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
var valueOffset = innerWidth * decimal + me.paddingLeft;
var finalVal = me.left + Math.round(valueOffset);
finalVal += me.isFullWidth() ? me.margins.left : 0;
return finalVal;
}
return me.top + decimal * me.height;
},
getBasePixel: function () {
return this.getPixelForValue(this.getBaseValue());
},
getBaseValue: function () {
var me = this;
var min = me.min;
var max = me.max;
return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
},
_autoSkip: function (ticks) {
var skipRatio;
var me = this;
var isHorizontal = me.isHorizontal();
var optionTicks = me.options.ticks.minor;
var tickCount = ticks.length;
var labelRotationRadians = helpers.toRadians(me.labelRotation);
var cosRotation = Math.cos(labelRotationRadians);
var longestRotatedLabel = me.longestLabelWidth * cosRotation;
var result = [];
var i, tick, shouldSkip;
var maxTicks;
if (optionTicks.maxTicksLimit) {
maxTicks = optionTicks.maxTicksLimit;
}
if (isHorizontal) {
skipRatio = false;
if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
}
if (maxTicks && tickCount > maxTicks) {
skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
}
}
for (i = 0; i < tickCount; i++) {
tick = ticks[i];
shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;
if (shouldSkip && i !== tickCount - 1) {
delete tick.label;
}
result.push(tick);
}
return result;
},
draw: function (chartArea) {
var me = this;
var options = me.options;
if (!options.display) {
return;
}
var context = me.ctx;
var globalDefaults = defaults.global;
var optionTicks = options.ticks.minor;
var optionMajorTicks = options.ticks.major || optionTicks;
var gridLines = options.gridLines;
var scaleLabel = options.scaleLabel;
var isRotated = me.labelRotation !== 0;
var isHorizontal = me.isHorizontal();
var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
var tickFont = parseFontOptions(optionTicks);
var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
var majorTickFont = parseFontOptions(optionMajorTicks);
var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
var scaleLabelFont = parseFontOptions(scaleLabel);
var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
var labelRotationRadians = helpers.toRadians(me.labelRotation);
var itemsToDraw = [];
var xTickStart = options.position === 'right' ? me.left : me.right - tl;
var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;
helpers.each(ticks, function (tick, index) {
if (helpers.isNullOrUndef(tick.label)) {
return;
}
var label = tick.label;
var lineWidth, lineColor, borderDash, borderDashOffset;
if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
lineWidth = gridLines.zeroLineWidth;
lineColor = gridLines.zeroLineColor;
borderDash = gridLines.zeroLineBorderDash;
borderDashOffset = gridLines.zeroLineBorderDashOffset;
} else {
lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
}
var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
var textAlign = 'middle';
var textBaseline = 'middle';
var tickPadding = optionTicks.padding;
if (isHorizontal) {
var labelYOffset = tl + tickPadding;
if (options.position === 'bottom') {
textBaseline = !isRotated ? 'top' : 'middle';
textAlign = !isRotated ? 'center' : 'right';
labelY = me.top + labelYOffset;
} else {
textBaseline = !isRotated ? 'bottom' : 'middle';
textAlign = !isRotated ? 'center' : 'left';
labelY = me.bottom - labelYOffset;
}
var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
if (xLineValue < me.left) {
lineColor = 'rgba(0,0,0,0)';
}
xLineValue += helpers.aliasPixel(lineWidth);
labelX = me.getPixelForTick(index) + optionTicks.labelOffset;
tx1 = tx2 = x1 = x2 = xLineValue;
ty1 = yTickStart;
ty2 = yTickEnd;
y1 = chartArea.top;
y2 = chartArea.bottom;
} else {
var isLeft = options.position === 'left';
var labelXOffset;
if (optionTicks.mirror) {
textAlign = isLeft ? 'left' : 'right';
labelXOffset = tickPadding;
} else {
textAlign = isLeft ? 'right' : 'left';
labelXOffset = tl + tickPadding;
}
labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
if (yLineValue < me.top) {
lineColor = 'rgba(0,0,0,0)';
}
yLineValue += helpers.aliasPixel(lineWidth);
labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
tx1 = xTickStart;
tx2 = xTickEnd;
x1 = chartArea.left;
x2 = chartArea.right;
ty1 = ty2 = y1 = y2 = yLineValue;
}
itemsToDraw.push({
tx1: tx1,
ty1: ty1,
tx2: tx2,
ty2: ty2,
x1: x1,
y1: y1,
x2: x2,
y2: y2,
labelX: labelX,
labelY: labelY,
glWidth: lineWidth,
glColor: lineColor,
glBorderDash: borderDash,
glBorderDashOffset: borderDashOffset,
rotation: -1 * labelRotationRadians,
label: label,
major: tick.major,
textBaseline: textBaseline,
textAlign: textAlign
});
});
helpers.each(itemsToDraw, function (itemToDraw) {
if (gridLines.display) {
context.save();
context.lineWidth = itemToDraw.glWidth;
context.strokeStyle = itemToDraw.glColor;
if (context.setLineDash) {
context.setLineDash(itemToDraw.glBorderDash);
context.lineDashOffset = itemToDraw.glBorderDashOffset;
}
context.beginPath();
if (gridLines.drawTicks) {
context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
}
if (gridLines.drawOnChartArea) {
context.moveTo(itemToDraw.x1, itemToDraw.y1);
context.lineTo(itemToDraw.x2, itemToDraw.y2);
}
context.stroke();
context.restore();
}
if (optionTicks.display) {
context.save();
context.translate(itemToDraw.labelX, itemToDraw.labelY);
context.rotate(itemToDraw.rotation);
context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
context.textBaseline = itemToDraw.textBaseline;
context.textAlign = itemToDraw.textAlign;
var label = itemToDraw.label;
if (helpers.isArray(label)) {
for (var i = 0, y = 0; i < label.length; ++i) {
context.fillText('' + label[i], 0, y);
y += tickFont.size * 1.5;
}
} else {
context.fillText(label, 0, 0);
}
context.restore();
}
});
if (scaleLabel.display) {
var scaleLabelX;
var scaleLabelY;
var rotation = 0;
var halfLineHeight = parseLineHeight(scaleLabel) / 2;
if (isHorizontal) {
scaleLabelX = me.left + (me.right - me.left) / 2;
scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
} else {
var isLeft = options.position === 'left';
scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
scaleLabelY = me.top + (me.bottom - me.top) / 2;
rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
}
context.save();
context.translate(scaleLabelX, scaleLabelY);
context.rotate(rotation);
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillStyle = scaleLabelFontColor;
context.font = scaleLabelFont.font;
context.fillText(scaleLabel.labelString, 0, 0);
context.restore();
}
if (gridLines.drawBorder) {
context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
var x1 = me.left;
var x2 = me.right;
var y1 = me.top;
var y2 = me.bottom;
var aliasPixel = helpers.aliasPixel(context.lineWidth);
if (isHorizontal) {
y1 = y2 = options.position === 'top' ? me.bottom : me.top;
y1 += aliasPixel;
y2 += aliasPixel;
} else {
x1 = x2 = options.position === 'left' ? me.right : me.left;
x1 += aliasPixel;
x2 += aliasPixel;
}
context.beginPath();
context.moveTo(x1, y1);
context.lineTo(x2, y2);
context.stroke();
}
}
});
};
},
{
'25': 25,
'26': 26,
'34': 34,
'45': 45
}
],
33: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var helpers = require(45);
module.exports = function (Chart) {
Chart.scaleService = {
constructors: {},
defaults: {},
registerScaleType: function (type, scaleConstructor, scaleDefaults) {
this.constructors[type] = scaleConstructor;
this.defaults[type] = helpers.clone(scaleDefaults);
},
getScaleConstructor: function (type) {
return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
},
getScaleDefaults: function (type) {
return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [
defaults.scale,
this.defaults[type]
]) : {};
},
updateScaleDefaults: function (type, additions) {
var me = this;
if (me.defaults.hasOwnProperty(type)) {
me.defaults[type] = helpers.extend(me.defaults[type], additions);
}
},
addScalesToLayout: function (chart) {
helpers.each(chart.scales, function (scale) {
scale.fullWidth = scale.options.fullWidth;
scale.position = scale.options.position;
scale.weight = scale.options.weight;
Chart.layoutService.addBox(chart, scale);
});
}
};
};
},
{
'25': 25,
'45': 45
}
],
34: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
module.exports = {
generators: {
linear: function (generationOptions, dataRange) {
var ticks = [];
var spacing;
if (generationOptions.stepSize && generationOptions.stepSize > 0) {
spacing = generationOptions.stepSize;
} else {
var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
}
var niceMin = Math.floor(dataRange.min / spacing) * spacing;
var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
niceMin = generationOptions.min;
niceMax = generationOptions.max;
}
}
var numSpaces = (niceMax - niceMin) / spacing;
if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
numSpaces = Math.round(numSpaces);
} else {
numSpaces = Math.ceil(numSpaces);
}
ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
for (var j = 1; j < numSpaces; ++j) {
ticks.push(niceMin + j * spacing);
}
ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
return ticks;
},
logarithmic: function (generationOptions, dataRange) {
var ticks = [];
var valueOrDefault = helpers.valueOrDefault;
var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
var endExp = Math.floor(helpers.log10(dataRange.max));
var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
var exp, significand;
if (tickVal === 0) {
exp = Math.floor(helpers.log10(dataRange.minNotZero));
significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
ticks.push(tickVal);
tickVal = significand * Math.pow(10, exp);
} else {
exp = Math.floor(helpers.log10(tickVal));
significand = Math.floor(tickVal / Math.pow(10, exp));
}
do {
ticks.push(tickVal);
++significand;
if (significand === 10) {
significand = 1;
++exp;
}
tickVal = significand * Math.pow(10, exp);
} while (exp < endExp || exp === endExp && significand < endSignificand);
var lastTick = valueOrDefault(generationOptions.max, tickVal);
ticks.push(lastTick);
return ticks;
}
},
formatters: {
values: function (value) {
return helpers.isArray(value) ? value : '' + value;
},
linear: function (tickValue, index, ticks) {
var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
if (Math.abs(delta) > 1) {
if (tickValue !== Math.floor(tickValue)) {
delta = tickValue - Math.floor(tickValue);
}
}
var logDelta = helpers.log10(Math.abs(delta));
var tickString = '';
if (tickValue !== 0) {
var numDecimal = -1 * Math.floor(logDelta);
numDecimal = Math.max(Math.min(numDecimal, 20), 0);
tickString = tickValue.toFixed(numDecimal);
} else {
tickString = '0';
}
return tickString;
},
logarithmic: function (tickValue, index, ticks) {
var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));
if (tickValue === 0) {
return '0';
} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
return tickValue.toExponential();
}
return '';
}
}
};
},
{ '45': 45 }
],
35: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
tooltips: {
enabled: true,
custom: null,
mode: 'nearest',
position: 'average',
intersect: true,
backgroundColor: 'rgba(0,0,0,0.8)',
titleFontStyle: 'bold',
titleSpacing: 2,
titleMarginBottom: 6,
titleFontColor: '#fff',
titleAlign: 'left',
bodySpacing: 2,
bodyFontColor: '#fff',
bodyAlign: 'left',
footerFontStyle: 'bold',
footerSpacing: 2,
footerMarginTop: 6,
footerFontColor: '#fff',
footerAlign: 'left',
yPadding: 6,
xPadding: 6,
caretPadding: 2,
caretSize: 5,
cornerRadius: 6,
multiKeyBackground: '#fff',
displayColors: true,
borderColor: 'rgba(0,0,0,0)',
borderWidth: 0,
callbacks: {
beforeTitle: helpers.noop,
title: function (tooltipItems, data) {
var title = '';
var labels = data.labels;
var labelCount = labels ? labels.length : 0;
if (tooltipItems.length > 0) {
var item = tooltipItems[0];
if (item.xLabel) {
title = item.xLabel;
} else if (labelCount > 0 && item.index < labelCount) {
title = labels[item.index];
}
}
return title;
},
afterTitle: helpers.noop,
beforeBody: helpers.noop,
beforeLabel: helpers.noop,
label: function (tooltipItem, data) {
var label = data.datasets[tooltipItem.datasetIndex].label || '';
if (label) {
label += ': ';
}
label += tooltipItem.yLabel;
return label;
},
labelColor: function (tooltipItem, chart) {
var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
var activeElement = meta.data[tooltipItem.index];
var view = activeElement._view;
return {
borderColor: view.borderColor,
backgroundColor: view.backgroundColor
};
},
labelTextColor: function () {
return this._options.bodyFontColor;
},
afterLabel: helpers.noop,
afterBody: helpers.noop,
beforeFooter: helpers.noop,
footer: helpers.noop,
afterFooter: helpers.noop
}
}
});
module.exports = function (Chart) {
function mergeOpacity(colorString, opacity) {
var color = helpers.color(colorString);
return color.alpha(opacity * color.alpha()).rgbaString();
}
function pushOrConcat(base, toPush) {
if (toPush) {
if (helpers.isArray(toPush)) {
Array.prototype.push.apply(base, toPush);
} else {
base.push(toPush);
}
}
return base;
}
function createTooltipItem(element) {
var xScale = element._xScale;
var yScale = element._yScale || element._scale;
var index = element._index;
var datasetIndex = element._datasetIndex;
return {
xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
index: index,
datasetIndex: datasetIndex,
x: element._model.x,
y: element._model.y
};
}
function getBaseModel(tooltipOpts) {
var globalDefaults = defaults.global;
var valueOrDefault = helpers.valueOrDefault;
return {
xPadding: tooltipOpts.xPadding,
yPadding: tooltipOpts.yPadding,
xAlign: tooltipOpts.xAlign,
yAlign: tooltipOpts.yAlign,
bodyFontColor: tooltipOpts.bodyFontColor,
_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
_bodyAlign: tooltipOpts.bodyAlign,
bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
bodySpacing: tooltipOpts.bodySpacing,
titleFontColor: tooltipOpts.titleFontColor,
_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
_titleAlign: tooltipOpts.titleAlign,
titleSpacing: tooltipOpts.titleSpacing,
titleMarginBottom: tooltipOpts.titleMarginBottom,
footerFontColor: tooltipOpts.footerFontColor,
_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
_footerAlign: tooltipOpts.footerAlign,
footerSpacing: tooltipOpts.footerSpacing,
footerMarginTop: tooltipOpts.footerMarginTop,
caretSize: tooltipOpts.caretSize,
cornerRadius: tooltipOpts.cornerRadius,
backgroundColor: tooltipOpts.backgroundColor,
opacity: 0,
legendColorBackground: tooltipOpts.multiKeyBackground,
displayColors: tooltipOpts.displayColors,
borderColor: tooltipOpts.borderColor,
borderWidth: tooltipOpts.borderWidth
};
}
function getTooltipSize(tooltip, model) {
var ctx = tooltip._chart.ctx;
var height = model.yPadding * 2;
var width = 0;
var body = model.body;
var combinedBodyLength = body.reduce(function (count, bodyItem) {
return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
}, 0);
combinedBodyLength += model.beforeBody.length + model.afterBody.length;
var titleLineCount = model.title.length;
var footerLineCount = model.footer.length;
var titleFontSize = model.titleFontSize;
var bodyFontSize = model.bodyFontSize;
var footerFontSize = model.footerFontSize;
height += titleLineCount * titleFontSize;
height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
height += titleLineCount ? model.titleMarginBottom : 0;
height += combinedBodyLength * bodyFontSize;
height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
height += footerLineCount ? model.footerMarginTop : 0;
height += footerLineCount * footerFontSize;
height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
var widthPadding = 0;
var maxLineWidth = function (line) {
width = Math.max(width, ctx.measureText(line).width + widthPadding);
};
ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
helpers.each(model.title, maxLineWidth);
ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
helpers.each(body, function (bodyItem) {
helpers.each(bodyItem.before, maxLineWidth);
helpers.each(bodyItem.lines, maxLineWidth);
helpers.each(bodyItem.after, maxLineWidth);
});
widthPadding = 0;
ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
helpers.each(model.footer, maxLineWidth);
width += 2 * model.xPadding;
return {
width: width,
height: height
};
}
function determineAlignment(tooltip, size) {
var model = tooltip._model;
var chart = tooltip._chart;
var chartArea = tooltip._chart.chartArea;
var xAlign = 'center';
var yAlign = 'center';
if (model.y < size.height) {
yAlign = 'top';
} else if (model.y > chart.height - size.height) {
yAlign = 'bottom';
}
var lf, rf;
var olf, orf;
var yf;
var midX = (chartArea.left + chartArea.right) / 2;
var midY = (chartArea.top + chartArea.bottom) / 2;
if (yAlign === 'center') {
lf = function (x) {
return x <= midX;
};
rf = function (x) {
return x > midX;
};
} else {
lf = function (x) {
return x <= size.width / 2;
};
rf = function (x) {
return x >= chart.width - size.width / 2;
};
}
olf = function (x) {
return x + size.width > chart.width;
};
orf = function (x) {
return x - size.width < 0;
};
yf = function (y) {
return y <= midY ? 'top' : 'bottom';
};
if (lf(model.x)) {
xAlign = 'left';
if (olf(model.x)) {
xAlign = 'center';
yAlign = yf(model.y);
}
} else if (rf(model.x)) {
xAlign = 'right';
if (orf(model.x)) {
xAlign = 'center';
yAlign = yf(model.y);
}
}
var opts = tooltip._options;
return {
xAlign: opts.xAlign ? opts.xAlign : xAlign,
yAlign: opts.yAlign ? opts.yAlign : yAlign
};
}
function getBackgroundPoint(vm, size, alignment) {
var x = vm.x;
var y = vm.y;
var caretSize = vm.caretSize;
var caretPadding = vm.caretPadding;
var cornerRadius = vm.cornerRadius;
var xAlign = alignment.xAlign;
var yAlign = alignment.yAlign;
var paddingAndSize = caretSize + caretPadding;
var radiusAndPadding = cornerRadius + caretPadding;
if (xAlign === 'right') {
x -= size.width;
} else if (xAlign === 'center') {
x -= size.width / 2;
}
if (yAlign === 'top') {
y += paddingAndSize;
} else if (yAlign === 'bottom') {
y -= size.height + paddingAndSize;
} else {
y -= size.height / 2;
}
if (yAlign === 'center') {
if (xAlign === 'left') {
x += paddingAndSize;
} else if (xAlign === 'right') {
x -= paddingAndSize;
}
} else if (xAlign === 'left') {
x -= radiusAndPadding;
} else if (xAlign === 'right') {
x += radiusAndPadding;
}
return {
x: x,
y: y
};
}
Chart.Tooltip = Element.extend({
initialize: function () {
this._model = getBaseModel(this._options);
this._lastActive = [];
},
getTitle: function () {
var me = this;
var opts = me._options;
var callbacks = opts.callbacks;
var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
var title = callbacks.title.apply(me, arguments);
var afterTitle = callbacks.afterTitle.apply(me, arguments);
var lines = [];
lines = pushOrConcat(lines, beforeTitle);
lines = pushOrConcat(lines, title);
lines = pushOrConcat(lines, afterTitle);
return lines;
},
getBeforeBody: function () {
var lines = this._options.callbacks.beforeBody.apply(this, arguments);
return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
},
getBody: function (tooltipItems, data) {
var me = this;
var callbacks = me._options.callbacks;
var bodyItems = [];
helpers.each(tooltipItems, function (tooltipItem) {
var bodyItem = {
before: [],
lines: [],
after: []
};
pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
bodyItems.push(bodyItem);
});
return bodyItems;
},
getAfterBody: function () {
var lines = this._options.callbacks.afterBody.apply(this, arguments);
return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
},
getFooter: function () {
var me = this;
var callbacks = me._options.callbacks;
var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
var footer = callbacks.footer.apply(me, arguments);
var afterFooter = callbacks.afterFooter.apply(me, arguments);
var lines = [];
lines = pushOrConcat(lines, beforeFooter);
lines = pushOrConcat(lines, footer);
lines = pushOrConcat(lines, afterFooter);
return lines;
},
update: function (changed) {
var me = this;
var opts = me._options;
var existingModel = me._model;
var model = me._model = getBaseModel(opts);
var active = me._active;
var data = me._data;
var alignment = {
xAlign: existingModel.xAlign,
yAlign: existingModel.yAlign
};
var backgroundPoint = {
x: existingModel.x,
y: existingModel.y
};
var tooltipSize = {
width: existingModel.width,
height: existingModel.height
};
var tooltipPosition = {
x: existingModel.caretX,
y: existingModel.caretY
};
var i, len;
if (active.length) {
model.opacity = 1;
var labelColors = [];
var labelTextColors = [];
tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);
var tooltipItems = [];
for (i = 0, len = active.length; i < len; ++i) {
tooltipItems.push(createTooltipItem(active[i]));
}
if (opts.filter) {
tooltipItems = tooltipItems.filter(function (a) {
return opts.filter(a, data);
});
}
if (opts.itemSort) {
tooltipItems = tooltipItems.sort(function (a, b) {
return opts.itemSort(a, b, data);
});
}
helpers.each(tooltipItems, function (tooltipItem) {
labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
});
model.title = me.getTitle(tooltipItems, data);
model.beforeBody = me.getBeforeBody(tooltipItems, data);
model.body = me.getBody(tooltipItems, data);
model.afterBody = me.getAfterBody(tooltipItems, data);
model.footer = me.getFooter(tooltipItems, data);
model.x = Math.round(tooltipPosition.x);
model.y = Math.round(tooltipPosition.y);
model.caretPadding = opts.caretPadding;
model.labelColors = labelColors;
model.labelTextColors = labelTextColors;
model.dataPoints = tooltipItems;
tooltipSize = getTooltipSize(this, model);
alignment = determineAlignment(this, tooltipSize);
backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
} else {
model.opacity = 0;
}
model.xAlign = alignment.xAlign;
model.yAlign = alignment.yAlign;
model.x = backgroundPoint.x;
model.y = backgroundPoint.y;
model.width = tooltipSize.width;
model.height = tooltipSize.height;
model.caretX = tooltipPosition.x;
model.caretY = tooltipPosition.y;
me._model = model;
if (changed && opts.custom) {
opts.custom.call(me, model);
}
return me;
},
drawCaret: function (tooltipPoint, size) {
var ctx = this._chart.ctx;
var vm = this._view;
var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
ctx.lineTo(caretPosition.x1, caretPosition.y1);
ctx.lineTo(caretPosition.x2, caretPosition.y2);
ctx.lineTo(caretPosition.x3, caretPosition.y3);
},
getCaretPosition: function (tooltipPoint, size, vm) {
var x1, x2, x3, y1, y2, y3;
var caretSize = vm.caretSize;
var cornerRadius = vm.cornerRadius;
var xAlign = vm.xAlign;
var yAlign = vm.yAlign;
var ptX = tooltipPoint.x;
var ptY = tooltipPoint.y;
var width = size.width;
var height = size.height;
if (yAlign === 'center') {
y2 = ptY + height / 2;
if (xAlign === 'left') {
x1 = ptX;
x2 = x1 - caretSize;
x3 = x1;
y1 = y2 + caretSize;
y3 = y2 - caretSize;
} else {
x1 = ptX + width;
x2 = x1 + caretSize;
x3 = x1;
y1 = y2 - caretSize;
y3 = y2 + caretSize;
}
} else {
if (xAlign === 'left') {
x2 = ptX + cornerRadius + caretSize;
x1 = x2 - caretSize;
x3 = x2 + caretSize;
} else if (xAlign === 'right') {
x2 = ptX + width - cornerRadius - caretSize;
x1 = x2 - caretSize;
x3 = x2 + caretSize;
} else {
x2 = ptX + width / 2;
x1 = x2 - caretSize;
x3 = x2 + caretSize;
}
if (yAlign === 'top') {
y1 = ptY;
y2 = y1 - caretSize;
y3 = y1;
} else {
y1 = ptY + height;
y2 = y1 + caretSize;
y3 = y1;
var tmp = x3;
x3 = x1;
x1 = tmp;
}
}
return {
x1: x1,
x2: x2,
x3: x3,
y1: y1,
y2: y2,
y3: y3
};
},
drawTitle: function (pt, vm, ctx, opacity) {
var title = vm.title;
if (title.length) {
ctx.textAlign = vm._titleAlign;
ctx.textBaseline = 'top';
var titleFontSize = vm.titleFontSize;
var titleSpacing = vm.titleSpacing;
ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
var i, len;
for (i = 0, len = title.length; i < len; ++i) {
ctx.fillText(title[i], pt.x, pt.y);
pt.y += titleFontSize + titleSpacing;
if (i + 1 === title.length) {
pt.y += vm.titleMarginBottom - titleSpacing;
}
}
}
},
drawBody: function (pt, vm, ctx, opacity) {
var bodyFontSize = vm.bodyFontSize;
var bodySpacing = vm.bodySpacing;
var body = vm.body;
ctx.textAlign = vm._bodyAlign;
ctx.textBaseline = 'top';
ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
var xLinePadding = 0;
var fillLineOfText = function (line) {
ctx.fillText(line, pt.x + xLinePadding, pt.y);
pt.y += bodyFontSize + bodySpacing;
};
ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
helpers.each(vm.beforeBody, fillLineOfText);
var drawColorBoxes = vm.displayColors;
xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;
helpers.each(body, function (bodyItem, i) {
var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
ctx.fillStyle = textColor;
helpers.each(bodyItem.before, fillLineOfText);
helpers.each(bodyItem.lines, function (line) {
if (drawColorBoxes) {
ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
ctx.lineWidth = 1;
ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
ctx.fillStyle = textColor;
}
fillLineOfText(line);
});
helpers.each(bodyItem.after, fillLineOfText);
});
xLinePadding = 0;
helpers.each(vm.afterBody, fillLineOfText);
pt.y -= bodySpacing;
},
drawFooter: function (pt, vm, ctx, opacity) {
var footer = vm.footer;
if (footer.length) {
pt.y += vm.footerMarginTop;
ctx.textAlign = vm._footerAlign;
ctx.textBaseline = 'top';
ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
helpers.each(footer, function (line) {
ctx.fillText(line, pt.x, pt.y);
pt.y += vm.footerFontSize + vm.footerSpacing;
});
}
},
drawBackground: function (pt, vm, ctx, tooltipSize, opacity) {
ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
ctx.lineWidth = vm.borderWidth;
var xAlign = vm.xAlign;
var yAlign = vm.yAlign;
var x = pt.x;
var y = pt.y;
var width = tooltipSize.width;
var height = tooltipSize.height;
var radius = vm.cornerRadius;
ctx.beginPath();
ctx.moveTo(x + radius, y);
if (yAlign === 'top') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + width - radius, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
if (yAlign === 'center' && xAlign === 'right') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + width, y + height - radius);
ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
if (yAlign === 'bottom') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + radius, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
if (yAlign === 'center' && xAlign === 'left') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x, y + radius);
ctx.quadraticCurveTo(x, y, x + radius, y);
ctx.closePath();
ctx.fill();
if (vm.borderWidth > 0) {
ctx.stroke();
}
},
draw: function () {
var ctx = this._chart.ctx;
var vm = this._view;
if (vm.opacity === 0) {
return;
}
var tooltipSize = {
width: vm.width,
height: vm.height
};
var pt = {
x: vm.x,
y: vm.y
};
var opacity = Math.abs(vm.opacity < 0.001) ? 0 : vm.opacity;
var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
if (this._options.enabled && hasTooltipContent) {
this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
pt.x += vm.xPadding;
pt.y += vm.yPadding;
this.drawTitle(pt, vm, ctx, opacity);
this.drawBody(pt, vm, ctx, opacity);
this.drawFooter(pt, vm, ctx, opacity);
}
},
handleEvent: function (e) {
var me = this;
var options = me._options;
var changed = false;
me._lastActive = me._lastActive || [];
if (e.type === 'mouseout') {
me._active = [];
} else {
me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
}
changed = !helpers.arrayEquals(me._active, me._lastActive);
if (!changed) {
return false;
}
me._lastActive = me._active;
if (options.enabled || options.custom) {
me._eventPosition = {
x: e.x,
y: e.y
};
var model = me._model;
me.update(true);
me.pivot();
changed |= model.x !== me._model.x || model.y !== me._model.y;
}
return changed;
}
});
Chart.Tooltip.positioners = {
average: function (elements) {
if (!elements.length) {
return false;
}
var i, len;
var x = 0;
var y = 0;
var count = 0;
for (i = 0, len = elements.length; i < len; ++i) {
var el = elements[i];
if (el && el.hasValue()) {
var pos = el.tooltipPosition();
x += pos.x;
y += pos.y;
++count;
}
}
return {
x: Math.round(x / count),
y: Math.round(y / count)
};
},
nearest: function (elements, eventPosition) {
var x = eventPosition.x;
var y = eventPosition.y;
var minDistance = Number.POSITIVE_INFINITY;
var i, len, nearestElement;
for (i = 0, len = elements.length; i < len; ++i) {
var el = elements[i];
if (el && el.hasValue()) {
var center = el.getCenterPoint();
var d = helpers.distanceBetweenPoints(eventPosition, center);
if (d < minDistance) {
minDistance = d;
nearestElement = el;
}
}
}
if (nearestElement) {
var tp = nearestElement.tooltipPosition();
x = tp.x;
y = tp.y;
}
return {
x: x,
y: y
};
}
};
};
},
{
'25': 25,
'26': 26,
'45': 45
}
],
36: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
elements: {
arc: {
backgroundColor: defaults.global.defaultColor,
borderColor: '#fff',
borderWidth: 2
}
}
});
module.exports = Element.extend({
inLabelRange: function (mouseX) {
var vm = this._view;
if (vm) {
return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
}
return false;
},
inRange: function (chartX, chartY) {
var vm = this._view;
if (vm) {
var pointRelativePosition = helpers.getAngleFromPoint(vm, {
x: chartX,
y: chartY
});
var angle = pointRelativePosition.angle;
var distance = pointRelativePosition.distance;
var startAngle = vm.startAngle;
var endAngle = vm.endAngle;
while (endAngle < startAngle) {
endAngle += 2 * Math.PI;
}
while (angle > endAngle) {
angle -= 2 * Math.PI;
}
while (angle < startAngle) {
angle += 2 * Math.PI;
}
var betweenAngles = angle >= startAngle && angle <= endAngle;
var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
return betweenAngles && withinRadius;
}
return false;
},
getCenterPoint: function () {
var vm = this._view;
var halfAngle = (vm.startAngle + vm.endAngle) / 2;
var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
return {
x: vm.x + Math.cos(halfAngle) * halfRadius,
y: vm.y + Math.sin(halfAngle) * halfRadius
};
},
getArea: function () {
var vm = this._view;
return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
},
tooltipPosition: function () {
var vm = this._view;
var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
return {
x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
y: vm.y + Math.sin(centreAngle) * rangeFromCentre
};
},
draw: function () {
var ctx = this._chart.ctx;
var vm = this._view;
var sA = vm.startAngle;
var eA = vm.endAngle;
ctx.beginPath();
ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
ctx.closePath();
ctx.strokeStyle = vm.borderColor;
ctx.lineWidth = vm.borderWidth;
ctx.fillStyle = vm.backgroundColor;
ctx.fill();
ctx.lineJoin = 'bevel';
if (vm.borderWidth) {
ctx.stroke();
}
}
});
},
{
'25': 25,
'26': 26,
'45': 45
}
],
37: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var globalDefaults = defaults.global;
defaults._set('global', {
elements: {
line: {
tension: 0.4,
backgroundColor: globalDefaults.defaultColor,
borderWidth: 3,
borderColor: globalDefaults.defaultColor,
borderCapStyle: 'butt',
borderDash: [],
borderDashOffset: 0,
borderJoinStyle: 'miter',
capBezierPoints: true,
fill: true
}
}
});
module.exports = Element.extend({
draw: function () {
var me = this;
var vm = me._view;
var ctx = me._chart.ctx;
var spanGaps = vm.spanGaps;
var points = me._children.slice();
var globalOptionLineElements = globalDefaults.elements.line;
var lastDrawnIndex = -1;
var index, current, previous, currentVM;
if (me._loop && points.length) {
points.push(points[0]);
}
ctx.save();
ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
if (ctx.setLineDash) {
ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
}
ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
ctx.beginPath();
lastDrawnIndex = -1;
for (index = 0; index < points.length; ++index) {
current = points[index];
previous = helpers.previousItem(points, index);
currentVM = current._view;
if (index === 0) {
if (!currentVM.skip) {
ctx.moveTo(currentVM.x, currentVM.y);
lastDrawnIndex = index;
}
} else {
previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
if (!currentVM.skip) {
if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
ctx.moveTo(currentVM.x, currentVM.y);
} else {
helpers.canvas.lineTo(ctx, previous._view, current._view);
}
lastDrawnIndex = index;
}
}
}
ctx.stroke();
ctx.restore();
}
});
},
{
'25': 25,
'26': 26,
'45': 45
}
],
38: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var defaultColor = defaults.global.defaultColor;
defaults._set('global', {
elements: {
point: {
radius: 3,
pointStyle: 'circle',
backgroundColor: defaultColor,
borderColor: defaultColor,
borderWidth: 1,
hitRadius: 1,
hoverRadius: 4,
hoverBorderWidth: 1
}
}
});
function xRange(mouseX) {
var vm = this._view;
return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
}
function yRange(mouseY) {
var vm = this._view;
return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
}
module.exports = Element.extend({
inRange: function (mouseX, mouseY) {
var vm = this._view;
return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
},
inLabelRange: xRange,
inXRange: xRange,
inYRange: yRange,
getCenterPoint: function () {
var vm = this._view;
return {
x: vm.x,
y: vm.y
};
},
getArea: function () {
return Math.PI * Math.pow(this._view.radius, 2);
},
tooltipPosition: function () {
var vm = this._view;
return {
x: vm.x,
y: vm.y,
padding: vm.radius + vm.borderWidth
};
},
draw: function (chartArea) {
var vm = this._view;
var model = this._model;
var ctx = this._chart.ctx;
var pointStyle = vm.pointStyle;
var radius = vm.radius;
var x = vm.x;
var y = vm.y;
var color = helpers.color;
var errMargin = 1.01;
var ratio = 0;
if (vm.skip) {
return;
}
ctx.strokeStyle = vm.borderColor || defaultColor;
ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
ctx.fillStyle = vm.backgroundColor || defaultColor;
if (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
if (model.x < chartArea.left) {
ratio = (x - model.x) / (chartArea.left - model.x);
} else if (chartArea.right * errMargin < model.x) {
ratio = (model.x - x) / (model.x - chartArea.right);
} else if (model.y < chartArea.top) {
ratio = (y - model.y) / (chartArea.top - model.y);
} else if (chartArea.bottom * errMargin < model.y) {
ratio = (model.y - y) / (model.y - chartArea.bottom);
}
ratio = Math.round(ratio * 100) / 100;
ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
}
helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
}
});
},
{
'25': 25,
'26': 26,
'45': 45
}
],
39: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
defaults._set('global', {
elements: {
rectangle: {
backgroundColor: defaults.global.defaultColor,
borderColor: defaults.global.defaultColor,
borderSkipped: 'bottom',
borderWidth: 0
}
}
});
function isVertical(bar) {
return bar._view.width !== undefined;
}
function getBarBounds(bar) {
var vm = bar._view;
var x1, x2, y1, y2;
if (isVertical(bar)) {
var halfWidth = vm.width / 2;
x1 = vm.x - halfWidth;
x2 = vm.x + halfWidth;
y1 = Math.min(vm.y, vm.base);
y2 = Math.max(vm.y, vm.base);
} else {
var halfHeight = vm.height / 2;
x1 = Math.min(vm.x, vm.base);
x2 = Math.max(vm.x, vm.base);
y1 = vm.y - halfHeight;
y2 = vm.y + halfHeight;
}
return {
left: x1,
top: y1,
right: x2,
bottom: y2
};
}
module.exports = Element.extend({
draw: function () {
var ctx = this._chart.ctx;
var vm = this._view;
var left, right, top, bottom, signX, signY, borderSkipped;
var borderWidth = vm.borderWidth;
if (!vm.horizontal) {
left = vm.x - vm.width / 2;
right = vm.x + vm.width / 2;
top = vm.y;
bottom = vm.base;
signX = 1;
signY = bottom > top ? 1 : -1;
borderSkipped = vm.borderSkipped || 'bottom';
} else {
left = vm.base;
right = vm.x;
top = vm.y - vm.height / 2;
bottom = vm.y + vm.height / 2;
signX = right > left ? 1 : -1;
signY = 1;
borderSkipped = vm.borderSkipped || 'left';
}
if (borderWidth) {
var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
borderWidth = borderWidth > barSize ? barSize : borderWidth;
var halfStroke = borderWidth / 2;
var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
if (borderLeft !== borderRight) {
top = borderTop;
bottom = borderBottom;
}
if (borderTop !== borderBottom) {
left = borderLeft;
right = borderRight;
}
}
ctx.beginPath();
ctx.fillStyle = vm.backgroundColor;
ctx.strokeStyle = vm.borderColor;
ctx.lineWidth = borderWidth;
var corners = [
[
left,
bottom
],
[
left,
top
],
[
right,
top
],
[
right,
bottom
]
];
var borders = [
'bottom',
'left',
'top',
'right'
];
var startCorner = borders.indexOf(borderSkipped, 0);
if (startCorner === -1) {
startCorner = 0;
}
function cornerAt(index) {
return corners[(startCorner + index) % 4];
}
var corner = cornerAt(0);
ctx.moveTo(corner[0], corner[1]);
for (var i = 1; i < 4; i++) {
corner = cornerAt(i);
ctx.lineTo(corner[0], corner[1]);
}
ctx.fill();
if (borderWidth) {
ctx.stroke();
}
},
height: function () {
var vm = this._view;
return vm.base - vm.y;
},
inRange: function (mouseX, mouseY) {
var inRange = false;
if (this._view) {
var bounds = getBarBounds(this);
inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
}
return inRange;
},
inLabelRange: function (mouseX, mouseY) {
var me = this;
if (!me._view) {
return false;
}
var inRange = false;
var bounds = getBarBounds(me);
if (isVertical(me)) {
inRange = mouseX >= bounds.left && mouseX <= bounds.right;
} else {
inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
}
return inRange;
},
inXRange: function (mouseX) {
var bounds = getBarBounds(this);
return mouseX >= bounds.left && mouseX <= bounds.right;
},
inYRange: function (mouseY) {
var bounds = getBarBounds(this);
return mouseY >= bounds.top && mouseY <= bounds.bottom;
},
getCenterPoint: function () {
var vm = this._view;
var x, y;
if (isVertical(this)) {
x = vm.x;
y = (vm.y + vm.base) / 2;
} else {
x = (vm.x + vm.base) / 2;
y = vm.y;
}
return {
x: x,
y: y
};
},
getArea: function () {
var vm = this._view;
return vm.width * Math.abs(vm.y - vm.base);
},
tooltipPosition: function () {
var vm = this._view;
return {
x: vm.x,
y: vm.y
};
}
});
},
{
'25': 25,
'26': 26
}
],
40: [
function (require, module, exports) {
'use strict';
module.exports = {};
module.exports.Arc = require(36);
module.exports.Line = require(37);
module.exports.Point = require(38);
module.exports.Rectangle = require(39);
},
{
'36': 36,
'37': 37,
'38': 38,
'39': 39
}
],
41: [
function (require, module, exports) {
'use strict';
var helpers = require(42);
var exports = module.exports = {
clear: function (chart) {
chart.ctx.clearRect(0, 0, chart.width, chart.height);
},
roundedRect: function (ctx, x, y, width, height, radius) {
if (radius) {
var rx = Math.min(radius, width / 2);
var ry = Math.min(radius, height / 2);
ctx.moveTo(x + rx, y);
ctx.lineTo(x + width - rx, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
ctx.lineTo(x + width, y + height - ry);
ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
ctx.lineTo(x + rx, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
ctx.lineTo(x, y + ry);
ctx.quadraticCurveTo(x, y, x + rx, y);
} else {
ctx.rect(x, y, width, height);
}
},
drawPoint: function (ctx, style, radius, x, y) {
var type, edgeLength, xOffset, yOffset, height, size;
if (style && typeof style === 'object') {
type = style.toString();
if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
return;
}
}
if (isNaN(radius) || radius <= 0) {
return;
}
switch (style) {
default:
ctx.beginPath();
ctx.arc(x, y, radius, 0, Math.PI * 2);
ctx.closePath();
ctx.fill();
break;
case 'triangle':
ctx.beginPath();
edgeLength = 3 * radius / Math.sqrt(3);
height = edgeLength * Math.sqrt(3) / 2;
ctx.moveTo(x - edgeLength / 2, y + height / 3);
ctx.lineTo(x + edgeLength / 2, y + height / 3);
ctx.lineTo(x, y - 2 * height / 3);
ctx.closePath();
ctx.fill();
break;
case 'rect':
size = 1 / Math.SQRT2 * radius;
ctx.beginPath();
ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
break;
case 'rectRounded':
var offset = radius / Math.SQRT2;
var leftX = x - offset;
var topY = y - offset;
var sideSize = Math.SQRT2 * radius;
ctx.beginPath();
this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
ctx.closePath();
ctx.fill();
break;
case 'rectRot':
size = 1 / Math.SQRT2 * radius;
ctx.beginPath();
ctx.moveTo(x - size, y);
ctx.lineTo(x, y + size);
ctx.lineTo(x + size, y);
ctx.lineTo(x, y - size);
ctx.closePath();
ctx.fill();
break;
case 'cross':
ctx.beginPath();
ctx.moveTo(x, y + radius);
ctx.lineTo(x, y - radius);
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
case 'crossRot':
ctx.beginPath();
xOffset = Math.cos(Math.PI / 4) * radius;
yOffset = Math.sin(Math.PI / 4) * radius;
ctx.moveTo(x - xOffset, y - yOffset);
ctx.lineTo(x + xOffset, y + yOffset);
ctx.moveTo(x - xOffset, y + yOffset);
ctx.lineTo(x + xOffset, y - yOffset);
ctx.closePath();
break;
case 'star':
ctx.beginPath();
ctx.moveTo(x, y + radius);
ctx.lineTo(x, y - radius);
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
xOffset = Math.cos(Math.PI / 4) * radius;
yOffset = Math.sin(Math.PI / 4) * radius;
ctx.moveTo(x - xOffset, y - yOffset);
ctx.lineTo(x + xOffset, y + yOffset);
ctx.moveTo(x - xOffset, y + yOffset);
ctx.lineTo(x + xOffset, y - yOffset);
ctx.closePath();
break;
case 'line':
ctx.beginPath();
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
case 'dash':
ctx.beginPath();
ctx.moveTo(x, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
}
ctx.stroke();
},
clipArea: function (ctx, area) {
ctx.save();
ctx.beginPath();
ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
ctx.clip();
},
unclipArea: function (ctx) {
ctx.restore();
},
lineTo: function (ctx, previous, target, flip) {
if (target.steppedLine) {
if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
ctx.lineTo(previous.x, target.y);
} else {
ctx.lineTo(target.x, previous.y);
}
ctx.lineTo(target.x, target.y);
return;
}
if (!target.tension) {
ctx.lineTo(target.x, target.y);
return;
}
ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
}
};
helpers.clear = exports.clear;
helpers.drawRoundedRectangle = function (ctx) {
ctx.beginPath();
exports.roundedRect.apply(exports, arguments);
ctx.closePath();
};
},
{ '42': 42 }
],
42: [
function (require, module, exports) {
'use strict';
var helpers = {
noop: function () {
},
uid: function () {
var id = 0;
return function () {
return id++;
};
}(),
isNullOrUndef: function (value) {
return value === null || typeof value === 'undefined';
},
isArray: Array.isArray ? Array.isArray : function (value) {
return Object.prototype.toString.call(value) === '[object Array]';
},
isObject: function (value) {
return value !== null && Object.prototype.toString.call(value) === '[object Object]';
},
valueOrDefault: function (value, defaultValue) {
return typeof value === 'undefined' ? defaultValue : value;
},
valueAtIndexOrDefault: function (value, index, defaultValue) {
return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
},
callback: function (fn, args, thisArg) {
if (fn && typeof fn.call === 'function') {
return fn.apply(thisArg, args);
}
},
each: function (loopable, fn, thisArg, reverse) {
var i, len, keys;
if (helpers.isArray(loopable)) {
len = loopable.length;
if (reverse) {
for (i = len - 1; i >= 0; i--) {
fn.call(thisArg, loopable[i], i);
}
} else {
for (i = 0; i < len; i++) {
fn.call(thisArg, loopable[i], i);
}
}
} else if (helpers.isObject(loopable)) {
keys = Object.keys(loopable);
len = keys.length;
for (i = 0; i < len; i++) {
fn.call(thisArg, loopable[keys[i]], keys[i]);
}
}
},
arrayEquals: function (a0, a1) {
var i, ilen, v0, v1;
if (!a0 || !a1 || a0.length !== a1.length) {
return false;
}
for (i = 0, ilen = a0.length; i < ilen; ++i) {
v0 = a0[i];
v1 = a1[i];
if (v0 instanceof Array && v1 instanceof Array) {
if (!helpers.arrayEquals(v0, v1)) {
return false;
}
} else if (v0 !== v1) {
return false;
}
}
return true;
},
clone: function (source) {
if (helpers.isArray(source)) {
return source.map(helpers.clone);
}
if (helpers.isObject(source)) {
var target = {};
var keys = Object.keys(source);
var klen = keys.length;
var k = 0;
for (; k < klen; ++k) {
target[keys[k]] = helpers.clone(source[keys[k]]);
}
return target;
}
return source;
},
_merger: function (key, target, source, options) {
var tval = target[key];
var sval = source[key];
if (helpers.isObject(tval) && helpers.isObject(sval)) {
helpers.merge(tval, sval, options);
} else {
target[key] = helpers.clone(sval);
}
},
_mergerIf: function (key, target, source) {
var tval = target[key];
var sval = source[key];
if (helpers.isObject(tval) && helpers.isObject(sval)) {
helpers.mergeIf(tval, sval);
} else if (!target.hasOwnProperty(key)) {
target[key] = helpers.clone(sval);
}
},
merge: function (target, source, options) {
var sources = helpers.isArray(source) ? source : [source];
var ilen = sources.length;
var merge, i, keys, klen, k;
if (!helpers.isObject(target)) {
return target;
}
options = options || {};
merge = options.merger || helpers._merger;
for (i = 0; i < ilen; ++i) {
source = sources[i];
if (!helpers.isObject(source)) {
continue;
}
keys = Object.keys(source);
for (k = 0, klen = keys.length; k < klen; ++k) {
merge(keys[k], target, source, options);
}
}
return target;
},
mergeIf: function (target, source) {
return helpers.merge(target, source, { merger: helpers._mergerIf });
},
extend: function (target) {
var setFn = function (value, key) {
target[key] = value;
};
for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
helpers.each(arguments[i], setFn);
}
return target;
},
inherits: function (extensions) {
var me = this;
var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
return me.apply(this, arguments);
};
var Surrogate = function () {
this.constructor = ChartElement;
};
Surrogate.prototype = me.prototype;
ChartElement.prototype = new Surrogate();
ChartElement.extend = helpers.inherits;
if (extensions) {
helpers.extend(ChartElement.prototype, extensions);
}
ChartElement.__super__ = me.prototype;
return ChartElement;
}
};
module.exports = helpers;
helpers.callCallback = helpers.callback;
helpers.indexOf = function (array, item, fromIndex) {
return Array.prototype.indexOf.call(array, item, fromIndex);
};
helpers.getValueOrDefault = helpers.valueOrDefault;
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
},
{}
],
43: [
function (require, module, exports) {
'use strict';
var helpers = require(42);
var effects = {
linear: function (t) {
return t;
},
easeInQuad: function (t) {
return t * t;
},
easeOutQuad: function (t) {
return -t * (t - 2);
},
easeInOutQuad: function (t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t;
}
return -0.5 * (--t * (t - 2) - 1);
},
easeInCubic: function (t) {
return t * t * t;
},
easeOutCubic: function (t) {
return (t = t - 1) * t * t + 1;
},
easeInOutCubic: function (t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t;
}
return 0.5 * ((t -= 2) * t * t + 2);
},
easeInQuart: function (t) {
return t * t * t * t;
},
easeOutQuart: function (t) {
return -((t = t - 1) * t * t * t - 1);
},
easeInOutQuart: function (t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t * t;
}
return -0.5 * ((t -= 2) * t * t * t - 2);
},
easeInQuint: function (t) {
return t * t * t * t * t;
},
easeOutQuint: function (t) {
return (t = t - 1) * t * t * t * t + 1;
},
easeInOutQuint: function (t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t * t * t;
}
return 0.5 * ((t -= 2) * t * t * t * t + 2);
},
easeInSine: function (t) {
return -Math.cos(t * (Math.PI / 2)) + 1;
},
easeOutSine: function (t) {
return Math.sin(t * (Math.PI / 2));
},
easeInOutSine: function (t) {
return -0.5 * (Math.cos(Math.PI * t) - 1);
},
easeInExpo: function (t) {
return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
},
easeOutExpo: function (t) {
return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
},
easeInOutExpo: function (t) {
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if ((t /= 0.5) < 1) {
return 0.5 * Math.pow(2, 10 * (t - 1));
}
return 0.5 * (-Math.pow(2, -10 * --t) + 2);
},
easeInCirc: function (t) {
if (t >= 1) {
return t;
}
return -(Math.sqrt(1 - t * t) - 1);
},
easeOutCirc: function (t) {
return Math.sqrt(1 - (t = t - 1) * t);
},
easeInOutCirc: function (t) {
if ((t /= 0.5) < 1) {
return -0.5 * (Math.sqrt(1 - t * t) - 1);
}
return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
},
easeInElastic: function (t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if (!p) {
p = 0.3;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
},
easeOutElastic: function (t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if (!p) {
p = 0.3;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
},
easeInOutElastic: function (t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if ((t /= 0.5) === 2) {
return 1;
}
if (!p) {
p = 0.45;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
if (t < 1) {
return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
}
return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
},
easeInBack: function (t) {
var s = 1.70158;
return t * t * ((s + 1) * t - s);
},
easeOutBack: function (t) {
var s = 1.70158;
return (t = t - 1) * t * ((s + 1) * t + s) + 1;
},
easeInOutBack: function (t) {
var s = 1.70158;
if ((t /= 0.5) < 1) {
return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
}
return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
},
easeInBounce: function (t) {
return 1 - effects.easeOutBounce(1 - t);
},
easeOutBounce: function (t) {
if (t < 1 / 2.75) {
return 7.5625 * t * t;
}
if (t < 2 / 2.75) {
return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
}
if (t < 2.5 / 2.75) {
return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
}
return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
},
easeInOutBounce: function (t) {
if (t < 0.5) {
return effects.easeInBounce(t * 2) * 0.5;
}
return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
}
};
module.exports = { effects: effects };
helpers.easingEffects = effects;
},
{ '42': 42 }
],
44: [
function (require, module, exports) {
'use strict';
var helpers = require(42);
module.exports = {
toLineHeight: function (value, size) {
var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
if (!matches || matches[1] === 'normal') {
return size * 1.2;
}
value = +matches[2];
switch (matches[3]) {
case 'px':
return value;
case '%':
value /= 100;
break;
default:
break;
}
return size * value;
},
toPadding: function (value) {
var t, r, b, l;
if (helpers.isObject(value)) {
t = +value.top || 0;
r = +value.right || 0;
b = +value.bottom || 0;
l = +value.left || 0;
} else {
t = r = b = l = +value || 0;
}
return {
top: t,
right: r,
bottom: b,
left: l,
height: t + b,
width: l + r
};
},
resolve: function (inputs, context, index) {
var i, ilen, value;
for (i = 0, ilen = inputs.length; i < ilen; ++i) {
value = inputs[i];
if (value === undefined) {
continue;
}
if (context !== undefined && typeof value === 'function') {
value = value(context);
}
if (index !== undefined && helpers.isArray(value)) {
value = value[index];
}
if (value !== undefined) {
return value;
}
}
}
};
},
{ '42': 42 }
],
45: [
function (require, module, exports) {
'use strict';
module.exports = require(42);
module.exports.easing = require(43);
module.exports.canvas = require(41);
module.exports.options = require(44);
},
{
'41': 41,
'42': 42,
'43': 43,
'44': 44
}
],
46: [
function (require, module, exports) {
module.exports = {
acquireContext: function (item) {
if (item && item.canvas) {
item = item.canvas;
}
return item && item.getContext('2d') || null;
}
};
},
{}
],
47: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = [
'animationstart',
'webkitAnimationStart'
];
var EVENT_TYPES = {
touchstart: 'mousedown',
touchmove: 'mousemove',
touchend: 'mouseup',
pointerenter: 'mouseenter',
pointerdown: 'mousedown',
pointermove: 'mousemove',
pointerup: 'mouseup',
pointerleave: 'mouseout',
pointerout: 'mouseout'
};
function readUsedSize(element, property) {
var value = helpers.getStyle(element, property);
var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
return matches ? Number(matches[1]) : undefined;
}
function initCanvas(canvas, config) {
var style = canvas.style;
var renderHeight = canvas.getAttribute('height');
var renderWidth = canvas.getAttribute('width');
canvas[EXPANDO_KEY] = {
initial: {
height: renderHeight,
width: renderWidth,
style: {
display: style.display,
height: style.height,
width: style.width
}
}
};
style.display = style.display || 'block';
if (renderWidth === null || renderWidth === '') {
var displayWidth = readUsedSize(canvas, 'width');
if (displayWidth !== undefined) {
canvas.width = displayWidth;
}
}
if (renderHeight === null || renderHeight === '') {
if (canvas.style.height === '') {
canvas.height = canvas.width / (config.options.aspectRatio || 2);
} else {
var displayHeight = readUsedSize(canvas, 'height');
if (displayWidth !== undefined) {
canvas.height = displayHeight;
}
}
}
return canvas;
}
var supportsEventListenerOptions = function () {
var supports = false;
try {
var options = Object.defineProperty({}, 'passive', {
get: function () {
supports = true;
}
});
window.addEventListener('e', null, options);
} catch (e) {
}
return supports;
}();
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addEventListener(node, type, listener) {
node.addEventListener(type, listener, eventListenerOptions);
}
function removeEventListener(node, type, listener) {
node.removeEventListener(type, listener, eventListenerOptions);
}
function createEvent(type, chart, x, y, nativeEvent) {
return {
type: type,
chart: chart,
native: nativeEvent || null,
x: x !== undefined ? x : null,
y: y !== undefined ? y : null
};
}
function fromNativeEvent(event, chart) {
var type = EVENT_TYPES[event.type] || event.type;
var pos = helpers.getRelativePosition(event, chart);
return createEvent(type, chart, pos.x, pos.y, event);
}
function throttled(fn, thisArg) {
var ticking = false;
var args = [];
return function () {
args = Array.prototype.slice.call(arguments);
thisArg = thisArg || this;
if (!ticking) {
ticking = true;
helpers.requestAnimFrame.call(window, function () {
ticking = false;
fn.apply(thisArg, args);
});
}
};
}
function createResizer(handler) {
var resizer = document.createElement('div');
var cls = CSS_PREFIX + 'size-monitor';
var maxSize = 1000000;
var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';
resizer.style.cssText = style;
resizer.className = cls;
resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';
var expand = resizer.childNodes[0];
var shrink = resizer.childNodes[1];
resizer._reset = function () {
expand.scrollLeft = maxSize;
expand.scrollTop = maxSize;
shrink.scrollLeft = maxSize;
shrink.scrollTop = maxSize;
};
var onScroll = function () {
resizer._reset();
handler();
};
addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
return resizer;
}
function watchForRender(node, handler) {
var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
var proxy = expando.renderProxy = function (e) {
if (e.animationName === CSS_RENDER_ANIMATION) {
handler();
}
};
helpers.each(ANIMATION_START_EVENTS, function (type) {
addEventListener(node, type, proxy);
});
expando.reflow = !!node.offsetParent;
node.classList.add(CSS_RENDER_MONITOR);
}
function unwatchForRender(node) {
var expando = node[EXPANDO_KEY] || {};
var proxy = expando.renderProxy;
if (proxy) {
helpers.each(ANIMATION_START_EVENTS, function (type) {
removeEventListener(node, type, proxy);
});
delete expando.renderProxy;
}
node.classList.remove(CSS_RENDER_MONITOR);
}
function addResizeListener(node, listener, chart) {
var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
var resizer = expando.resizer = createResizer(throttled(function () {
if (expando.resizer) {
return listener(createEvent('resize', chart));
}
}));
watchForRender(node, function () {
if (expando.resizer) {
var container = node.parentNode;
if (container && container !== resizer.parentNode) {
container.insertBefore(resizer, container.firstChild);
}
resizer._reset();
}
});
}
function removeResizeListener(node) {
var expando = node[EXPANDO_KEY] || {};
var resizer = expando.resizer;
delete expando.resizer;
unwatchForRender(node);
if (resizer && resizer.parentNode) {
resizer.parentNode.removeChild(resizer);
}
}
function injectCSS(platform, css) {
var style = platform._style || document.createElement('style');
if (!platform._style) {
platform._style = style;
css = '/* Chart.js */\n' + css;
style.setAttribute('type', 'text/css');
document.getElementsByTagName('head')[0].appendChild(style);
}
style.appendChild(document.createTextNode(css));
}
module.exports = {
_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
initialize: function () {
var keyframes = 'from{opacity:0.99}to{opacity:1}';
injectCSS(this, '@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
},
acquireContext: function (item, config) {
if (typeof item === 'string') {
item = document.getElementById(item);
} else if (item.length) {
item = item[0];
}
if (item && item.canvas) {
item = item.canvas;
}
var context = item && item.getContext && item.getContext('2d');
if (context && context.canvas === item) {
initCanvas(item, config);
return context;
}
return null;
},
releaseContext: function (context) {
var canvas = context.canvas;
if (!canvas[EXPANDO_KEY]) {
return;
}
var initial = canvas[EXPANDO_KEY].initial;
[
'height',
'width'
].forEach(function (prop) {
var value = initial[prop];
if (helpers.isNullOrUndef(value)) {
canvas.removeAttribute(prop);
} else {
canvas.setAttribute(prop, value);
}
});
helpers.each(initial.style || {}, function (value, key) {
canvas.style[key] = value;
});
canvas.width = canvas.width;
delete canvas[EXPANDO_KEY];
},
addEventListener: function (chart, type, listener) {
var canvas = chart.canvas;
if (type === 'resize') {
addResizeListener(canvas, listener, chart);
return;
}
var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
var proxies = expando.proxies || (expando.proxies = {});
var proxy = proxies[chart.id + '_' + type] = function (event) {
listener(fromNativeEvent(event, chart));
};
addEventListener(canvas, type, proxy);
},
removeEventListener: function (chart, type, listener) {
var canvas = chart.canvas;
if (type === 'resize') {
removeResizeListener(canvas, listener);
return;
}
var expando = listener[EXPANDO_KEY] || {};
var proxies = expando.proxies || {};
var proxy = proxies[chart.id + '_' + type];
if (!proxy) {
return;
}
removeEventListener(canvas, type, proxy);
}
};
helpers.addEvent = addEventListener;
helpers.removeEvent = removeEventListener;
},
{ '45': 45 }
],
48: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
var basic = require(46);
var dom = require(47);
var implementation = dom._enabled ? dom : basic;
module.exports = helpers.extend({
initialize: function () {
},
acquireContext: function () {
},
releaseContext: function () {
},
addEventListener: function () {
},
removeEventListener: function () {
}
}, implementation);
},
{
'45': 45,
'46': 46,
'47': 47
}
],
49: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('global', { plugins: { filler: { propagate: true } } });
module.exports = function () {
var mappers = {
dataset: function (source) {
var index = source.fill;
var chart = source.chart;
var meta = chart.getDatasetMeta(index);
var visible = meta && chart.isDatasetVisible(index);
var points = visible && meta.dataset._children || [];
var length = points.length || 0;
return !length ? null : function (point, i) {
return i < length && points[i]._view || null;
};
},
boundary: function (source) {
var boundary = source.boundary;
var x = boundary ? boundary.x : null;
var y = boundary ? boundary.y : null;
return function (point) {
return {
x: x === null ? point.x : x,
y: y === null ? point.y : y
};
};
}
};
function decodeFill(el, index, count) {
var model = el._model || {};
var fill = model.fill;
var target;
if (fill === undefined) {
fill = !!model.backgroundColor;
}
if (fill === false || fill === null) {
return false;
}
if (fill === true) {
return 'origin';
}
target = parseFloat(fill, 10);
if (isFinite(target) && Math.floor(target) === target) {
if (fill[0] === '-' || fill[0] === '+') {
target = index + target;
}
if (target === index || target < 0 || target >= count) {
return false;
}
return target;
}
switch (fill) {
case 'bottom':
return 'start';
case 'top':
return 'end';
case 'zero':
return 'origin';
case 'origin':
case 'start':
case 'end':
return fill;
default:
return false;
}
}
function computeBoundary(source) {
var model = source.el._model || {};
var scale = source.el._scale || {};
var fill = source.fill;
var target = null;
var horizontal;
if (isFinite(fill)) {
return null;
}
if (fill === 'start') {
target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
} else if (fill === 'end') {
target = model.scaleTop === undefined ? scale.top : model.scaleTop;
} else if (model.scaleZero !== undefined) {
target = model.scaleZero;
} else if (scale.getBasePosition) {
target = scale.getBasePosition();
} else if (scale.getBasePixel) {
target = scale.getBasePixel();
}
if (target !== undefined && target !== null) {
if (target.x !== undefined && target.y !== undefined) {
return target;
}
if (typeof target === 'number' && isFinite(target)) {
horizontal = scale.isHorizontal();
return {
x: horizontal ? target : null,
y: horizontal ? null : target
};
}
}
return null;
}
function resolveTarget(sources, index, propagate) {
var source = sources[index];
var fill = source.fill;
var visited = [index];
var target;
if (!propagate) {
return fill;
}
while (fill !== false && visited.indexOf(fill) === -1) {
if (!isFinite(fill)) {
return fill;
}
target = sources[fill];
if (!target) {
return false;
}
if (target.visible) {
return fill;
}
visited.push(fill);
fill = target.fill;
}
return false;
}
function createMapper(source) {
var fill = source.fill;
var type = 'dataset';
if (fill === false) {
return null;
}
if (!isFinite(fill)) {
type = 'boundary';
}
return mappers[type](source);
}
function isDrawable(point) {
return point && !point.skip;
}
function drawArea(ctx, curve0, curve1, len0, len1) {
var i;
if (!len0 || !len1) {
return;
}
ctx.moveTo(curve0[0].x, curve0[0].y);
for (i = 1; i < len0; ++i) {
helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
}
ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
for (i = len1 - 1; i > 0; --i) {
helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
}
}
function doFill(ctx, points, mapper, view, color, loop) {
var count = points.length;
var span = view.spanGaps;
var curve0 = [];
var curve1 = [];
var len0 = 0;
var len1 = 0;
var i, ilen, index, p0, p1, d0, d1;
ctx.beginPath();
for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
index = i % count;
p0 = points[index]._view;
p1 = mapper(p0, index, view);
d0 = isDrawable(p0);
d1 = isDrawable(p1);
if (d0 && d1) {
len0 = curve0.push(p0);
len1 = curve1.push(p1);
} else if (len0 && len1) {
if (!span) {
drawArea(ctx, curve0, curve1, len0, len1);
len0 = len1 = 0;
curve0 = [];
curve1 = [];
} else {
if (d0) {
curve0.push(p0);
}
if (d1) {
curve1.push(p1);
}
}
}
}
drawArea(ctx, curve0, curve1, len0, len1);
ctx.closePath();
ctx.fillStyle = color;
ctx.fill();
}
return {
id: 'filler',
afterDatasetsUpdate: function (chart, options) {
var count = (chart.data.datasets || []).length;
var propagate = options.propagate;
var sources = [];
var meta, i, el, source;
for (i = 0; i < count; ++i) {
meta = chart.getDatasetMeta(i);
el = meta.dataset;
source = null;
if (el && el._model && el instanceof elements.Line) {
source = {
visible: chart.isDatasetVisible(i),
fill: decodeFill(el, i, count),
chart: chart,
el: el
};
}
meta.$filler = source;
sources.push(source);
}
for (i = 0; i < count; ++i) {
source = sources[i];
if (!source) {
continue;
}
source.fill = resolveTarget(sources, i, propagate);
source.boundary = computeBoundary(source);
source.mapper = createMapper(source);
}
},
beforeDatasetDraw: function (chart, args) {
var meta = args.meta.$filler;
if (!meta) {
return;
}
var ctx = chart.ctx;
var el = meta.el;
var view = el._view;
var points = el._children || [];
var mapper = meta.mapper;
var color = view.backgroundColor || defaults.global.defaultColor;
if (mapper && color && points.length) {
helpers.canvas.clipArea(ctx, chart.chartArea);
doFill(ctx, points, mapper, view, color, el._loop);
helpers.canvas.unclipArea(ctx);
}
}
};
};
},
{
'25': 25,
'40': 40,
'45': 45
}
],
50: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
legend: {
display: true,
position: 'top',
fullWidth: true,
reverse: false,
weight: 1000,
onClick: function (e, legendItem) {
var index = legendItem.datasetIndex;
var ci = this.chart;
var meta = ci.getDatasetMeta(index);
meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
ci.update();
},
onHover: null,
labels: {
boxWidth: 40,
padding: 10,
generateLabels: function (chart) {
var data = chart.data;
return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
return {
text: dataset.label,
fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
hidden: !chart.isDatasetVisible(i),
lineCap: dataset.borderCapStyle,
lineDash: dataset.borderDash,
lineDashOffset: dataset.borderDashOffset,
lineJoin: dataset.borderJoinStyle,
lineWidth: dataset.borderWidth,
strokeStyle: dataset.borderColor,
pointStyle: dataset.pointStyle,
datasetIndex: i
};
}, this) : [];
}
}
},
legendCallback: function (chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
for (var i = 0; i < chart.data.datasets.length; i++) {
text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
if (chart.data.datasets[i].label) {
text.push(chart.data.datasets[i].label);
}
text.push('</li>');
}
text.push('</ul>');
return text.join('');
}
});
module.exports = function (Chart) {
var layout = Chart.layoutService;
var noop = helpers.noop;
function getBoxWidth(labelOpts, fontSize) {
return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
}
Chart.Legend = Element.extend({
initialize: function (config) {
helpers.extend(this, config);
this.legendHitBoxes = [];
this.doughnutMode = false;
},
beforeUpdate: noop,
update: function (maxWidth, maxHeight, margins) {
var me = this;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = margins;
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeBuildLabels();
me.buildLabels();
me.afterBuildLabels();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: noop,
beforeSetDimensions: noop,
setDimensions: function () {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
me.minSize = {
width: 0,
height: 0
};
},
afterSetDimensions: noop,
beforeBuildLabels: noop,
buildLabels: function () {
var me = this;
var labelOpts = me.options.labels || {};
var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];
if (labelOpts.filter) {
legendItems = legendItems.filter(function (item) {
return labelOpts.filter(item, me.chart.data);
});
}
if (me.options.reverse) {
legendItems.reverse();
}
me.legendItems = legendItems;
},
afterBuildLabels: noop,
beforeFit: noop,
fit: function () {
var me = this;
var opts = me.options;
var labelOpts = opts.labels;
var display = opts.display;
var ctx = me.ctx;
var globalDefault = defaults.global;
var valueOrDefault = helpers.valueOrDefault;
var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var hitboxes = me.legendHitBoxes = [];
var minSize = me.minSize;
var isHorizontal = me.isHorizontal();
if (isHorizontal) {
minSize.width = me.maxWidth;
minSize.height = display ? 10 : 0;
} else {
minSize.width = display ? 10 : 0;
minSize.height = me.maxHeight;
}
if (display) {
ctx.font = labelFont;
if (isHorizontal) {
var lineWidths = me.lineWidths = [0];
var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
helpers.each(me.legendItems, function (legendItem, i) {
var boxWidth = getBoxWidth(labelOpts, fontSize);
var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
totalHeight += fontSize + labelOpts.padding;
lineWidths[lineWidths.length] = me.left;
}
hitboxes[i] = {
left: 0,
top: 0,
width: width,
height: fontSize
};
lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
});
minSize.height += totalHeight;
} else {
var vPadding = labelOpts.padding;
var columnWidths = me.columnWidths = [];
var totalWidth = labelOpts.padding;
var currentColWidth = 0;
var currentColHeight = 0;
var itemHeight = fontSize + vPadding;
helpers.each(me.legendItems, function (legendItem, i) {
var boxWidth = getBoxWidth(labelOpts, fontSize);
var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
if (currentColHeight + itemHeight > minSize.height) {
totalWidth += currentColWidth + labelOpts.padding;
columnWidths.push(currentColWidth);
currentColWidth = 0;
currentColHeight = 0;
}
currentColWidth = Math.max(currentColWidth, itemWidth);
currentColHeight += itemHeight;
hitboxes[i] = {
left: 0,
top: 0,
width: itemWidth,
height: fontSize
};
});
totalWidth += currentColWidth;
columnWidths.push(currentColWidth);
minSize.width += totalWidth;
}
}
me.width = minSize.width;
me.height = minSize.height;
},
afterFit: noop,
isHorizontal: function () {
return this.options.position === 'top' || this.options.position === 'bottom';
},
draw: function () {
var me = this;
var opts = me.options;
var labelOpts = opts.labels;
var globalDefault = defaults.global;
var lineDefault = globalDefault.elements.line;
var legendWidth = me.width;
var lineWidths = me.lineWidths;
if (opts.display) {
var ctx = me.ctx;
var valueOrDefault = helpers.valueOrDefault;
var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var cursor;
ctx.textAlign = 'left';
ctx.textBaseline = 'middle';
ctx.lineWidth = 0.5;
ctx.strokeStyle = fontColor;
ctx.fillStyle = fontColor;
ctx.font = labelFont;
var boxWidth = getBoxWidth(labelOpts, fontSize);
var hitboxes = me.legendHitBoxes;
var drawLegendBox = function (x, y, legendItem) {
if (isNaN(boxWidth) || boxWidth <= 0) {
return;
}
ctx.save();
ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;
if (ctx.setLineDash) {
ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
}
if (opts.labels && opts.labels.usePointStyle) {
var radius = fontSize * Math.SQRT2 / 2;
var offSet = radius / Math.SQRT2;
var centerX = x + offSet;
var centerY = y + offSet;
helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
} else {
if (!isLineWidthZero) {
ctx.strokeRect(x, y, boxWidth, fontSize);
}
ctx.fillRect(x, y, boxWidth, fontSize);
}
ctx.restore();
};
var fillText = function (x, y, legendItem, textWidth) {
var halfFontSize = fontSize / 2;
var xLeft = boxWidth + halfFontSize + x;
var yMiddle = y + halfFontSize;
ctx.fillText(legendItem.text, xLeft, yMiddle);
if (legendItem.hidden) {
ctx.beginPath();
ctx.lineWidth = 2;
ctx.moveTo(xLeft, yMiddle);
ctx.lineTo(xLeft + textWidth, yMiddle);
ctx.stroke();
}
};
var isHorizontal = me.isHorizontal();
if (isHorizontal) {
cursor = {
x: me.left + (legendWidth - lineWidths[0]) / 2,
y: me.top + labelOpts.padding,
line: 0
};
} else {
cursor = {
x: me.left + labelOpts.padding,
y: me.top + labelOpts.padding,
line: 0
};
}
var itemHeight = fontSize + labelOpts.padding;
helpers.each(me.legendItems, function (legendItem, i) {
var textWidth = ctx.measureText(legendItem.text).width;
var width = boxWidth + fontSize / 2 + textWidth;
var x = cursor.x;
var y = cursor.y;
if (isHorizontal) {
if (x + width >= legendWidth) {
y = cursor.y += itemHeight;
cursor.line++;
x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
}
} else if (y + itemHeight > me.bottom) {
x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
y = cursor.y = me.top + labelOpts.padding;
cursor.line++;
}
drawLegendBox(x, y, legendItem);
hitboxes[i].left = x;
hitboxes[i].top = y;
fillText(x, y, legendItem, textWidth);
if (isHorizontal) {
cursor.x += width + labelOpts.padding;
} else {
cursor.y += itemHeight;
}
});
}
},
handleEvent: function (e) {
var me = this;
var opts = me.options;
var type = e.type === 'mouseup' ? 'click' : e.type;
var changed = false;
if (type === 'mousemove') {
if (!opts.onHover) {
return;
}
} else if (type === 'click') {
if (!opts.onClick) {
return;
}
} else {
return;
}
var x = e.x;
var y = e.y;
if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
var lh = me.legendHitBoxes;
for (var i = 0; i < lh.length; ++i) {
var hitBox = lh[i];
if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
if (type === 'click') {
opts.onClick.call(me, e.native, me.legendItems[i]);
changed = true;
break;
} else if (type === 'mousemove') {
opts.onHover.call(me, e.native, me.legendItems[i]);
changed = true;
break;
}
}
}
}
return changed;
}
});
function createNewLegendAndAttach(chart, legendOpts) {
var legend = new Chart.Legend({
ctx: chart.ctx,
options: legendOpts,
chart: chart
});
layout.configure(chart, legend, legendOpts);
layout.addBox(chart, legend);
chart.legend = legend;
}
return {
id: 'legend',
beforeInit: function (chart) {
var legendOpts = chart.options.legend;
if (legendOpts) {
createNewLegendAndAttach(chart, legendOpts);
}
},
beforeUpdate: function (chart) {
var legendOpts = chart.options.legend;
var legend = chart.legend;
if (legendOpts) {
helpers.mergeIf(legendOpts, defaults.global.legend);
if (legend) {
layout.configure(chart, legend, legendOpts);
legend.options = legendOpts;
} else {
createNewLegendAndAttach(chart, legendOpts);
}
} else if (legend) {
layout.removeBox(chart, legend);
delete chart.legend;
}
},
afterEvent: function (chart, e) {
var legend = chart.legend;
if (legend) {
legend.handleEvent(e);
}
}
};
};
},
{
'25': 25,
'26': 26,
'45': 45
}
],
51: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
title: {
display: false,
fontStyle: 'bold',
fullWidth: true,
lineHeight: 1.2,
padding: 10,
position: 'top',
text: '',
weight: 2000
}
});
module.exports = function (Chart) {
var layout = Chart.layoutService;
var noop = helpers.noop;
Chart.Title = Element.extend({
initialize: function (config) {
var me = this;
helpers.extend(me, config);
me.legendHitBoxes = [];
},
beforeUpdate: noop,
update: function (maxWidth, maxHeight, margins) {
var me = this;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = margins;
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeBuildLabels();
me.buildLabels();
me.afterBuildLabels();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: noop,
beforeSetDimensions: noop,
setDimensions: function () {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
me.minSize = {
width: 0,
height: 0
};
},
afterSetDimensions: noop,
beforeBuildLabels: noop,
buildLabels: noop,
afterBuildLabels: noop,
beforeFit: noop,
fit: function () {
var me = this;
var valueOrDefault = helpers.valueOrDefault;
var opts = me.options;
var display = opts.display;
var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
var minSize = me.minSize;
var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;
if (me.isHorizontal()) {
minSize.width = me.maxWidth;
minSize.height = textSize;
} else {
minSize.width = textSize;
minSize.height = me.maxHeight;
}
me.width = minSize.width;
me.height = minSize.height;
},
afterFit: noop,
isHorizontal: function () {
var pos = this.options.position;
return pos === 'top' || pos === 'bottom';
},
draw: function () {
var me = this;
var ctx = me.ctx;
var valueOrDefault = helpers.valueOrDefault;
var opts = me.options;
var globalDefaults = defaults.global;
if (opts.display) {
var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
var offset = lineHeight / 2 + opts.padding;
var rotation = 0;
var top = me.top;
var left = me.left;
var bottom = me.bottom;
var right = me.right;
var maxWidth, titleX, titleY;
ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor);
ctx.font = titleFont;
if (me.isHorizontal()) {
titleX = left + (right - left) / 2;
titleY = top + offset;
maxWidth = right - left;
} else {
titleX = opts.position === 'left' ? left + offset : right - offset;
titleY = top + (bottom - top) / 2;
maxWidth = bottom - top;
rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
}
ctx.save();
ctx.translate(titleX, titleY);
ctx.rotate(rotation);
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
var text = opts.text;
if (helpers.isArray(text)) {
var y = 0;
for (var i = 0; i < text.length; ++i) {
ctx.fillText(text[i], 0, y, maxWidth);
y += lineHeight;
}
} else {
ctx.fillText(text, 0, 0, maxWidth);
}
ctx.restore();
}
}
});
function createNewTitleBlockAndAttach(chart, titleOpts) {
var title = new Chart.Title({
ctx: chart.ctx,
options: titleOpts,
chart: chart
});
layout.configure(chart, title, titleOpts);
layout.addBox(chart, title);
chart.titleBlock = title;
}
return {
id: 'title',
beforeInit: function (chart) {
var titleOpts = chart.options.title;
if (titleOpts) {
createNewTitleBlockAndAttach(chart, titleOpts);
}
},
beforeUpdate: function (chart) {
var titleOpts = chart.options.title;
var titleBlock = chart.titleBlock;
if (titleOpts) {
helpers.mergeIf(titleOpts, defaults.global.title);
if (titleBlock) {
layout.configure(chart, titleBlock, titleOpts);
titleBlock.options = titleOpts;
} else {
createNewTitleBlockAndAttach(chart, titleOpts);
}
} else if (titleBlock) {
Chart.layoutService.removeBox(chart, titleBlock);
delete chart.titleBlock;
}
}
};
};
},
{
'25': 25,
'26': 26,
'45': 45
}
],
52: [
function (require, module, exports) {
'use strict';
module.exports = function (Chart) {
var defaultConfig = { position: 'bottom' };
var DatasetScale = Chart.Scale.extend({
getLabels: function () {
var data = this.chart.data;
return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
},
determineDataLimits: function () {
var me = this;
var labels = me.getLabels();
me.minIndex = 0;
me.maxIndex = labels.length - 1;
var findIndex;
if (me.options.ticks.min !== undefined) {
findIndex = labels.indexOf(me.options.ticks.min);
me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
}
if (me.options.ticks.max !== undefined) {
findIndex = labels.indexOf(me.options.ticks.max);
me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
}
me.min = labels[me.minIndex];
me.max = labels[me.maxIndex];
},
buildTicks: function () {
var me = this;
var labels = me.getLabels();
me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
},
getLabelForIndex: function (index, datasetIndex) {
var me = this;
var data = me.chart.data;
var isHorizontal = me.isHorizontal();
if (data.yLabels && !isHorizontal) {
return me.getRightValue(data.datasets[datasetIndex].data[index]);
}
return me.ticks[index - me.minIndex];
},
getPixelForValue: function (value, index) {
var me = this;
var offset = me.options.offset;
var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);
var valueCategory;
if (value !== undefined && value !== null) {
valueCategory = me.isHorizontal() ? value.x : value.y;
}
if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
var labels = me.getLabels();
value = valueCategory || value;
var idx = labels.indexOf(value);
index = idx !== -1 ? idx : index;
}
if (me.isHorizontal()) {
var valueWidth = me.width / offsetAmt;
var widthOffset = valueWidth * (index - me.minIndex);
if (offset) {
widthOffset += valueWidth / 2;
}
return me.left + Math.round(widthOffset);
}
var valueHeight = me.height / offsetAmt;
var heightOffset = valueHeight * (index - me.minIndex);
if (offset) {
heightOffset += valueHeight / 2;
}
return me.top + Math.round(heightOffset);
},
getPixelForTick: function (index) {
return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
},
getValueForPixel: function (pixel) {
var me = this;
var offset = me.options.offset;
var value;
var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
var horz = me.isHorizontal();
var valueDimension = (horz ? me.width : me.height) / offsetAmt;
pixel -= horz ? me.left : me.top;
if (offset) {
pixel -= valueDimension / 2;
}
if (pixel <= 0) {
value = 0;
} else {
value = Math.round(pixel / valueDimension);
}
return value + me.minIndex;
},
getBasePixel: function () {
return this.bottom;
}
});
Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};
},
{}
],
53: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var helpers = require(45);
var Ticks = require(34);
module.exports = function (Chart) {
var defaultConfig = {
position: 'left',
ticks: { callback: Ticks.formatters.linear }
};
var LinearScale = Chart.LinearScaleBase.extend({
determineDataLimits: function () {
var me = this;
var opts = me.options;
var chart = me.chart;
var data = chart.data;
var datasets = data.datasets;
var isHorizontal = me.isHorizontal();
var DEFAULT_MIN = 0;
var DEFAULT_MAX = 1;
function IDMatches(meta) {
return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
}
me.min = null;
me.max = null;
var hasStacks = opts.stacked;
if (hasStacks === undefined) {
helpers.each(datasets, function (dataset, datasetIndex) {
if (hasStacks) {
return;
}
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
hasStacks = true;
}
});
}
if (opts.stacked || hasStacks) {
var valuesPerStack = {};
helpers.each(datasets, function (dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
var key = [
meta.type,
opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '',
meta.stack
].join('.');
if (valuesPerStack[key] === undefined) {
valuesPerStack[key] = {
positiveValues: [],
negativeValues: []
};
}
var positiveValues = valuesPerStack[key].positiveValues;
var negativeValues = valuesPerStack[key].negativeValues;
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function (rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
positiveValues[index] = positiveValues[index] || 0;
negativeValues[index] = negativeValues[index] || 0;
if (opts.relativePoints) {
positiveValues[index] = 100;
} else if (value < 0) {
negativeValues[index] += value;
} else {
positiveValues[index] += value;
}
});
}
});
helpers.each(valuesPerStack, function (valuesForType) {
var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
var minVal = helpers.min(values);
var maxVal = helpers.max(values);
me.min = me.min === null ? minVal : Math.min(me.min, minVal);
me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
});
} else {
helpers.each(datasets, function (dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function (rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
if (me.min === null) {
me.min = value;
} else if (value < me.min) {
me.min = value;
}
if (me.max === null) {
me.max = value;
} else if (value > me.max) {
me.max = value;
}
});
}
});
}
me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
this.handleTickRangeOptions();
},
getTickLimit: function () {
var maxTicks;
var me = this;
var tickOpts = me.options.ticks;
if (me.isHorizontal()) {
maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
} else {
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
}
return maxTicks;
},
handleDirectionalChanges: function () {
if (!this.isHorizontal()) {
this.ticks.reverse();
}
},
getLabelForIndex: function (index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
getPixelForValue: function (value) {
var me = this;
var start = me.start;
var rightValue = +me.getRightValue(value);
var pixel;
var range = me.end - start;
if (me.isHorizontal()) {
pixel = me.left + me.width / range * (rightValue - start);
return Math.round(pixel);
}
pixel = me.bottom - me.height / range * (rightValue - start);
return Math.round(pixel);
},
getValueForPixel: function (pixel) {
var me = this;
var isHorizontal = me.isHorizontal();
var innerDimension = isHorizontal ? me.width : me.height;
var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
return me.start + (me.end - me.start) * offset;
},
getPixelForTick: function (index) {
return this.getPixelForValue(this.ticksAsNumbers[index]);
}
});
Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
};
},
{
'25': 25,
'34': 34,
'45': 45
}
],
54: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
var Ticks = require(34);
module.exports = function (Chart) {
var noop = helpers.noop;
Chart.LinearScaleBase = Chart.Scale.extend({
getRightValue: function (value) {
if (typeof value === 'string') {
return +value;
}
return Chart.Scale.prototype.getRightValue.call(this, value);
},
handleTickRangeOptions: function () {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
if (tickOpts.beginAtZero) {
var minSign = helpers.sign(me.min);
var maxSign = helpers.sign(me.max);
if (minSign < 0 && maxSign < 0) {
me.max = 0;
} else if (minSign > 0 && maxSign > 0) {
me.min = 0;
}
}
var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
if (tickOpts.min !== undefined) {
me.min = tickOpts.min;
} else if (tickOpts.suggestedMin !== undefined) {
if (me.min === null) {
me.min = tickOpts.suggestedMin;
} else {
me.min = Math.min(me.min, tickOpts.suggestedMin);
}
}
if (tickOpts.max !== undefined) {
me.max = tickOpts.max;
} else if (tickOpts.suggestedMax !== undefined) {
if (me.max === null) {
me.max = tickOpts.suggestedMax;
} else {
me.max = Math.max(me.max, tickOpts.suggestedMax);
}
}
if (setMin !== setMax) {
if (me.min >= me.max) {
if (setMin) {
me.max = me.min + 1;
} else {
me.min = me.max - 1;
}
}
}
if (me.min === me.max) {
me.max++;
if (!tickOpts.beginAtZero) {
me.min--;
}
}
},
getTickLimit: noop,
handleDirectionalChanges: noop,
buildTicks: function () {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var maxTicks = me.getTickLimit();
maxTicks = Math.max(2, maxTicks);
var numericGeneratorOptions = {
maxTicks: maxTicks,
min: tickOpts.min,
max: tickOpts.max,
stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
};
var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);
me.handleDirectionalChanges();
me.max = helpers.max(ticks);
me.min = helpers.min(ticks);
if (tickOpts.reverse) {
ticks.reverse();
me.start = me.max;
me.end = me.min;
} else {
me.start = me.min;
me.end = me.max;
}
},
convertTicksToLabels: function () {
var me = this;
me.ticksAsNumbers = me.ticks.slice();
me.zeroLineIndex = me.ticks.indexOf(0);
Chart.Scale.prototype.convertTicksToLabels.call(me);
}
});
};
},
{
'34': 34,
'45': 45
}
],
55: [
function (require, module, exports) {
'use strict';
var helpers = require(45);
var Ticks = require(34);
module.exports = function (Chart) {
var defaultConfig = {
position: 'left',
ticks: { callback: Ticks.formatters.logarithmic }
};
var LogarithmicScale = Chart.Scale.extend({
determineDataLimits: function () {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var chart = me.chart;
var data = chart.data;
var datasets = data.datasets;
var valueOrDefault = helpers.valueOrDefault;
var isHorizontal = me.isHorizontal();
function IDMatches(meta) {
return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
}
me.min = null;
me.max = null;
me.minNotZero = null;
var hasStacks = opts.stacked;
if (hasStacks === undefined) {
helpers.each(datasets, function (dataset, datasetIndex) {
if (hasStacks) {
return;
}
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
hasStacks = true;
}
});
}
if (opts.stacked || hasStacks) {
var valuesPerStack = {};
helpers.each(datasets, function (dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
var key = [
meta.type,
opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '',
meta.stack
].join('.');
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
if (valuesPerStack[key] === undefined) {
valuesPerStack[key] = [];
}
helpers.each(dataset.data, function (rawValue, index) {
var values = valuesPerStack[key];
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
values[index] = values[index] || 0;
if (opts.relativePoints) {
values[index] = 100;
} else {
values[index] += value;
}
});
}
});
helpers.each(valuesPerStack, function (valuesForType) {
var minVal = helpers.min(valuesForType);
var maxVal = helpers.max(valuesForType);
me.min = me.min === null ? minVal : Math.min(me.min, minVal);
me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
});
} else {
helpers.each(datasets, function (dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function (rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
if (me.min === null) {
me.min = value;
} else if (value < me.min) {
me.min = value;
}
if (me.max === null) {
me.max = value;
} else if (value > me.max) {
me.max = value;
}
if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
me.minNotZero = value;
}
});
}
});
}
me.min = valueOrDefault(tickOpts.min, me.min);
me.max = valueOrDefault(tickOpts.max, me.max);
if (me.min === me.max) {
if (me.min !== 0 && me.min !== null) {
me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
} else {
me.min = 1;
me.max = 10;
}
}
},
buildTicks: function () {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var generationOptions = {
min: tickOpts.min,
max: tickOpts.max
};
var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);
if (!me.isHorizontal()) {
ticks.reverse();
}
me.max = helpers.max(ticks);
me.min = helpers.min(ticks);
if (tickOpts.reverse) {
ticks.reverse();
me.start = me.max;
me.end = me.min;
} else {
me.start = me.min;
me.end = me.max;
}
},
convertTicksToLabels: function () {
this.tickValues = this.ticks.slice();
Chart.Scale.prototype.convertTicksToLabels.call(this);
},
getLabelForIndex: function (index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
getPixelForTick: function (index) {
return this.getPixelForValue(this.tickValues[index]);
},
getPixelForValue: function (value) {
var me = this;
var start = me.start;
var newVal = +me.getRightValue(value);
var opts = me.options;
var tickOpts = opts.ticks;
var innerDimension, pixel, range;
if (me.isHorizontal()) {
range = helpers.log10(me.end) - helpers.log10(start);
if (newVal === 0) {
pixel = me.left;
} else {
innerDimension = me.width;
pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
}
} else {
innerDimension = me.height;
if (start === 0 && !tickOpts.reverse) {
range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
if (newVal === start) {
pixel = me.bottom;
} else if (newVal === me.minNotZero) {
pixel = me.bottom - innerDimension * 0.02;
} else {
pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
}
} else if (me.end === 0 && tickOpts.reverse) {
range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
if (newVal === me.end) {
pixel = me.top;
} else if (newVal === me.minNotZero) {
pixel = me.top + innerDimension * 0.02;
} else {
pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
}
} else if (newVal === 0) {
pixel = tickOpts.reverse ? me.top : me.bottom;
} else {
range = helpers.log10(me.end) - helpers.log10(start);
innerDimension = me.height;
pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
}
}
return pixel;
},
getValueForPixel: function (pixel) {
var me = this;
var range = helpers.log10(me.end) - helpers.log10(me.start);
var value, innerDimension;
if (me.isHorizontal()) {
innerDimension = me.width;
value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
} else {
innerDimension = me.height;
value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
}
return value;
}
});
Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
};
},
{
'34': 34,
'45': 45
}
],
56: [
function (require, module, exports) {
'use strict';
var defaults = require(25);
var helpers = require(45);
var Ticks = require(34);
module.exports = function (Chart) {
var globalDefaults = defaults.global;
var defaultConfig = {
display: true,
animate: true,
position: 'chartArea',
angleLines: {
display: true,
color: 'rgba(0, 0, 0, 0.1)',
lineWidth: 1
},
gridLines: { circular: false },
ticks: {
showLabelBackdrop: true,
backdropColor: 'rgba(255,255,255,0.75)',
backdropPaddingY: 2,
backdropPaddingX: 2,
callback: Ticks.formatters.linear
},
pointLabels: {
display: true,
fontSize: 10,
callback: function (label) {
return label;
}
}
};
function getValueCount(scale) {
var opts = scale.options;
return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
}
function getPointLabelFontOptions(scale) {
var pointLabelOptions = scale.options.pointLabels;
var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
var font = helpers.fontString(fontSize, fontStyle, fontFamily);
return {
size: fontSize,
style: fontStyle,
family: fontFamily,
font: font
};
}
function measureLabelSize(ctx, fontSize, label) {
if (helpers.isArray(label)) {
return {
w: helpers.longestText(ctx, ctx.font, label),
h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
};
}
return {
w: ctx.measureText(label).width,
h: fontSize
};
}
function determineLimits(angle, pos, size, min, max) {
if (angle === min || angle === max) {
return {
start: pos - size / 2,
end: pos + size / 2
};
} else if (angle < min || angle > max) {
return {
start: pos - size - 5,
end: pos
};
}
return {
start: pos,
end: pos + size + 5
};
}
function fitWithPointLabels(scale) {
var plFont = getPointLabelFontOptions(scale);
var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
var furthestLimits = {
r: scale.width,
l: 0,
t: scale.height,
b: 0
};
var furthestAngles = {};
var i, textSize, pointPosition;
scale.ctx.font = plFont.font;
scale._pointLabelSizes = [];
var valueCount = getValueCount(scale);
for (i = 0; i < valueCount; i++) {
pointPosition = scale.getPointPosition(i, largestPossibleRadius);
textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
scale._pointLabelSizes[i] = textSize;
var angleRadians = scale.getIndexAngle(i);
var angle = helpers.toDegrees(angleRadians) % 360;
var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
if (hLimits.start < furthestLimits.l) {
furthestLimits.l = hLimits.start;
furthestAngles.l = angleRadians;
}
if (hLimits.end > furthestLimits.r) {
furthestLimits.r = hLimits.end;
furthestAngles.r = angleRadians;
}
if (vLimits.start < furthestLimits.t) {
furthestLimits.t = vLimits.start;
furthestAngles.t = angleRadians;
}
if (vLimits.end > furthestLimits.b) {
furthestLimits.b = vLimits.end;
furthestAngles.b = angleRadians;
}
}
scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
}
function fit(scale) {
var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
scale.drawingArea = Math.round(largestPossibleRadius);
scale.setCenterPoint(0, 0, 0, 0);
}
function getTextAlignForAngle(angle) {
if (angle === 0 || angle === 180) {
return 'center';
} else if (angle < 180) {
return 'left';
}
return 'right';
}
function fillText(ctx, text, position, fontSize) {
if (helpers.isArray(text)) {
var y = position.y;
var spacing = 1.5 * fontSize;
for (var i = 0; i < text.length; ++i) {
ctx.fillText(text[i], position.x, y);
y += spacing;
}
} else {
ctx.fillText(text, position.x, position.y);
}
}
function adjustPointPositionForLabelHeight(angle, textSize, position) {
if (angle === 90 || angle === 270) {
position.y -= textSize.h / 2;
} else if (angle > 270 || angle < 90) {
position.y -= textSize.h;
}
}
function drawPointLabels(scale) {
var ctx = scale.ctx;
var valueOrDefault = helpers.valueOrDefault;
var opts = scale.options;
var angleLineOpts = opts.angleLines;
var pointLabelOpts = opts.pointLabels;
ctx.lineWidth = angleLineOpts.lineWidth;
ctx.strokeStyle = angleLineOpts.color;
var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
var plFont = getPointLabelFontOptions(scale);
ctx.textBaseline = 'top';
for (var i = getValueCount(scale) - 1; i >= 0; i--) {
if (angleLineOpts.display) {
var outerPosition = scale.getPointPosition(i, outerDistance);
ctx.beginPath();
ctx.moveTo(scale.xCenter, scale.yCenter);
ctx.lineTo(outerPosition.x, outerPosition.y);
ctx.stroke();
ctx.closePath();
}
if (pointLabelOpts.display) {
var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);
var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
ctx.font = plFont.font;
ctx.fillStyle = pointLabelFontColor;
var angleRadians = scale.getIndexAngle(i);
var angle = helpers.toDegrees(angleRadians);
ctx.textAlign = getTextAlignForAngle(angle);
adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
}
}
}
function drawRadiusLine(scale, gridLineOpts, radius, index) {
var ctx = scale.ctx;
ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
if (scale.options.gridLines.circular) {
ctx.beginPath();
ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
ctx.closePath();
ctx.stroke();
} else {
var valueCount = getValueCount(scale);
if (valueCount === 0) {
return;
}
ctx.beginPath();
var pointPosition = scale.getPointPosition(0, radius);
ctx.moveTo(pointPosition.x, pointPosition.y);
for (var i = 1; i < valueCount; i++) {
pointPosition = scale.getPointPosition(i, radius);
ctx.lineTo(pointPosition.x, pointPosition.y);
}
ctx.closePath();
ctx.stroke();
}
}
function numberOrZero(param) {
return helpers.isNumber(param) ? param : 0;
}
var LinearRadialScale = Chart.LinearScaleBase.extend({
setDimensions: function () {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
me.width = me.maxWidth;
me.height = me.maxHeight;
me.xCenter = Math.round(me.width / 2);
me.yCenter = Math.round(me.height / 2);
var minSize = helpers.min([
me.height,
me.width
]);
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
},
determineDataLimits: function () {
var me = this;
var chart = me.chart;
var min = Number.POSITIVE_INFINITY;
var max = Number.NEGATIVE_INFINITY;
helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
if (chart.isDatasetVisible(datasetIndex)) {
var meta = chart.getDatasetMeta(datasetIndex);
helpers.each(dataset.data, function (rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
min = Math.min(value, min);
max = Math.max(value, max);
});
}
});
me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
me.handleTickRangeOptions();
},
getTickLimit: function () {
var tickOpts = this.options.ticks;
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
},
convertTicksToLabels: function () {
var me = this;
Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
},
getLabelForIndex: function (index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
fit: function () {
if (this.options.pointLabels.display) {
fitWithPointLabels(this);
} else {
fit(this);
}
},
setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
var me = this;
var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
radiusReductionLeft = numberOrZero(radiusReductionLeft);
radiusReductionRight = numberOrZero(radiusReductionRight);
radiusReductionTop = numberOrZero(radiusReductionTop);
radiusReductionBottom = numberOrZero(radiusReductionBottom);
me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
},
setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
var me = this;
var maxRight = me.width - rightMovement - me.drawingArea;
var maxLeft = leftMovement + me.drawingArea;
var maxTop = topMovement + me.drawingArea;
var maxBottom = me.height - bottomMovement - me.drawingArea;
me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
},
getIndexAngle: function (index) {
var angleMultiplier = Math.PI * 2 / getValueCount(this);
var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
var startAngleRadians = startAngle * Math.PI * 2 / 360;
return index * angleMultiplier + startAngleRadians;
},
getDistanceFromCenterForValue: function (value) {
var me = this;
if (value === null) {
return 0;
}
var scalingFactor = me.drawingArea / (me.max - me.min);
if (me.options.ticks.reverse) {
return (me.max - value) * scalingFactor;
}
return (value - me.min) * scalingFactor;
},
getPointPosition: function (index, distanceFromCenter) {
var me = this;
var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
return {
x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
};
},
getPointPositionForValue: function (index, value) {
return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
},
getBasePosition: function () {
var me = this;
var min = me.min;
var max = me.max;
return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
},
draw: function () {
var me = this;
var opts = me.options;
var gridLineOpts = opts.gridLines;
var tickOpts = opts.ticks;
var valueOrDefault = helpers.valueOrDefault;
if (opts.display) {
var ctx = me.ctx;
var startAngle = this.getIndexAngle(0);
var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
helpers.each(me.ticks, function (label, index) {
if (index > 0 || tickOpts.reverse) {
var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
if (gridLineOpts.display && index !== 0) {
drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
}
if (tickOpts.display) {
var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
ctx.font = tickLabelFont;
ctx.save();
ctx.translate(me.xCenter, me.yCenter);
ctx.rotate(startAngle);
if (tickOpts.showLabelBackdrop) {
var labelWidth = ctx.measureText(label).width;
ctx.fillStyle = tickOpts.backdropColor;
ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
}
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillStyle = tickFontColor;
ctx.fillText(label, 0, -yCenterOffset);
ctx.restore();
}
}
});
if (opts.angleLines.display || opts.pointLabels.display) {
drawPointLabels(me);
}
}
}
});
Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
};
},
{
'25': 25,
'34': 34,
'45': 45
}
],
57: [
function (require, module, exports) {
'use strict';
var moment = require(1);
moment = typeof moment === 'function' ? moment : window.moment;
var defaults = require(25);
var helpers = require(45);
var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var INTERVALS = {
millisecond: {
common: true,
size: 1,
steps: [
1,
2,
5,
10,
20,
50,
100,
250,
500
]
},
second: {
common: true,
size: 1000,
steps: [
1,
2,
5,
10,
30
]
},
minute: {
common: true,
size: 60000,
steps: [
1,
2,
5,
10,
30
]
},
hour: {
common: true,
size: 3600000,
steps: [
1,
2,
3,
6,
12
]
},
day: {
common: true,
size: 86400000,
steps: [
1,
2,
5
]
},
week: {
common: false,
size: 604800000,
steps: [
1,
2,
3,
4
]
},
month: {
common: true,
size: 2628000000,
steps: [
1,
2,
3
]
},
quarter: {
common: false,
size: 7884000000,
steps: [
1,
2,
3,
4
]
},
year: {
common: true,
size: 31540000000
}
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
return a - b;
}
function arrayUnique(items) {
var hash = {};
var out = [];
var i, ilen, item;
for (i = 0, ilen = items.length; i < ilen; ++i) {
item = items[i];
if (!hash[item]) {
hash[item] = true;
out.push(item);
}
}
return out;
}
function buildLookupTable(timestamps, min, max, distribution) {
if (distribution === 'linear' || !timestamps.length) {
return [
{
time: min,
pos: 0
},
{
time: max,
pos: 1
}
];
}
var table = [];
var items = [min];
var i, ilen, prev, curr, next;
for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
curr = timestamps[i];
if (curr > min && curr < max) {
items.push(curr);
}
}
items.push(max);
for (i = 0, ilen = items.length; i < ilen; ++i) {
next = items[i + 1];
prev = items[i - 1];
curr = items[i];
if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
table.push({
time: curr,
pos: i / (ilen - 1)
});
}
}
return table;
}
function lookup(table, key, value) {
var lo = 0;
var hi = table.length - 1;
var mid, i0, i1;
while (lo >= 0 && lo <= hi) {
mid = lo + hi >> 1;
i0 = table[mid - 1] || null;
i1 = table[mid];
if (!i0) {
return {
lo: null,
hi: i1
};
} else if (i1[key] < value) {
lo = mid + 1;
} else if (i0[key] > value) {
hi = mid - 1;
} else {
return {
lo: i0,
hi: i1
};
}
}
return {
lo: i1,
hi: null
};
}
function interpolate(table, skey, sval, tkey) {
var range = lookup(table, skey, sval);
var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
var span = next[skey] - prev[skey];
var ratio = span ? (sval - prev[skey]) / span : 0;
var offset = (next[tkey] - prev[tkey]) * ratio;
return prev[tkey] + offset;
}
function momentify(value, options) {
var parser = options.parser;
var format = options.parser || options.format;
if (typeof parser === 'function') {
return parser(value);
}
if (typeof value === 'string' && typeof format === 'string') {
return moment(value, format);
}
if (!(value instanceof moment)) {
value = moment(value);
}
if (value.isValid()) {
return value;
}
if (typeof format === 'function') {
return format(value);
}
return value;
}
function parse(input, scale) {
if (helpers.isNullOrUndef(input)) {
return null;
}
var options = scale.options.time;
var value = momentify(scale.getRightValue(input), options);
if (!value.isValid()) {
return null;
}
if (options.round) {
value.startOf(options.round);
}
return value.valueOf();
}
function determineStepSize(min, max, unit, capacity) {
var range = max - min;
var interval = INTERVALS[unit];
var milliseconds = interval.size;
var steps = interval.steps;
var i, ilen, factor;
if (!steps) {
return Math.ceil(range / ((capacity || 1) * milliseconds));
}
for (i = 0, ilen = steps.length; i < ilen; ++i) {
factor = steps[i];
if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
break;
}
}
return factor;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
var ilen = UNITS.length;
var i, interval, factor;
for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
interval = INTERVALS[UNITS[i]];
factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;
if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
return UNITS[i];
}
}
return UNITS[ilen - 1];
}
function determineUnitForFormatting(ticks, minUnit, min, max) {
var duration = moment.duration(moment(max).diff(moment(min)));
var ilen = UNITS.length;
var i, unit;
for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
unit = UNITS[i];
if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
return unit;
}
}
return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
if (INTERVALS[UNITS[i]].common) {
return UNITS[i];
}
}
}
function generate(min, max, capacity, options) {
var timeOpts = options.time;
var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
var major = determineMajorUnit(minor);
var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
var majorTicksEnabled = options.ticks.major.enabled;
var interval = INTERVALS[minor];
var first = moment(min);
var last = moment(max);
var ticks = [];
var time;
if (!stepSize) {
stepSize = determineStepSize(min, max, minor, capacity);
}
if (weekday) {
first = first.isoWeekday(weekday);
last = last.isoWeekday(weekday);
}
first = first.startOf(weekday ? 'day' : minor);
last = last.startOf(weekday ? 'day' : minor);
if (last < max) {
last.add(1, minor);
}
time = moment(first);
if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
time.startOf(major);
time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
}
for (; time < last; time.add(stepSize, minor)) {
ticks.push(+time);
}
ticks.push(+time);
return ticks;
}
function computeOffsets(table, ticks, min, max, options) {
var left = 0;
var right = 0;
var upper, lower;
if (options.offset && ticks.length) {
if (!options.time.min) {
upper = ticks.length > 1 ? ticks[1] : max;
lower = ticks[0];
left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
}
if (!options.time.max) {
upper = ticks[ticks.length - 1];
lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
}
}
return {
left: left,
right: right
};
}
function ticksFromTimestamps(values, majorUnit) {
var ticks = [];
var i, ilen, value, major;
for (i = 0, ilen = values.length; i < ilen; ++i) {
value = values[i];
major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
ticks.push({
value: value,
major: major
});
}
return ticks;
}
module.exports = function (Chart) {
var defaultConfig = {
position: 'bottom',
distribution: 'linear',
bounds: 'data',
time: {
parser: false,
format: false,
unit: false,
round: false,
displayFormat: false,
isoWeekday: false,
minUnit: 'millisecond',
displayFormats: {
millisecond: 'h:mm:ss.SSS a',
second: 'h:mm:ss a',
minute: 'h:mm a',
hour: 'hA',
day: 'MMM D',
week: 'll',
month: 'MMM YYYY',
quarter: '[Q]Q - YYYY',
year: 'YYYY'
}
},
ticks: {
autoSkip: false,
source: 'auto',
major: { enabled: false }
}
};
var TimeScale = Chart.Scale.extend({
initialize: function () {
if (!moment) {
throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
}
this.mergeTicksOptions();
Chart.Scale.prototype.initialize.call(this);
},
update: function () {
var me = this;
var options = me.options;
if (options.time && options.time.format) {
console.warn('options.time.format is deprecated and replaced by options.time.parser.');
}
return Chart.Scale.prototype.update.apply(me, arguments);
},
getRightValue: function (rawValue) {
if (rawValue && rawValue.t !== undefined) {
rawValue = rawValue.t;
}
return Chart.Scale.prototype.getRightValue.call(this, rawValue);
},
determineDataLimits: function () {
var me = this;
var chart = me.chart;
var timeOpts = me.options.time;
var min = MAX_INTEGER;
var max = MIN_INTEGER;
var timestamps = [];
var datasets = [];
var labels = [];
var i, j, ilen, jlen, data, timestamp;
for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
labels.push(parse(chart.data.labels[i], me));
}
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
if (chart.isDatasetVisible(i)) {
data = chart.data.datasets[i].data;
if (helpers.isObject(data[0])) {
datasets[i] = [];
for (j = 0, jlen = data.length; j < jlen; ++j) {
timestamp = parse(data[j], me);
timestamps.push(timestamp);
datasets[i][j] = timestamp;
}
} else {
timestamps.push.apply(timestamps, labels);
datasets[i] = labels.slice(0);
}
} else {
datasets[i] = [];
}
}
if (labels.length) {
labels = arrayUnique(labels).sort(sorter);
min = Math.min(min, labels[0]);
max = Math.max(max, labels[labels.length - 1]);
}
if (timestamps.length) {
timestamps = arrayUnique(timestamps).sort(sorter);
min = Math.min(min, timestamps[0]);
max = Math.max(max, timestamps[timestamps.length - 1]);
}
min = parse(timeOpts.min, me) || min;
max = parse(timeOpts.max, me) || max;
min = min === MAX_INTEGER ? +moment().startOf('day') : min;
max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;
me.min = Math.min(min, max);
me.max = Math.max(min + 1, max);
me._horizontal = me.isHorizontal();
me._table = [];
me._timestamps = {
data: timestamps,
datasets: datasets,
labels: labels
};
},
buildTicks: function () {
var me = this;
var min = me.min;
var max = me.max;
var options = me.options;
var timeOpts = options.time;
var timestamps = [];
var ticks = [];
var i, ilen, timestamp;
switch (options.ticks.source) {
case 'data':
timestamps = me._timestamps.data;
break;
case 'labels':
timestamps = me._timestamps.labels;
break;
case 'auto':
default:
timestamps = generate(min, max, me.getLabelCapacity(min), options);
}
if (options.bounds === 'ticks' && timestamps.length) {
min = timestamps[0];
max = timestamps[timestamps.length - 1];
}
min = parse(timeOpts.min, me) || min;
max = parse(timeOpts.max, me) || max;
for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
timestamp = timestamps[i];
if (timestamp >= min && timestamp <= max) {
ticks.push(timestamp);
}
}
me.min = min;
me.max = max;
me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
me._majorUnit = determineMajorUnit(me._unit);
me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
me._offsets = computeOffsets(me._table, ticks, min, max, options);
return ticksFromTimestamps(ticks, me._majorUnit);
},
getLabelForIndex: function (index, datasetIndex) {
var me = this;
var data = me.chart.data;
var timeOpts = me.options.time;
var label = data.labels && index < data.labels.length ? data.labels[index] : '';
var value = data.datasets[datasetIndex].data[index];
if (helpers.isObject(value)) {
label = me.getRightValue(value);
}
if (timeOpts.tooltipFormat) {
label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
}
return label;
},
tickFormatFunction: function (tick, index, ticks, formatOverride) {
var me = this;
var options = me.options;
var time = tick.valueOf();
var formats = options.time.displayFormats;
var minorFormat = formats[me._unit];
var majorUnit = me._majorUnit;
var majorFormat = formats[majorUnit];
var majorTime = tick.clone().startOf(majorUnit).valueOf();
var majorTickOpts = options.ticks.major;
var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
var tickOpts = major ? majorTickOpts : options.ticks.minor;
var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
return formatter ? formatter(label, index, ticks) : label;
},
convertTicksToLabels: function (ticks) {
var labels = [];
var i, ilen;
for (i = 0, ilen = ticks.length; i < ilen; ++i) {
labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
}
return labels;
},
getPixelForOffset: function (time) {
var me = this;
var size = me._horizontal ? me.width : me.height;
var start = me._horizontal ? me.left : me.top;
var pos = interpolate(me._table, 'time', time, 'pos');
return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
},
getPixelForValue: function (value, index, datasetIndex) {
var me = this;
var time = null;
if (index !== undefined && datasetIndex !== undefined) {
time = me._timestamps.datasets[datasetIndex][index];
}
if (time === null) {
time = parse(value, me);
}
if (time !== null) {
return me.getPixelForOffset(time);
}
},
getPixelForTick: function (index) {
var ticks = this.getTicks();
return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
},
getValueForPixel: function (pixel) {
var me = this;
var size = me._horizontal ? me.width : me.height;
var start = me._horizontal ? me.left : me.top;
var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
var time = interpolate(me._table, 'pos', pos, 'time');
return moment(time);
},
getLabelWidth: function (label) {
var me = this;
var ticksOpts = me.options.ticks;
var tickLabelWidth = me.ctx.measureText(label).width;
var angle = helpers.toRadians(ticksOpts.maxRotation);
var cosRotation = Math.cos(angle);
var sinRotation = Math.sin(angle);
var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
},
getLabelCapacity: function (exampleTime) {
var me = this;
var formatOverride = me.options.time.displayFormats.millisecond;
var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
var tickLabelWidth = me.getLabelWidth(exampleLabel);
var innerWidth = me.isHorizontal() ? me.width : me.height;
return Math.floor(innerWidth / tickLabelWidth);
}
});
Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
};
},
{
'1': 1,
'25': 25,
'45': 45
}
]
}, {}, [7])(7);
}));
(function () {
'use strict';
Polymer({
is: 'flight-graph',
properties: {
table: {
type: Object,
value: function () {
return null;
},
observer: '_tableChanged',
notify: true
},
colors: {
type: Array,
value: [
'#ec407a',
'#ef5350',
'#ab47bc',
'#7e57c2',
'#5c6bc0',
'#2196f3',
'#039be5',
'#0097a7',
'#009688',
'#43a047',
'#689f38',
'#cddc39',
'#ffeb3b',
'#ffc107',
'#ff9800'
]
},
chart: Object
},
_tableChanged: function (newTable) {
if (!newTable) {
return;
}
if (this.chart) {
this.chart.clear();
this.chart.destroy();
}
var labels = [];
var datasets = [];
if (newTable.z === 'TIME') {
var dataValues = [];
for (var day in newTable.data) {
labels.push(day);
dataValues.push(newTable.data[day][0]);
}
datasets = [{
label: newTable.y,
backgroundColor: this.colors[0],
data: dataValues
}];
} else {
labels = newTable.x;
datasets = this._createDatasets(newTable);
}
var ctx = this.$.chart.getContext('2d');
this.chart = new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
options: {
scales: {
yAxes: [{
ticks: { suggestedMin: 0 },
scaleLabel: {
display: true,
labelString: newTable.y
}
}],
xAxes: [{
scaleLabel: {
display: true,
labelString: 'Time'
}
}]
}
},
datasets: datasets
}
});
},
_createDatasets: function (data) {
var dataset = [];
if (Object.keys(data.data).length > 15) {
var tempData = {};
var keys = Object.keys(data.data).sort(function (a, b) {
var sumA = data.data[a].reduce(function (a, b) {
return a + b;
}, 0);
var sumB = data.data[b].reduce(function (a, b) {
return a + b;
}, 0);
return sumB - sumA;
}).map(function (elem, index, arr) {
return elem;
});
for (var i = 0; i < 15; i++) {
tempData[keys[i]] = data.data[keys[i]];
}
data.data = tempData;
this.fire('show-toast', 'More than 15 elements. Only first 15 can be shown.');
}
var counter = 0;
for (var dataElement in data.data) {
dataset.push({
label: dataElement,
backgroundColor: this.colors[counter++],
data: data.data[dataElement]
});
}
return dataset;
}
});
}());
function MakePromise(asap) {
function Promise(fn) {
if (typeof this !== 'object' || typeof fn !== 'function')
throw new TypeError();
this._state = null;
this._value = null;
this._deferreds = [];
doResolve(fn, resolve.bind(this), reject.bind(this));
}
function handle(deferred) {
var me = this;
if (this._state === null) {
this._deferreds.push(deferred);
return;
}
asap(function () {
var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
if (typeof cb !== 'function') {
(me._state ? deferred.resolve : deferred.reject)(me._value);
return;
}
var ret;
try {
ret = cb(me._value);
} catch (e) {
deferred.reject(e);
return;
}
deferred.resolve(ret);
});
}
function resolve(newValue) {
try {
if (newValue === this)
throw new TypeError();
if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
var then = newValue.then;
if (typeof then === 'function') {
doResolve(then.bind(newValue), resolve.bind(this), reject.bind(this));
return;
}
}
this._state = true;
this._value = newValue;
finale.call(this);
} catch (e) {
reject.call(this, e);
}
}
function reject(newValue) {
this._state = false;
this._value = newValue;
finale.call(this);
}
function finale() {
for (var i = 0, len = this._deferreds.length; i < len; i++) {
handle.call(this, this._deferreds[i]);
}
this._deferreds = null;
}
function doResolve(fn, onFulfilled, onRejected) {
var done = false;
try {
fn(function (value) {
if (done)
return;
done = true;
onFulfilled(value);
}, function (reason) {
if (done)
return;
done = true;
onRejected(reason);
});
} catch (ex) {
if (done)
return;
done = true;
onRejected(ex);
}
}
Promise.prototype['catch'] = function (onRejected) {
return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
var me = this;
return new Promise(function (resolve, reject) {
handle.call(me, {
onFulfilled: onFulfilled,
onRejected: onRejected,
resolve: resolve,
reject: reject
});
});
};
Promise.resolve = function (value) {
if (value && typeof value === 'object' && value.constructor === Promise) {
return value;
}
return new Promise(function (resolve) {
resolve(value);
});
};
Promise.reject = function (value) {
return new Promise(function (resolve, reject) {
reject(value);
});
};
return Promise;
}
if (typeof module !== 'undefined') {
module.exports = MakePromise;
};
if (!window.Promise) {
window.Promise = MakePromise(Polymer.Base.async);
};
'use strict';
Polymer({
is: 'iron-request',
hostAttributes: { hidden: true },
properties: {
xhr: {
type: Object,
notify: true,
readOnly: true,
value: function () {
return new XMLHttpRequest();
}
},
response: {
type: Object,
notify: true,
readOnly: true,
value: function () {
return null;
}
},
status: {
type: Number,
notify: true,
readOnly: true,
value: 0
},
statusText: {
type: String,
notify: true,
readOnly: true,
value: ''
},
completes: {
type: Object,
readOnly: true,
notify: true,
value: function () {
return new Promise(function (resolve, reject) {
this.resolveCompletes = resolve;
this.rejectCompletes = reject;
}.bind(this));
}
},
progress: {
type: Object,
notify: true,
readOnly: true,
value: function () {
return {};
}
},
aborted: {
type: Boolean,
notify: true,
readOnly: true,
value: false
},
errored: {
type: Boolean,
notify: true,
readOnly: true,
value: false
},
timedOut: {
type: Boolean,
notify: true,
readOnly: true,
value: false
}
},
get succeeded() {
if (this.errored || this.aborted || this.timedOut) {
return false;
}
var status = this.xhr.status || 0;
return status === 0 || status >= 200 && status < 300;
},
send: function (options) {
var xhr = this.xhr;
if (xhr.readyState > 0) {
return null;
}
xhr.addEventListener('progress', function (progress) {
this._setProgress({
lengthComputable: progress.lengthComputable,
loaded: progress.loaded,
total: progress.total
});
}.bind(this));
xhr.addEventListener('error', function (error) {
this._setErrored(true);
this._updateStatus();
this.rejectCompletes(error);
}.bind(this));
xhr.addEventListener('timeout', function (error) {
this._setTimedOut(true);
this._updateStatus();
this.rejectCompletes(error);
}.bind(this));
xhr.addEventListener('abort', function () {
this._updateStatus();
this.rejectCompletes(new Error('Request aborted.'));
}.bind(this));
xhr.addEventListener('loadend', function () {
this._updateStatus();
this._setResponse(this.parseResponse());
if (!this.succeeded) {
this.rejectCompletes(new Error('The request failed with status code: ' + this.xhr.status));
return;
}
this.resolveCompletes(this);
}.bind(this));
this.url = options.url;
xhr.open(options.method || 'GET', options.url, options.async !== false);
var acceptType = {
'json': 'application/json',
'text': 'text/plain',
'html': 'text/html',
'xml': 'application/xml',
'arraybuffer': 'application/octet-stream'
}[options.handleAs];
var headers = options.headers || Object.create(null);
var newHeaders = Object.create(null);
for (var key in headers) {
newHeaders[key.toLowerCase()] = headers[key];
}
headers = newHeaders;
if (acceptType && !headers['accept']) {
headers['accept'] = acceptType;
}
Object.keys(headers).forEach(function (requestHeader) {
if (/[A-Z]/.test(requestHeader)) {
Polymer.Base._error('Headers must be lower case, got', requestHeader);
}
xhr.setRequestHeader(requestHeader, headers[requestHeader]);
}, this);
if (options.async !== false) {
if (options.async) {
xhr.timeout = options.timeout;
}
var handleAs = options.handleAs;
if (!!options.jsonPrefix || !handleAs) {
handleAs = 'text';
}
xhr.responseType = xhr._responseType = handleAs;
if (!!options.jsonPrefix) {
xhr._jsonPrefix = options.jsonPrefix;
}
}
xhr.withCredentials = !!options.withCredentials;
var body = this._encodeBodyObject(options.body, headers['content-type']);
xhr.send(body);
return this.completes;
},
parseResponse: function () {
var xhr = this.xhr;
var responseType = xhr.responseType || xhr._responseType;
var preferResponseText = !this.xhr.responseType;
var prefixLen = xhr._jsonPrefix && xhr._jsonPrefix.length || 0;
try {
switch (responseType) {
case 'json':
if (preferResponseText || xhr.response === undefined) {
try {
return JSON.parse(xhr.responseText);
} catch (_) {
return null;
}
}
return xhr.response;
case 'xml':
return xhr.responseXML;
case 'blob':
case 'document':
case 'arraybuffer':
return xhr.response;
case 'text':
default: {
if (prefixLen) {
try {
return JSON.parse(xhr.responseText.substring(prefixLen));
} catch (_) {
return null;
}
}
return xhr.responseText;
}
}
} catch (e) {
this.rejectCompletes(new Error('Could not parse response. ' + e.message));
}
},
abort: function () {
this._setAborted(true);
this.xhr.abort();
},
_encodeBodyObject: function (body, contentType) {
if (typeof body == 'string') {
return body;
}
var bodyObj = body;
switch (contentType) {
case 'application/json':
return JSON.stringify(bodyObj);
case 'application/x-www-form-urlencoded':
return this._wwwFormUrlEncode(bodyObj);
}
return body;
},
_wwwFormUrlEncode: function (object) {
if (!object) {
return '';
}
var pieces = [];
Object.keys(object).forEach(function (key) {
pieces.push(this._wwwFormUrlEncodePiece(key) + '=' + this._wwwFormUrlEncodePiece(object[key]));
}, this);
return pieces.join('&');
},
_wwwFormUrlEncodePiece: function (str) {
if (str === null) {
return '';
}
return encodeURIComponent(str.toString().replace(/\r?\n/g, '\r\n')).replace(/%20/g, '+');
},
_updateStatus: function () {
this._setStatus(this.xhr.status);
this._setStatusText(this.xhr.statusText === undefined ? '' : this.xhr.statusText);
}
});
'use strict';
Polymer({
is: 'iron-ajax',
hostAttributes: { hidden: true },
properties: {
url: { type: String },
params: {
type: Object,
value: function () {
return {};
}
},
method: {
type: String,
value: 'GET'
},
headers: {
type: Object,
value: function () {
return {};
}
},
contentType: {
type: String,
value: null
},
body: {
type: Object,
value: null
},
sync: {
type: Boolean,
value: false
},
handleAs: {
type: String,
value: 'json'
},
withCredentials: {
type: Boolean,
value: false
},
timeout: {
type: Number,
value: 0
},
auto: {
type: Boolean,
value: false
},
verbose: {
type: Boolean,
value: false
},
lastRequest: {
type: Object,
notify: true,
readOnly: true
},
loading: {
type: Boolean,
notify: true,
readOnly: true
},
lastResponse: {
type: Object,
notify: true,
readOnly: true
},
lastError: {
type: Object,
notify: true,
readOnly: true
},
activeRequests: {
type: Array,
notify: true,
readOnly: true,
value: function () {
return [];
}
},
debounceDuration: {
type: Number,
value: 0,
notify: true
},
jsonPrefix: {
type: String,
value: ''
},
bubbles: {
type: Boolean,
value: false
},
_boundHandleResponse: {
type: Function,
value: function () {
return this._handleResponse.bind(this);
}
}
},
observers: ['_requestOptionsChanged(url, method, params.*, headers, contentType, ' + 'body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)'],
get queryString() {
var queryParts = [];
var param;
var value;
for (param in this.params) {
value = this.params[param];
param = window.encodeURIComponent(param);
if (Array.isArray(value)) {
for (var i = 0; i < value.length; i++) {
queryParts.push(param + '=' + window.encodeURIComponent(value[i]));
}
} else if (value !== null) {
queryParts.push(param + '=' + window.encodeURIComponent(value));
} else {
queryParts.push(param);
}
}
return queryParts.join('&');
},
get requestUrl() {
var queryString = this.queryString;
var url = this.url || '';
if (queryString) {
var bindingChar = url.indexOf('?') >= 0 ? '&' : '?';
return url + bindingChar + queryString;
}
return url;
},
get requestHeaders() {
var headers = {};
var contentType = this.contentType;
if (contentType == null && typeof this.body === 'string') {
contentType = 'application/x-www-form-urlencoded';
}
if (contentType) {
headers['content-type'] = contentType;
}
var header;
if (this.headers instanceof Object) {
for (header in this.headers) {
headers[header] = this.headers[header].toString();
}
}
return headers;
},
toRequestOptions: function () {
return {
url: this.requestUrl || '',
method: this.method,
headers: this.requestHeaders,
body: this.body,
async: !this.sync,
handleAs: this.handleAs,
jsonPrefix: this.jsonPrefix,
withCredentials: this.withCredentials,
timeout: this.timeout
};
},
generateRequest: function () {
var request = document.createElement('iron-request');
var requestOptions = this.toRequestOptions();
this.push('activeRequests', request);
request.completes.then(this._boundHandleResponse).catch(this._handleError.bind(this, request)).then(this._discardRequest.bind(this, request));
request.send(requestOptions);
this._setLastRequest(request);
this._setLoading(true);
this.fire('request', {
request: request,
options: requestOptions
}, { bubbles: this.bubbles });
this.fire('iron-ajax-request', {
request: request,
options: requestOptions
}, { bubbles: this.bubbles });
return request;
},
_handleResponse: function (request) {
if (request === this.lastRequest) {
this._setLastResponse(request.response);
this._setLastError(null);
this._setLoading(false);
}
this.fire('response', request, { bubbles: this.bubbles });
this.fire('iron-ajax-response', request, { bubbles: this.bubbles });
},
_handleError: function (request, error) {
if (this.verbose) {
Polymer.Base._error(error);
}
if (request === this.lastRequest) {
this._setLastError({
request: request,
error: error,
status: request.xhr.status,
statusText: request.xhr.statusText,
response: request.xhr.response
});
this._setLastResponse(null);
this._setLoading(false);
}
this.fire('iron-ajax-error', {
request: request,
error: error
}, { bubbles: this.bubbles });
this.fire('error', {
request: request,
error: error
}, { bubbles: this.bubbles });
},
_discardRequest: function (request) {
var requestIndex = this.activeRequests.indexOf(request);
if (requestIndex > -1) {
this.splice('activeRequests', requestIndex, 1);
}
},
_requestOptionsChanged: function () {
this.debounce('generate-request', function () {
if (this.url == null) {
return;
}
if (this.auto) {
this.generateRequest();
}
}, this.debounceDuration);
}
});
(function () {
'use strict';
Polymer({
is: 'settings-data',
properties: {
username: String,
baseUrl: String,
settings: {
type: Array,
notify: true
},
active: {
type: Boolean,
notify: true
}
},
save: function (setting) {
setting.creator = this.username;
var ajaxel = this.$.ajaxSaveSettings;
ajaxel.body = setting;
ajaxel.generateRequest();
},
getAll: function () {
this.$.ajaxGetSettings.params = { name: this.username };
this.$.ajaxGetSettings.generateRequest();
},
_responseHandlerSave: function () {
this.fire('show-toast', 'Successfully saved setting.');
},
_responseHandlerLoad: function (event) {
var content = event.detail.response._embedded.settings;
content.forEach(function (setting) {
setting.rangeFrom = setting.rangeFrom.split('T')[0];
setting.rangeTo = setting.rangeTo.split('T')[0];
});
console.log(content);
this.set('settings', content);
},
_errorHandler: function (e) {
var message = e.detail.error.message == null ? 'An error occured performing your request.' : e.detail.error.message;
this.fire('show-toast', message);
}
});
}());
(function () {
'use strict';
Polymer({
is: 'graph-page',
properties: {
airlines: Array,
markets: Array,
table: Object,
currentPage: {
type: String,
observer: 'ready'
}
},
ready: function () {
if (this.currentPage === 'graph') {
this.fire('load-airlines-markets');
}
}
});
}());
(function () {
var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
var DEFAULT_PHYSICAL_COUNT = 3;
var HIDDEN_Y = '-10000px';
var ITEM_WIDTH = 0;
var ITEM_HEIGHT = 1;
var SECRET_TABINDEX = -100;
Polymer({
is: 'iron-list',
properties: {
items: { type: Array },
maxPhysicalCount: {
type: Number,
value: 500
},
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
selectedAs: {
type: String,
value: 'selected'
},
grid: {
type: Boolean,
value: false,
reflectToAttribute: true
},
selectionEnabled: {
type: Boolean,
value: false
},
selectedItem: {
type: Object,
notify: true
},
selectedItems: {
type: Object,
notify: true
},
multiSelection: {
type: Boolean,
value: false
},
scrollOffset: {
type: Number,
value: 0
}
},
observers: [
'_itemsChanged(items.*)',
'_selectionEnabledChanged(selectionEnabled)',
'_multiSelectionChanged(multiSelection)',
'_setOverflow(scrollTarget, scrollOffset)'
],
behaviors: [
Polymer.Templatizer,
Polymer.IronResizableBehavior,
Polymer.IronA11yKeysBehavior,
Polymer.IronScrollTargetBehavior
],
keyBindings: {
'up': '_didMoveUp',
'down': '_didMoveDown',
'enter': '_didEnter'
},
_ratio: 0.5,
_scrollerPaddingTop: 0,
_scrollPosition: 0,
_physicalSize: 0,
_physicalAverage: 0,
_physicalAverageCount: 0,
_physicalTop: 0,
_virtualCount: 0,
_physicalIndexForKey: null,
_estScrollHeight: 0,
_scrollHeight: 0,
_viewportHeight: 0,
_viewportWidth: 0,
_physicalItems: null,
_physicalSizes: null,
_firstVisibleIndexVal: null,
_lastVisibleIndexVal: null,
_collection: null,
_maxPages: 2,
_focusedItem: null,
_focusedIndex: -1,
_offscreenFocusedItem: null,
_focusBackfillItem: null,
_itemsPerRow: 1,
_itemWidth: 0,
_rowHeight: 0,
_templateCost: 0,
get _physicalBottom() {
return this._physicalTop + this._physicalSize;
},
get _scrollBottom() {
return this._scrollPosition + this._viewportHeight;
},
get _virtualEnd() {
return this._virtualStart + this._physicalCount - 1;
},
get _hiddenContentSize() {
var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;
return size - this._viewportHeight;
},
get _itemsParent() {
return Polymer.dom(Polymer.dom(this._userTemplate).parentNode);
},
get _maxScrollTop() {
return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
},
_minVirtualStart: 0,
get _maxVirtualStart() {
return Math.max(0, this._virtualCount - this._physicalCount);
},
_virtualStartVal: 0,
set _virtualStart(val) {
val = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
if (this.grid) {
val = val - val % this._itemsPerRow;
}
this._virtualStartVal = val;
},
get _virtualStart() {
return this._virtualStartVal || 0;
},
_physicalStartVal: 0,
set _physicalStart(val) {
val = val % this._physicalCount;
if (val < 0) {
val = this._physicalCount + val;
}
if (this.grid) {
val = val - val % this._itemsPerRow;
}
this._physicalStartVal = val;
this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
},
get _physicalStart() {
return this._physicalStartVal || 0;
},
_physicalCountVal: 0,
set _physicalCount(val) {
this._physicalCountVal = val;
this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
},
get _physicalCount() {
return this._physicalCountVal;
},
_physicalEnd: 0,
get _optPhysicalSize() {
if (this.grid) {
return this._estRowsInView * this._rowHeight * this._maxPages;
}
return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;
},
get _isVisible() {
return Boolean(this.offsetWidth || this.offsetHeight);
},
get firstVisibleIndex() {
var idx = this._firstVisibleIndexVal;
if (idx == null) {
var physicalOffset = this._physicalTop + this._scrollOffset;
idx = this._iterateItems(function (pidx, vidx) {
physicalOffset += this._getPhysicalSizeIncrement(pidx);
if (physicalOffset > this._scrollPosition) {
return this.grid ? vidx - vidx % this._itemsPerRow : vidx;
}
if (this.grid && this._virtualCount - 1 === vidx) {
return vidx - vidx % this._itemsPerRow;
}
}) || 0;
this._firstVisibleIndexVal = idx;
}
return idx;
},
get lastVisibleIndex() {
var idx = this._lastVisibleIndexVal;
if (idx == null) {
if (this.grid) {
idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);
} else {
var physicalOffset = this._physicalTop + this._scrollOffset;
this._iterateItems(function (pidx, vidx) {
if (physicalOffset < this._scrollBottom) {
idx = vidx;
}
physicalOffset += this._getPhysicalSizeIncrement(pidx);
});
}
this._lastVisibleIndexVal = idx;
}
return idx;
},
get _defaultScrollTarget() {
return this;
},
get _virtualRowCount() {
return Math.ceil(this._virtualCount / this._itemsPerRow);
},
get _estRowsInView() {
return Math.ceil(this._viewportHeight / this._rowHeight);
},
get _physicalRows() {
return Math.ceil(this._physicalCount / this._itemsPerRow);
},
get _scrollOffset() {
return this._scrollerPaddingTop + this.scrollOffset;
},
ready: function () {
this.addEventListener('focus', this._didFocus.bind(this), true);
},
attached: function () {
if (this._physicalCount === 0) {
this._debounceTemplate(this._render);
}
this.listen(this, 'iron-resize', '_resizeHandler');
},
detached: function () {
this.unlisten(this, 'iron-resize', '_resizeHandler');
},
_setOverflow: function (scrollTarget) {
this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';
this.style.overflow = scrollTarget === this ? 'auto' : '';
this._lastVisibleIndexVal = null;
this._firstVisibleIndexVal = null;
this._debounceTemplate(this._render);
},
updateViewportBoundaries: function () {
var styles = window.getComputedStyle(this);
this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);
this._isRTL = Boolean(styles.direction === 'rtl');
this._viewportWidth = this.$.items.offsetWidth;
this._viewportHeight = this._scrollTargetHeight;
this.grid && this._updateGridMetrics();
},
_scrollHandler: function () {
var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
var delta = scrollTop - this._scrollPosition;
var isScrollingDown = delta >= 0;
this._scrollPosition = scrollTop;
this._firstVisibleIndexVal = null;
this._lastVisibleIndexVal = null;
if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {
delta = delta - this._scrollOffset;
var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;
this._virtualStart = this._virtualStart + idxAdjustment;
this._physicalStart = this._physicalStart + idxAdjustment;
this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;
this._update();
} else {
var reusables = this._getReusables(isScrollingDown);
if (isScrollingDown) {
this._physicalTop = reusables.physicalTop;
this._virtualStart = this._virtualStart + reusables.indexes.length;
this._physicalStart = this._physicalStart + reusables.indexes.length;
} else {
this._virtualStart = this._virtualStart - reusables.indexes.length;
this._physicalStart = this._physicalStart - reusables.indexes.length;
}
if (reusables.indexes.length === 0) {
this._increasePoolIfNeeded();
} else {
this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);
}
}
},
_getReusables: function (fromTop) {
var ith, lastIth, offsetContent, physicalItemHeight;
var idxs = [];
var protectedOffsetContent = this._hiddenContentSize * this._ratio;
var virtualStart = this._virtualStart;
var virtualEnd = this._virtualEnd;
var physicalCount = this._physicalCount;
var top = this._physicalTop + this._scrollOffset;
var bottom = this._physicalBottom + this._scrollOffset;
var scrollTop = this._scrollTop;
var scrollBottom = this._scrollBottom;
if (fromTop) {
ith = this._physicalStart;
lastIth = this._physicalEnd;
offsetContent = scrollTop - top;
} else {
ith = this._physicalEnd;
lastIth = this._physicalStart;
offsetContent = bottom - scrollBottom;
}
while (true) {
physicalItemHeight = this._getPhysicalSizeIncrement(ith);
offsetContent = offsetContent - physicalItemHeight;
if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {
break;
}
if (fromTop) {
if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
break;
}
if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {
break;
}
idxs.push(ith);
top = top + physicalItemHeight;
ith = (ith + 1) % physicalCount;
} else {
if (virtualStart - idxs.length <= 0) {
break;
}
if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {
break;
}
idxs.push(ith);
top = top - physicalItemHeight;
ith = ith === 0 ? physicalCount - 1 : ith - 1;
}
}
return {
indexes: idxs,
physicalTop: top - this._scrollOffset
};
},
_update: function (itemSet, movingUp) {
if (itemSet && itemSet.length === 0) {
return;
}
this._manageFocus();
this._assignModels(itemSet);
this._updateMetrics(itemSet);
if (movingUp) {
while (movingUp.length) {
var idx = movingUp.pop();
this._physicalTop -= this._getPhysicalSizeIncrement(idx);
}
}
this._positionItems();
this._updateScrollerSize();
this._increasePoolIfNeeded();
},
_createPool: function (size) {
var physicalItems = new Array(size);
this._ensureTemplatized();
for (var i = 0; i < size; i++) {
var inst = this.stamp(null);
physicalItems[i] = inst.root.querySelector('*');
this._itemsParent.appendChild(inst.root);
}
return physicalItems;
},
_increasePoolIfNeeded: function () {
var self = this;
var isClientFull = this._physicalBottom + this._scrollOffset >= this._scrollBottom && this._physicalTop - this._scrollOffset <= this._scrollPosition;
if (this._physicalSize >= this._optPhysicalSize && isClientFull) {
return false;
}
var maxPoolSize = Math.round(this._physicalCount * 0.5);
if (!isClientFull) {
this._debounceTemplate(this._increasePool.bind(this, maxPoolSize));
return true;
}
this._yield(function () {
self._increasePool(Math.min(maxPoolSize, Math.max(1, Math.round(50 / self._templateCost))));
});
return true;
},
_yield: function (cb) {
var g = window;
var handle = g.requestIdleCallback ? g.requestIdleCallback(cb) : g.setTimeout(cb, 16);
Polymer.dom.addDebouncer({
complete: function () {
g.cancelIdleCallback ? g.cancelIdleCallback(handle) : g.clearTimeout(handle);
cb();
}
});
},
_increasePool: function (missingItems) {
var nextPhysicalCount = Math.min(this._physicalCount + missingItems, this._virtualCount - this._virtualStart, Math.max(this.maxPhysicalCount, DEFAULT_PHYSICAL_COUNT));
var prevPhysicalCount = this._physicalCount;
var delta = nextPhysicalCount - prevPhysicalCount;
var ts = window.performance.now();
if (delta <= 0) {
return;
}
[].push.apply(this._physicalItems, this._createPool(delta));
[].push.apply(this._physicalSizes, new Array(delta));
this._physicalCount = prevPhysicalCount + delta;
if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedIndex) && this._getPhysicalIndex(this._focusedIndex) < this._physicalEnd) {
this._physicalStart = this._physicalStart + delta;
}
this._update();
this._templateCost = (window.performance.now() - ts) / delta;
},
_render: function () {
if (this.isAttached && this._isVisible) {
if (this._physicalCount === 0) {
this.updateViewportBoundaries();
this._increasePool(DEFAULT_PHYSICAL_COUNT);
} else {
var reusables = this._getReusables(true);
this._physicalTop = reusables.physicalTop;
this._virtualStart = this._virtualStart + reusables.indexes.length;
this._physicalStart = this._physicalStart + reusables.indexes.length;
this._update(reusables.indexes);
this._update();
}
}
},
_ensureTemplatized: function () {
if (!this.ctor) {
var props = {};
props.__key__ = true;
props[this.as] = true;
props[this.indexAs] = true;
props[this.selectedAs] = true;
props.tabIndex = true;
this._instanceProps = props;
this._userTemplate = this.queryEffectiveChildren('template');
if (this._userTemplate) {
this.templatize(this._userTemplate);
} else {
console.warn('iron-list requires a template to be provided in light-dom');
}
}
},
_getStampedChildren: function () {
return this._physicalItems;
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
(this._physicalItems || []).concat([
this._offscreenFocusedItem,
this._focusBackfillItem
]).forEach(function (item) {
if (item) {
item._templateInstance[prop] = value;
}
});
},
_forwardParentPath: function (path, value) {
(this._physicalItems || []).concat([
this._offscreenFocusedItem,
this._focusBackfillItem
]).forEach(function (item) {
if (item) {
item._templateInstance.notifyPath(path, value, true);
}
});
},
_forwardItemPath: function (path, value) {
if (!this._physicalIndexForKey) {
return;
}
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._physicalIndexForKey[key];
var offscreenItem = this._offscreenFocusedItem;
var el = offscreenItem && offscreenItem._templateInstance.__key__ === key ? offscreenItem : this._physicalItems[idx];
if (!el || el._templateInstance.__key__ !== key) {
return;
}
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
el._templateInstance.notifyPath(path, value, true);
} else {
var currentItem = el._templateInstance[this.as];
if (Array.isArray(this.selectedItems)) {
for (var i = 0; i < this.selectedItems.length; i++) {
if (this.selectedItems[i] === currentItem) {
this.set('selectedItems.' + i, value);
break;
}
}
} else if (this.selectedItem === currentItem) {
this.set('selectedItem', value);
}
el._templateInstance[this.as] = value;
}
},
_itemsChanged: function (change) {
if (change.path === 'items') {
this._virtualStart = 0;
this._physicalTop = 0;
this._virtualCount = this.items ? this.items.length : 0;
this._collection = this.items ? Polymer.Collection.get(this.items) : null;
this._physicalIndexForKey = {};
this._firstVisibleIndexVal = null;
this._lastVisibleIndexVal = null;
this._physicalCount = this._physicalCount || 0;
this._physicalItems = this._physicalItems || [];
this._physicalSizes = this._physicalSizes || [];
this._physicalStart = 0;
if (this._scrollTop > this._scrollOffset) {
this._resetScrollPosition(0);
}
this._removeFocusedItem();
this._debounceTemplate(this._render);
} else if (change.path === 'items.splices') {
this._adjustVirtualIndex(change.value.indexSplices);
this._virtualCount = this.items ? this.items.length : 0;
this._debounceTemplate(this._render);
} else {
this._forwardItemPath(change.path.split('.').slice(1).join('.'), change.value);
}
},
_adjustVirtualIndex: function (splices) {
splices.forEach(function (splice) {
splice.removed.forEach(this._removeItem, this);
if (splice.index < this._virtualStart) {
var delta = Math.max(splice.addedCount - splice.removed.length, splice.index - this._virtualStart);
this._virtualStart = this._virtualStart + delta;
if (this._focusedIndex >= 0) {
this._focusedIndex = this._focusedIndex + delta;
}
}
}, this);
},
_removeItem: function (item) {
this.$.selector.deselect(item);
if (this._focusedItem && this._focusedItem._templateInstance[this.as] === item) {
this._removeFocusedItem();
}
},
_iterateItems: function (fn, itemSet) {
var pidx, vidx, rtn, i;
if (arguments.length === 2 && itemSet) {
for (i = 0; i < itemSet.length; i++) {
pidx = itemSet[i];
vidx = this._computeVidx(pidx);
if ((rtn = fn.call(this, pidx, vidx)) != null) {
return rtn;
}
}
} else {
pidx = this._physicalStart;
vidx = this._virtualStart;
for (; pidx < this._physicalCount; pidx++, vidx++) {
if ((rtn = fn.call(this, pidx, vidx)) != null) {
return rtn;
}
}
for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
if ((rtn = fn.call(this, pidx, vidx)) != null) {
return rtn;
}
}
}
},
_computeVidx: function (pidx) {
if (pidx >= this._physicalStart) {
return this._virtualStart + (pidx - this._physicalStart);
}
return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
},
_assignModels: function (itemSet) {
this._iterateItems(function (pidx, vidx) {
var el = this._physicalItems[pidx];
var inst = el._templateInstance;
var item = this.items && this.items[vidx];
if (item != null) {
inst[this.as] = item;
inst.__key__ = this._collection.getKey(item);
inst[this.selectedAs] = this.$.selector.isSelected(item);
inst[this.indexAs] = vidx;
inst.tabIndex = this._focusedIndex === vidx ? 0 : -1;
this._physicalIndexForKey[inst.__key__] = pidx;
el.removeAttribute('hidden');
} else {
inst.__key__ = null;
el.setAttribute('hidden', '');
}
}, itemSet);
},
_updateMetrics: function (itemSet) {
Polymer.dom.flush();
var newPhysicalSize = 0;
var oldPhysicalSize = 0;
var prevAvgCount = this._physicalAverageCount;
var prevPhysicalAvg = this._physicalAverage;
this._iterateItems(function (pidx, vidx) {
oldPhysicalSize += this._physicalSizes[pidx] || 0;
this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
newPhysicalSize += this._physicalSizes[pidx];
this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
}, itemSet);
if (this.grid) {
this._updateGridMetrics();
this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;
} else {
this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
}
if (this._physicalAverageCount !== prevAvgCount) {
this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);
}
},
_updateGridMetrics: function () {
this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;
this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;
this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;
},
_positionItems: function () {
this._adjustScrollPosition();
var y = this._physicalTop;
if (this.grid) {
var totalItemWidth = this._itemsPerRow * this._itemWidth;
var rowOffset = (this._viewportWidth - totalItemWidth) / 2;
this._iterateItems(function (pidx, vidx) {
var modulus = vidx % this._itemsPerRow;
var x = Math.floor(modulus * this._itemWidth + rowOffset);
if (this._isRTL) {
x = x * -1;
}
this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);
if (this._shouldRenderNextRow(vidx)) {
y += this._rowHeight;
}
});
} else {
this._iterateItems(function (pidx, vidx) {
this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);
y += this._physicalSizes[pidx];
});
}
},
_getPhysicalSizeIncrement: function (pidx) {
if (!this.grid) {
return this._physicalSizes[pidx];
}
if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {
return 0;
}
return this._rowHeight;
},
_shouldRenderNextRow: function (vidx) {
return vidx % this._itemsPerRow === this._itemsPerRow - 1;
},
_adjustScrollPosition: function () {
var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
if (deltaHeight !== 0) {
this._physicalTop = this._physicalTop - deltaHeight;
var scrollTop = this._scrollTop;
if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {
this._resetScrollPosition(scrollTop - deltaHeight);
}
}
},
_resetScrollPosition: function (pos) {
if (this.scrollTarget && pos >= 0) {
this._scrollTop = pos;
this._scrollPosition = this._scrollTop;
}
},
_updateScrollerSize: function (forceUpdate) {
if (this.grid) {
this._estScrollHeight = this._virtualRowCount * this._rowHeight;
} else {
this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
}
forceUpdate = forceUpdate || this._scrollHeight === 0;
forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;
forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight;
if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
this.$.items.style.height = this._estScrollHeight + 'px';
this._scrollHeight = this._estScrollHeight;
}
},
scrollToItem: function (item) {
return this.scrollToIndex(this.items.indexOf(item));
},
scrollToIndex: function (idx) {
if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {
return;
}
Polymer.dom.flush();
if (this._physicalCount === 0) {
return;
}
idx = Math.min(Math.max(idx, 0), this._virtualCount - 1);
if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
this._virtualStart = this.grid ? idx - this._itemsPerRow * 2 : idx - 1;
}
this._manageFocus();
this._assignModels();
this._updateMetrics();
this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;
var currentTopItem = this._physicalStart;
var currentVirtualItem = this._virtualStart;
var targetOffsetTop = 0;
var hiddenContentSize = this._hiddenContentSize;
while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
currentTopItem = (currentTopItem + 1) % this._physicalCount;
currentVirtualItem++;
}
this._updateScrollerSize(true);
this._positionItems();
this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);
this._increasePoolIfNeeded();
this._firstVisibleIndexVal = null;
this._lastVisibleIndexVal = null;
},
_resetAverage: function () {
this._physicalAverage = 0;
this._physicalAverageCount = 0;
},
_resizeHandler: function () {
this._debounceTemplate(function () {
var delta = Math.abs(this._viewportHeight - this._scrollTargetHeight);
this.updateViewportBoundaries();
if (('ontouchstart' in window || navigator.maxTouchPoints > 0) && delta > 0 && delta < 100) {
return;
}
if (this._isVisible) {
this.toggleScrollListener(true);
this._resetAverage();
this._render();
} else {
this.toggleScrollListener(false);
}
}.bind(this));
},
_getModelFromItem: function (item) {
var key = this._collection.getKey(item);
var pidx = this._physicalIndexForKey[key];
if (pidx != null) {
return this._physicalItems[pidx]._templateInstance;
}
return null;
},
_getNormalizedItem: function (item) {
if (this._collection.getKey(item) === undefined) {
if (typeof item === 'number') {
item = this.items[item];
if (!item) {
throw new RangeError('<item> not found');
}
return item;
}
throw new TypeError('<item> should be a valid item');
}
return item;
},
selectItem: function (item) {
item = this._getNormalizedItem(item);
var model = this._getModelFromItem(item);
if (!this.multiSelection && this.selectedItem) {
this.deselectItem(this.selectedItem);
}
if (model) {
model[this.selectedAs] = true;
}
this.$.selector.select(item);
this.updateSizeForItem(item);
},
deselectItem: function (item) {
item = this._getNormalizedItem(item);
var model = this._getModelFromItem(item);
if (model) {
model[this.selectedAs] = false;
}
this.$.selector.deselect(item);
this.updateSizeForItem(item);
},
toggleSelectionForItem: function (item) {
item = this._getNormalizedItem(item);
if (this.$.selector.isSelected(item)) {
this.deselectItem(item);
} else {
this.selectItem(item);
}
},
clearSelection: function () {
function unselect(item) {
var model = this._getModelFromItem(item);
if (model) {
model[this.selectedAs] = false;
}
}
if (Array.isArray(this.selectedItems)) {
this.selectedItems.forEach(unselect, this);
} else if (this.selectedItem) {
unselect.call(this, this.selectedItem);
}
this.$.selector.clearSelection();
},
_selectionEnabledChanged: function (selectionEnabled) {
var handler = selectionEnabled ? this.listen : this.unlisten;
handler.call(this, this, 'tap', '_selectionHandler');
},
_selectionHandler: function (e) {
var model = this.modelForElement(e.target);
if (!model) {
return;
}
var modelTabIndex, activeElTabIndex;
var target = Polymer.dom(e).path[0];
var itemsHost = this._itemsParent.node.domHost;
var activeEl = Polymer.dom(itemsHost ? itemsHost.root : document).activeElement;
var physicalItem = this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];
if (target.localName === 'input' || target.localName === 'button' || target.localName === 'select') {
return;
}
modelTabIndex = model.tabIndex;
model.tabIndex = SECRET_TABINDEX;
activeElTabIndex = activeEl ? activeEl.tabIndex : -1;
model.tabIndex = modelTabIndex;
if (activeEl && physicalItem !== activeEl && physicalItem.contains(activeEl) && activeElTabIndex !== SECRET_TABINDEX) {
return;
}
this.toggleSelectionForItem(model[this.as]);
},
_multiSelectionChanged: function (multiSelection) {
this.clearSelection();
this.$.selector.multi = multiSelection;
},
updateSizeForItem: function (item) {
item = this._getNormalizedItem(item);
var key = this._collection.getKey(item);
var pidx = this._physicalIndexForKey[key];
if (pidx != null) {
this._updateMetrics([pidx]);
this._positionItems();
}
},
_manageFocus: function () {
var fidx = this._focusedIndex;
if (fidx >= 0 && fidx < this._virtualCount) {
if (this._isIndexRendered(fidx)) {
this._restoreFocusedItem();
} else {
this._createFocusBackfillItem();
}
} else if (this._virtualCount > 0 && this._physicalCount > 0) {
this._focusedIndex = this._virtualStart;
this._focusedItem = this._physicalItems[this._physicalStart];
}
},
_isIndexRendered: function (idx) {
return idx >= this._virtualStart && idx <= this._virtualEnd;
},
_isIndexVisible: function (idx) {
return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
},
_getPhysicalIndex: function (idx) {
return this._physicalIndexForKey[this._collection.getKey(this._getNormalizedItem(idx))];
},
_focusPhysicalItem: function (idx) {
if (idx < 0 || idx >= this._virtualCount) {
return;
}
this._restoreFocusedItem();
if (!this._isIndexRendered(idx)) {
this.scrollToIndex(idx);
}
var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];
var model = physicalItem._templateInstance;
var focusable;
model.tabIndex = SECRET_TABINDEX;
if (physicalItem.tabIndex === SECRET_TABINDEX) {
focusable = physicalItem;
}
if (!focusable) {
focusable = Polymer.dom(physicalItem).querySelector('[tabindex="' + SECRET_TABINDEX + '"]');
}
model.tabIndex = 0;
this._focusedIndex = idx;
focusable && focusable.focus();
},
_removeFocusedItem: function () {
if (this._offscreenFocusedItem) {
this._itemsParent.removeChild(this._offscreenFocusedItem);
}
this._offscreenFocusedItem = null;
this._focusBackfillItem = null;
this._focusedItem = null;
this._focusedIndex = -1;
},
_createFocusBackfillItem: function () {
var fidx = this._focusedIndex;
var pidx = this._getPhysicalIndex(fidx);
if (this._offscreenFocusedItem || pidx == null || fidx < 0) {
return;
}
if (!this._focusBackfillItem) {
var stampedTemplate = this.stamp(null);
this._focusBackfillItem = stampedTemplate.root.querySelector('*');
this._itemsParent.appendChild(stampedTemplate.root);
}
this._offscreenFocusedItem = this._physicalItems[pidx];
this._offscreenFocusedItem._templateInstance.tabIndex = 0;
this._physicalItems[pidx] = this._focusBackfillItem;
this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);
},
_restoreFocusedItem: function () {
var pidx, fidx = this._focusedIndex;
if (!this._offscreenFocusedItem || this._focusedIndex < 0) {
return;
}
this._assignModels();
pidx = this._getPhysicalIndex(fidx);
var onScreenItem = this._physicalItems[pidx];
if (!onScreenItem) {
return;
}
var onScreenInstance = onScreenItem._templateInstance;
var offScreenInstance = this._offscreenFocusedItem._templateInstance;
if (onScreenInstance.__key__ === offScreenInstance.__key__) {
this._focusBackfillItem = onScreenItem;
onScreenInstance.tabIndex = -1;
this._physicalItems[pidx] = this._offscreenFocusedItem;
this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);
} else {
this._removeFocusedItem();
this._focusBackfillItem = null;
}
this._offscreenFocusedItem = null;
},
_didFocus: function (e) {
var targetModel = this.modelForElement(e.target);
var focusedModel = this._focusedItem ? this._focusedItem._templateInstance : null;
var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;
var fidx = this._focusedIndex;
if (!targetModel || !focusedModel) {
return;
}
if (focusedModel === targetModel) {
if (!this._isIndexVisible(fidx)) {
this.scrollToIndex(fidx);
}
} else {
this._restoreFocusedItem();
focusedModel.tabIndex = -1;
targetModel.tabIndex = 0;
fidx = targetModel[this.indexAs];
this._focusedIndex = fidx;
this._focusedItem = this._physicalItems[this._getPhysicalIndex(fidx)];
if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {
this._update();
}
}
},
_didMoveUp: function () {
this._focusPhysicalItem(this._focusedIndex - 1);
},
_didMoveDown: function (e) {
e.detail.keyboardEvent.preventDefault();
this._focusPhysicalItem(this._focusedIndex + 1);
},
_didEnter: function (e) {
this._focusPhysicalItem(this._focusedIndex);
this._selectionHandler(e.detail.keyboardEvent);
}
});
}());
Polymer({
is: 'paper-fab',
behaviors: [Polymer.PaperButtonBehavior],
properties: {
src: {
type: String,
value: ''
},
icon: {
type: String,
value: ''
},
mini: {
type: Boolean,
value: false,
reflectToAttribute: true
},
label: {
type: String,
observer: '_labelChanged'
}
},
_labelChanged: function () {
this.setAttribute('aria-label', this.label);
},
_computeIsIconFab: function (icon, src) {
return icon.length > 0 || src.length > 0;
}
});
(function () {
'use strict';
Polymer({
is: 'settings-page',
properties: {
settings: { type: Array },
currentPage: {
type: String,
observer: 'ready'
}
},
ready: function () {
if (this.currentPage === 'settings') {
this.fire('load-settings');
}
},
_computeClass: function (selected) {
if (selected) {
return 'iron-selected';
}
return '';
},
_filter: function (settings, filter) {
if (!filter || (filter = filter.trim()).length === 0) {
return settings;
}
return settings.filter(function (item) {
var filtersubstring = filter.toLowerCase();
var namestring = item.name.toLowerCase();
var creatorstring = item.creator.toLowerCase();
return namestring.indexOf(filtersubstring) > -1 || creatorstring.indexOf(filtersubstring) > -1;
});
},
_isEmpty: function (arr) {
return arr.length == 0;
},
_select: function (e) {
var item = e.model.filter;
var flightfilter = document.querySelector('#flightfilter');
flightfilter.dataFilter = item;
this.fire('apply-setting', item);
this.fire('navigate', 'graph');
}
});
}());
Polymer.PaperSpinnerBehavior = {
listeners: {
'animationend': '__reset',
'webkitAnimationEnd': '__reset'
},
properties: {
active: {
type: Boolean,
value: false,
reflectToAttribute: true,
observer: '__activeChanged'
},
alt: {
type: String,
value: 'loading',
observer: '__altChanged'
},
__coolingDown: {
type: Boolean,
value: false
}
},
__computeContainerClasses: function (active, coolingDown) {
return [
active || coolingDown ? 'active' : '',
coolingDown ? 'cooldown' : ''
].join(' ');
},
__activeChanged: function (active, old) {
this.__setAriaHidden(!active);
this.__coolingDown = !active && old;
},
__altChanged: function (alt) {
if (alt === this.getPropertyInfo('alt').value) {
this.alt = this.getAttribute('aria-label') || alt;
} else {
this.__setAriaHidden(alt === '');
this.setAttribute('aria-label', alt);
}
},
__setAriaHidden: function (hidden) {
var attr = 'aria-hidden';
if (hidden) {
this.setAttribute(attr, 'true');
} else {
this.removeAttribute(attr);
}
},
__reset: function () {
this.active = false;
this.__coolingDown = false;
}
};
Polymer({
is: 'paper-spinner',
behaviors: [Polymer.PaperSpinnerBehavior]
});
(function () {
'use strict';
Polymer({
is: 'crawler-page',
properties: {
requesting: {
type: Boolean,
value: false,
notify: true
},
_crawlerStates: {
type: Array,
value: []
}
},
attached: function () {
this._reloadStates();
},
_getItemIcon: function (finished) {
return finished ? 'icons:cloud-done' : 'icons:cloud-download';
},
_hasData: function (states) {
return states.length != 0;
},
_errorHandler: function (e) {
var message = e.detail.error.message == null ? 'An error occured performing your request.' : e.detail.error.message;
this.fire('show-toast', message);
this._reloadStates();
},
_responseHandlerLoad: function (e) {
this.fire('show-toast', 'Job started successfully. It may take a few minutes for the data to be available in the graph.');
this._reloadStates();
},
_clearStates: function (e) {
this.$.clear.animate([
{
transform: 'translateX(0px)',
opacity: 1
},
{
transform: 'translateX(30px)',
opacity: 0
},
{
transform: 'translateX(-30px)',
opacity: 0
},
{
transform: 'translateX(0px)',
opacity: 1
}
], { duration: 700 });
fetch(new Request(this.baseUrl + 'clearStatus', { method: 'POST' })).then(function (response) {
if (response.ok) {
this._reloadStates();
} else {
console.log('Response was not OK!' + response);
}
});
},
_reloadStates: function (e) {
if (e) {
this.$.reload.animate([
{ transform: 'rotate(0)' },
{ transform: 'rotate(360deg)' }
], { duration: 1000 });
}
var that = this;
fetch(new Request(this.baseUrl + 'status', { method: 'GET' })).then(function (response) {
if (response.ok) {
response.json().then(function (data) {
that.set('_crawlerStates', data);
console.log(data);
});
} else {
console.log('Response was not OK!');
console.log(response);
}
});
},
_startCrawling: function (e) {
var timestamp = Date.parse(this.date);
var datefield = this.$.inputDate;
if (isNaN(timestamp) == false) {
var date = new Date(timestamp);
var today = new Date();
if (date > today) {
datefield.invalid = true;
return;
}
datefield.invalid = false;
var ajax = this.$.ajaxStartCrawler;
var params = {
year: date.getFullYear(),
month: date.getMonth() + 1
};
console.log(params);
ajax.params = params;
ajax.generateRequest();
} else {
datefield.invalid = true;
}
}
});
}());
(function () {
'use strict';
Polymer({
is: 'transtats-data',
properties: {
baseUrl: String,
markets: {
type: Array,
notify: true
},
airlines: {
type: Array,
notify: true
},
table: {
type: Object,
notify: true
},
setting: {
type: Object,
notify: true,
observer: '_settingChanged'
},
active: {
type: Boolean,
notify: true
}
},
loadAirlinesAndMarkets: function () {
this.$.ajaxGetAirlines.generateRequest();
this.$.ajaxGetMarkets.generateRequest();
},
_settingChanged: function (newSettings) {
this.$.postTable.body = newSettings;
this.$.postTable.generateRequest();
},
_loadMarkets: function (event) {
var markets = event.detail.response._embedded.markets;
this.set('markets', markets);
},
_loadAirlines: function (event) {
var airlines = event.detail.response._embedded.airlines;
this.set('airlines', airlines);
},
_loadTable: function (event) {
var table = event.detail.response;
console.log(table);
this.set('table', table);
},
_errorHandler: function (e) {
var message = e.detail.error.message == null ? 'Can\'t load the data.' : e.detail.error.message;
this.fire('show-toast', message);
}
});
}());
(function () {
'use strict';
Polymer({
is: 'flight-app',
properties: {
base: {
type: String,
value: 'https://orfap-backend.herokuapp.com/'
},
baseCrawler: {
type: String,
value: 'https://orfap-crawler.herokuapp.com/'
},
settings: {
type: Array,
notify: true
}
},
observers: ['_pageChanged(routeData.page)'],
listeners: {
'save-setting': '_saveSettingHandler',
'apply-setting': '_applySettingHandler',
'load-settings': '_loadSettingsHandler',
'load-airlines-markets': '_loadAirlinesMarketsHandler',
'show-toast': '_showToast',
'navigate': '_navigateHandler'
},
_pdfPrint: function () {
html2canvas(this.$.graphpage, {
onrendered: function (canvas) {
var imgData = canvas.toDataURL();
var imgWidth = 297;
var imgHeight = canvas.height * imgWidth / canvas.width;
var doc = new jsPDF('l', 'mm');
doc.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
var date = new Date();
doc.save('flightanalyzer_' + date.toISOString() + '.pdf');
}
});
},
_help: function () {
clippy.load('Clippy', function (agent) {
agent.moveTo(window.innerWidth - 150, 10, 0);
agent.show();
var x = Math.floor(Math.random() * window.innerWidth);
var y = Math.floor(Math.random() * window.innerHeight);
agent.moveTo(x, y);
var sentences = [
'It seems like you are trying to analyse some data. May I help you with that?',
'Want to fly with me?',
'Remember me?',
'What\'s up? Need help? RTFM!',
'Not enough data? Try the crawler!',
'Don\'t like the background color? Buy colored glasses!',
'Make sure to buy your admin coffee!',
'Like to see some data from outside US? Throw some money at your screen!',
'There is no life outside the US.',
'I will make america great (britain) again!',
'Follow ORFAP on github!'
];
agent.speak(sentences[Math.floor(Math.random() * sentences.length)]);
window.setTimeout(function (agent) {
agent.hide();
}, 8000, agent);
});
},
_pageChanged: function (page) {
var username = this._getCookie('username');
if (username) {
this.$.loginpage.username = username;
this.$.ironpages.selected = page;
} else {
this.$.ironpages.selected = '';
}
},
closeDrawer: function () {
this.$.drawer.close();
},
_logout: function () {
this.$.loginpage.username = '';
document.cookie = 'username=';
this.$.ironpages.selected = '';
},
_isLoginpage: function () {
return this.$.ironpages.selected === '';
},
_closeToast: function () {
this.$.toast.hide();
},
_applySettingHandler: function (e) {
this.$.transtatsData._settingChanged(e.detail);
},
_saveSettingHandler: function (e) {
this.$.settingsData.save(e.detail);
},
_loadSettingsHandler: function () {
this.$.settingsData.getAll();
},
_loadAirlinesMarketsHandler: function () {
this.$.transtatsData.loadAirlinesAndMarkets();
},
_showToast: function (e) {
var toast = this.$.toast;
toast.text = e.detail;
toast.show();
},
_navigateHandler: function (e) {
this.$.ironpages.selected = e.detail;
},
_getCookie: function (name) {
var value = '; ' + document.cookie;
var parts = value.split('; ' + name + '=');
if (parts.length == 2)
return parts.pop().split(';').shift();
}
});
}());